A graph data structure is a nonlinear 
data structure consisting of vertices  
and edges. They're used to solve many real 
world problems and are commonly needed to  
solve coding challenges. Harris from coding 
cleverly teaches this graph course using Java.  
Harris is extremely knowledgeable 
in algorithms and data structures.
Hey there everyone, this is coding cleverly. And 
today we're going to be talking about the graph  
data structure. We're going to talk about how it 
works, how it's constructed, and all the important  
stuff we need to know about it. The first thing I 
did was create three different files in the same  
directory. Here I have graph dot Java, and then 
we have vertex dot java. And we also have edge  
dot java. And what I'm going to do now is I'm 
going to actually write some code, and then I'm  
going to try to interlink these, all three files. 
Because this edge, this vertex and this graph are  
going to be used together to create our graph data 
structure. Before talking about graphs, I want to  
talk about the graph traversals there are many 
ways to traverse a graph, but you will focus on  
three methods depth first search breadth first 
search and Dykstra algorithm. These traversal  
methods are core algorithms for searching a 
graph. Now what are graphs graphs are the ideal  
data structure for modeling networks, making them 
an essential part of your data structure toolkit.  
They are made up of nodes, or vertices, which 
hold data and edges which connect to vertices.  
A vertex is a single node. Now all of this 
will be explained through the diagram. Here's  
a sample of a graph that I created. These 
circles everywhere are actually vertices,  
and they're holding data and edges, which connect 
to vertices. So these lines over here are known as  
edges these things now I want to give an example 
consider a map of your neighborhood. As a graph,  
we could represent bus stops, as vertices and bus 
routes, between stops as edges. So how about the  
internet web pages can be thought of as vertices 
and the hyperlinks that connect them as edges.  
Real world relationships are represented as 
graphs are numerous, making them an important  
concept to grasp. The graph, which could see over 
here is actually representing a social network.  
People are vertices and edges are friendships. 
So these lines are friendships. These circles are  
the people Peter, Cody and Jordan are all friends, 
Peter and Cody are friends. And the same goes for  
Cody and Peter, Peter and Jordan are also friends. 
And Jordan, all and Peter are friends as well.  
So this bidirectional pattern is also existing 
here, Jordan and Cody are friends. And Cody and  
Jordan are friends. One other thing that we see 
here is distinct, which is Caleb and Alex. Now,  
these are friends. But these are not linked with 
these people over here. Interesting. A path is  
made up of vertices connected by any number of 
intermediate edges from Peter to Cody, the paths  
could be Peter to Jordan to Cody, or Peter to 
Cody. There is no way between Peter and Caleb, a  
graph is disconnected when no path exists between 
two vertices. So this here is a disconnected  
graph. Because not all of these vertices are 
connected with each other, it's impossible to  
reach here. So this is the reason why this graph 
is a disconnected graph. Alright, so now let's  
map out this concept in our code. Now, what we 
want to do is we want to create a graph class  
that could be flexible enough to support directed, 
undirected, weighted and unweighted graphs. Now,  
the difference between a directed and 
undirected graph is that for directed graphs,  
which is so this is an undirected, disconnected 
graph, because there's no link here, and you can  
reach here. So this is disconnected. The reason 
why it's undirected is the reason that both of  
these paths are like bi directional. So over here, 
Peter and Jordan is Peter is friends to Jordan,  
and also Jordan friends to Peter. So this 
is bidirectional. So and this is undirected,  
if it's directed, it would have arrows here. 
So it would point that Peter is only friends  
to Jordan. But Jordan doesn't like him back. And 
Jordan is friends to Cody, and Cody doesn't like  
him back. So something like that is going 
to be directed. In case of weighted graphs,  
you'd have weights on top of each. So I know it 
doesn't make sense over here. But if we had like,  
stopped, bus stops, and then their 
routes, it would have been easier  
and easy to map out. But here, if I say 
Peter, and then Jordan, it takes like,  
let's say five. So it's something like this. And 
then we have over here we have, let's say 10.  
And over here, let's say it's 12. So over here, 
now we got weights on top of the edges. And these  
are just going to indicate the number or the 
expense that we're going to take here. So Peter,  
I know it's not a good example, like I said that 
we could have done with bus stops and routes,  
but here we're at Again, Peter is finished 
with Jordan. And I don't say five times. He,  
he likes him five times this. Jordan likes Cody 
10 times. And Cody likes Peter 12 times, I'm  
not sure if that was a good example. But you you 
got my point there something like that it with,  
which associates the numbers as they're expensive 
with this in mind, we will create our graph with  
the following requirements of vertex can store any 
data. So these circles, a vertex maintains a list  
of connections to other vertices represented by 
a list of edge instances. So we're going to have  
a vertex, we're going to also have its list to 
connect other ones. So those are going to be  
called as these vertices and they're going to be 
linked through the edges. So here we have Peter,  
but friends are Jordan and Cody, right. So 
we're going to have to put that in some kind  
of structure here. So it's going to be a list 
of edges. So they're going to be represented  
by all this stuff, Edge instances, a vertex can 
add and remove edges going to another vertex.  
A graph stores all of the all of its vertices 
represented by a list of vertex instances. So all  
of these vertices you see, are just going to be 
stored in that graph structure. Our graph knows if  
it is directed or undirected. Like I said, this is 
undirected. And if it had some kind of direction  
it would been directed, a graph can add and remove 
its own vertices graph can add and remove edges  
between stored vertices with all of that other 
way, let's write the code. So to keep the concepts  
grounded in a real world application, we'll build 
a transportation network of bus stops as we go,  
what I want to do first thing is actually look 
into my vertex class. And because I know this is  
a circle, which has the data, and it's also 
going to have the edges, so we're going to  
start from this one. Here, we're gonna go into 
this class vertex here. And we're just going  
to create some instance variables. So the first 
thing that I am saying is private string data.  
Second thing that comes to the mind is private 
ArrayList. Because we want to store the edges,  
right, so we say ArrayList, we put the type of 
the ArrayList here, so we're going to store edges.  
So it's an ArrayList of edges. And we're going 
to call this as edges. Alright, so now we're done  
with that, let's add a constructor here, we're 
gonna say public. And we're gonna say vertex.  
Here, we're gonna have a string. And we'll 
say input data, the data that the user will  
provide. And then for that will take the class 
variable is equal to the input parameter.  
And then we have this dot edges, which is the 
edges, and that would equal to the new ArrayList.  
And here we want the edge. And we also want 
this. So here, we instantiated the array list,  
which was this edge is one. Now I know this 
is giving us problems, because it's not  
allowing us to have this. So let's just import 
this import Java dot util dot ArrayList. And the  
errors are gone. Here, we have a vertex 
constructor that assigns the data with  
the input data and also instantiates the 
edges list with a new ArrayList of type  
edge. Now we got these vertices right, now we 
want to have a mechanism that will allow us  
to see these edges in live action, right. The 
other thing that I want to go through this is that  
I'm going to create this as a directed graph. So 
there's going to be arrows here, a method called  
public void, add edge. And over here, we're gonna 
add in the vertex and vertex and integer. Wait.  
Alright, so now that this is done, and we just 
created this constructor for this, I mean,  
know the instance variables. Let's move on to 
edge dot Java and create the instance variables  
for here. And then after that, we're going to go 
back to this vertex dot Java and finish it up.  
One thing I want to make clear here is that I'm 
going to create a directed graph. It's going to  
be the ones that have the arrows, it's not going 
to be the bi directional ones, which would go both  
ways. It's just going to be one, one stop to the 
other stop, right? It's a bus stop. So I don't  
want to go backwards. So in this case, it's just a 
directed graph. What we're going to do here is for  
the edge, like I said, it's just a line where you 
see in the graphical representation And by here,  
I'm gonna have to try to map it out in code. So 
I'm going to have the start vertex, where it's  
coming from, and where it's going to. So PRI, 
visit private vertex. And then we have the end.
And over here, we want to wait, we're also 
going to create this as a weighted graph,  
that will have a cost for how much expensive 
will it take to move from one place to another,  
remember those numbers which were on top 
of those lines, so that's the weight here,  
so it's going to be a weighted graph as well. So 
I'm going to put up weight in here as well. And  
it's going to be called integer. And I'm gonna 
say W, RI ght, I'm going to put a integer Wait,  
and notice I'm using integer and not int. It's the 
reason is that if I don't want to put anything,  
I could just type in null. And it would allow me 
to just like Pass It On with no reason. And if I  
had an integer, I'd pass in something like 
minus one. All right, so now over here, we  
have a constructor and I will say public edge. And 
let's create the constructor here. So the vertex,  
and I'll say the start vertex, so I'll call it 
as the start being the vertex. And we have any  
vertex or we have envy, we have the integer. 
And we call it as the input weight, web ID.  
So there you go. So we got the start 
vertex, the vertex and the input weight  
that we're going to ask the user for. So 
remember, this is just an edge of that we  
are creating as users. So the class variable, 
the start star will equal to the start vertex,  
which will be passed in as an input parameter. 
The same thing goes for the disk dot end.  
And it will equal to the end vertex, Jose  
and vertex. And we have the way to so we say this 
dot w e IG ht, and we equal that to the input,  
w e, IG HT. There you go. So now we're done 
with this. And let's just add in some other  
helper methods. So I'm going to be adding some 
helper methods along with this. And I'm just  
going to be copy pasting this. So here, these 
are the public vertex, get start. And it just  
going to return the start vertex, the public start 
vertex get and will return the end vertex of the,  
you know the edge of what's in the edge. And 
the integer gateway will just return the weight.  
Okay, so that was cool. Let's go back to the 
vertex dot java file, and just make some methods  
here as well. So for the vertex dot Java, and 
remember, like I said, we wanted to create a  
function that will allow us to add some edges, 
right, we're not giving the, we're adding a layer  
of abstraction here. And we're allowing the method 
over here, we'll just add it I just for us. So  
what I could do here is I could say, a public. 
And I'd say, void, add, II D, so II, add, add,  
so add edge. And if we want to add an edge to a 
vertex, so remember, the current vertex is already  
in the context. So this will be the end vertex. 
So I'll just pass in the end vertex here. And  
also the weight if you want to give it some kind 
of weight. Remember, I said weight is optional.  
If you don't want to give it it will be assigned 
as not to do something like that. First of all,  
I'm going to have the call to this, I'm going to 
say this dot edges, et je s, because it exists and  
edges over here. And then there is a function that 
was called add for the ArrayList, because edges is  
an ArrayList. And we just add in a new ad G, and 
we call in the constructor, so this constructor  
will add pass in the this, it will get the edges 
and a vertex, so it's going to be an vertex,  
and will also be the weight of the edge. So all 
of this will be mapped in here. So this is our  
add edge, and it's gonna just gonna add some 
edges here. All right, so now we're gonna have  
to create the Remove edge here. So we're 
gonna say public, and I'm gonna say void.  
Remove Ed G, and we have vertex, and we 
have an vertex. And over here we have  
the, this dot EDG II, I just got removed. And 
the method for this is, since it's a just as  
an ArrayList removed if will allow us to add a 
predicate and remove all of the elements of this  
collection that satisfy the given predicate. 
errors at runtime exceptions thrown during  
iteration or by the predicate are related to the 
color parameter here is a predicate. And here you  
can read it. It says filter a predicate, which 
returns true for elements to be removed. And I'm  
going to add that predicate here. So over here, 
I'm going to add in, so I want to remove that  
vertex. So here I'm saying remove edge right And 
I'm in that vertex. So I'm in the vertex, Java,  
and I want to remove that edge that was passed 
in as this one. So n vertex, right, I want to  
remove that edge from here. So I would say, I just 
removed if now say, I remove that kind of edge,  
right? I know, we put this arrow bracket. So 
this is an arrow sign, and I'm gonna say edges.  
And then we say get added, because we're getting 
actually, two things here, the edges are having  
two places. One is the first. And the second is 
the end. So you can see in the code over here,  
we have the start and the end. So the edge 
has two things. And what we want is the end.  
So that's why we are getting the second one. And 
that's going to be over there. So they'll get and,  
and then we say dot equals, so we say if that 
equals to the vertex that we passed in here, I'm  
just gonna copy that and paste it here. And for 
that equals, then just remove that from there. So  
we just need a semicolon here. 
If I could get a semicolon,  
all right. And that should solve our problem here. 
So it's just going to remove that end vertex that  
we passed in as an input parameter. And it's 
going to look at this, just dot remove if and  
it's going to pass in this predicate logic that 
says, find that edge, which has the end vertex  
equal to the end vertex that was passed in pretty 
easy. Okay, so now we're gonna add in some other  
helper methods, I'm gonna copy paste this as well. 
So I'll just paste it here. So the first thing,  
let me just zoom out and show you what I've done. 
Here, we have this remove edge, and we have the  
Add edge perfect. Over here, we have this Get 
Data method. It's a string return type. And  
it's just going to get the data for the vertex 
pretty easy, straightforward. And the ArrayList  
edge. So this is the return type, and it's in 
get edges. So it's just going to return the,  
the edges that the certain vertex has. So it's 
just going to return the list of it, this dot  
edges. All right. Now over here, we have a public 
void, print Boolean, show eight. So over here,  
we have this printer method that's just going to 
allow us to visualize our implementation. And it's  
just going to show us how the graph is looking 
like inside of our structure. So it's pretty  
easy, you don't need to go into detail for 
this. And if you want to write this down,  
you can pause the video and start typing this in. 
We're done with the edit of Java. And we're also  
done now with the vertex dot java. In fact, 
I don't even need this main method here. So  
I'm just going to remove that here. And now we 
just have this so the Virta edge dot Java and  
the vertex dot Java are done. Let's go to the 
graph dot Java, the main thing, the main boss,  
so over here, we're just gonna add in the 
following things. Remember, like I said,  
a graph is a list of vertices. That's exactly 
what we want to do here. So I'm gonna say private.  
And I'm gonna say array list. And I'm gonna put 
in the type here, the type for this is vertex,  
because we're putting in vertices, and we're 
going to pass in vertices like this has a name.  
Now we also have a type, which I've specified 
that there could be different kinds. And my  
graph will be a weighted graph. So I'm just 
going to put an is weighted boolean variable,  
I'm also going to put is directed boolean 
variable. And this is just going to tell me  
if the graph is directed with arrows, or if it's 
unidirectional, or bi directional. And so that's,  
that's the thing. Let's create a constructor 
for the graph. And we'll just say public graph.  
Graph, and then we'll just pass 
in Boolean. And we'll say input  
is weighted. So the things that are passed 
in will be determined by the user. And pool  
Boolean input is directed. So with all of this, 
and here we're gonna have the this dot vertices.  
And we're gonna say new array list and we're just 
gonna pass and so over here we have graph and then  
we have Boolean, input his weighted, and then we 
have input as directed. So like I said, we're we  
have to first initialize the vertices array 
list, so I'll just say new ArrayList vertex,  
put the round brackets and then the 
semicolon this will initialize our vertex.  
This will initialize our vertices list and 
for the weighted thing, so we can say is W E,  
weighted is equal to and we say 
input is weighted, so W E IG ht,  
for the other one which is directed so is directed 
is equal to input is directed There you go.
Cool. So now this is created. And yeah, 
I have to import the ArrayList as well.  
So just import that as well. Now let's create 
some methods. And the important methods that  
we want to do here is that we want to create 
a method that will allow us to add vertex,  
add some vertices to our array list. And the 
name for that will be self explanatory. It's  
called vertex. And that's the return type. 
So it's going to be called add vertex. The  
data that will be passed in was a string. And over 
here, we'll say vertex. And we'll say new vertex.  
And over here, we're just going to create 
a new vertex here. So we'll say new vertex.  
And we'll pass in the data that was passed in.  
And over here, we're gonna put that inside of our 
list. So we'll say this dot vertices dot add, and  
we put the new vertex, semicolon. And then we have 
the return new vertex. Cool. So we're done with  
this, that's the Add vertex method. And it just 
returns to us the vertex. So we'll have to assign  
it to a variable in the main methods. So now we're 
going to create the public void, add edge method.  
And this will allow us to pass 
in the vertex, vertex one,  
the vertex, vertex two. So this is the start and 
the end vertex and the integer way, like I said,  
I wanted to create a level of abstraction here. 
So I'm allowing our graph to have the Add edge  
of functionality as well. So over here, 
it's pretty straightforward. If I said,  
if the thing is weighted, then there's going 
to be no weight for this because I passed an  
integer weight. And I have to first check the 
boolean variable here. So if I say is waited,  
not directed, but is W E, IG HT. Now if the 
waiter was false, then so it says if waited,  
is false, right. So we'll just say, the wait, 
that was passing, it will be assigned as null.  
All right. And if it's not false, meaning if the 
thing is weighted thing, so we'll say vertex, one  
dot add edge, and over here, we're 
actually adding the vertex to.  
And here the weight will be passed in as 
well. And this is the Add edge method.  
That's from the vertex class here. So the 
vertex add edge, this one. Now, over here,  
we want to actually add in the other thing around 
as well, because we don't need bi directional  
and unidirectional. So if it's undirected than 
both right, and if it's directed than just one,  
so I'll say if it's not directed than both, 
so this.is directed if it's not directed.
Then we'll have the vertex, vertex two dot, add 
vertex, or, yeah, so vertex two dot add edge,  
here, we're gonna add the edge. 
And we're gonna say, vertex one.
And we're also going to put in the weight over 
here as well. And there you go. Similar to how  
we created the Add edge method, we now need 
to create the Remove edge method. So let's go  
here a little down. And let's add the Remove edge 
method. So we're just like I said, I'm giving the,  
the power to the user to do all of this. So 
and the user doesn't even have to know how  
the vertex Java or Java works. So that's the 
layer of abstraction that we're creating here,  
remove edge, Ed EDG II, and over here, we're gonna 
pass in the vertex. And we'll say vertex. So to  
remove the edge, you'll have to need you'll need 
the vertex one. You'll also need the vertex two.
Now to remove it, it's pretty simple. We say 
vertex, one dot remove, this is the method  
that was there. So remove edge and it takes 
another vertex. And we have the vertex here,  
we're just gonna pass in the vertex two. And there 
you go. And then, like I said, we have to check if  
it's not directed. If it's bi directional, then 
we have to remove the other way around as well.  
So I'll say if this.is done directed. So if it's 
undirected, right, so if it's bi directional,  
then after moving the other way around, as 
well as using vertex two dot, remove edge,  
and we put in the vertex one. Okay, so that was 
pretty much it with the Remove edge. Now we have  
some other methods like remove vertex, so just 
add an empty move redex, quickly over here, void,  
remove vertex. And for the Remove vertex, we 
have the vertex that's passed in as like this.  
And what we're going to do is we're going 
to say this dot vertices, which is the list  
that is existing here in this class, this instance 
variable, and we're going to use the remove method  
that's provided by the ArrayList. And we're just 
going to remove the vertex that you just asked  
for, right, so that's just going to be removed 
here. Now to save some time, I'm just pasting  
some helper methods that we also need here. So 
I'll just paste that in. And let's see how it  
looks like. So here we have the get vertices, 
the remover index, the get vertices method,  
it just returns the list is weighted, is directed. 
So that the last thing we did was this one,  
which was removed the vertex, and then after that, 
this one is just to get vertices, it's just going  
to return the array list vertex. So the whatever 
the array list is, it's going to return all the  
vertices here, inside of that current graph. 
Public boolean is weighted will return if the  
graph is weighted or not. And boolean is directed 
will turn if it's directed or not. Public vertex,  
get vertex by value, passing a value, and it will 
loop through this. For condition, it's going to go  
vertex. So you pass in a string value, and you try 
to look for that vertex for that kind of value. So  
let's say I have a stop in New Jersey, let's say 
Jersey City, I'm looking for Jersey City, stop  
for my bus, you know, bus route. So in the bus 
service that I'm trying to map out here, let's say  
I have Jersey City passed in here, now I'm gonna 
have to look for that stop if it exists in this  
entire bus ecosystem. So if it exists in the bus 
routes, if if there is any kind of bus stop, that  
has the name, Jersey City, and then it will be 
returned here. So over here, I go for each loop,  
and it says over here, the vertices are listed. So 
I would say for every vertex v, if the value is So  
I'll use the get the data value and this vertex, 
remember that I created get data over here  
somewhere. So it's supposed to be somewhere over 
here, there you go, it returns a data string. And  
if it equals to the value that was passed it as an 
input over here, no more return the V vertex, and  
then you'll have it as a vertex here. So perfect. 
And if it didn't exist, it will just return null.  
So that will help us know if the vertex exists 
here. And now over here, if you want to print it,  
so for vertex V in this vertices, v dot print, 
and we have is weighted, so you know the print  
method that we created here, this will allow us to 
see all of these vertices in action. Awesome. Now,  
let's create the main deal here. Let's create some 
graph. Let's create the graph data structure. And  
let's try to map it out. And I'm gonna remember 
I said I'm gonna create a bus station. So I'm  
gonna say gr, a pH. And I'm gonna say, bus 
network. And I'm going to say, new graph.  
And over here, we're going to pass in for 
the is weighted, and for the direct fizzing,  
we're going to pass in both true true. 
So T, ru, E, and t, are you ready? Now,  
let me tell you why it's this. The first one was 
input is weighted, so it is weighted, there's  
going to be values associated to it. So for every 
edge of there's going to be some kind of distance,  
and the input is directed, meaning that there's 
going to be some kind of Arrow and it's so it's  
a it's not bi directional. It's not two ways. 
It's just one way going forward. So bus network.  
And I'm going to use the advert x method that 
we created here in this method. So it asks us  
for a string data, and we'll just say that, 
say, Clifton. And here we have a semicolon.  
But remember that this add vertex method if 
you go, if you go and see the method here,  
it's actually returning a vertex. So we're gonna 
have to store in some kind of barrier variable.  
So let's store it in a vertex. And I'll 
call this as Cliff Clifton station.  
And it equals to that so there you go. And the 
same goes for the next one. So I'll say bus  
network, dot add vertex, and we'll say vertex. 
And over here, we'll have the next station I'll  
just add a caveman station. And let's have the 
vertex here as well. So, vertex and all Say,  
keep keep me station. And just There you go. So we 
created two stops. And I think that's enough for  
now. So now what we have to do is add the edges 
and the connections between them. So we use the,  
you know, the Add Agile method. So we'll 
use bus network. And we'll say add edge.  
And to add edge, we have to put one station to 
the next Jose Clifton station, and we'll say,  
the cape Main Station. So that's the connection. 
And we'll also have to put a weight, let's put  
a weight as well. So I'm gonna say it takes 1000 
miles to reach there. And that's our weight. Cool,  
now it's connected. And remember that I'm not 
putting it. So I'm just putting it one way,  
and it's just going to connect 
it that, you know, directed way.  
Here we have that, if I wanted to remove an 
edge, it would remove it and using the same  
but I'm just gonna say bus network dot remove 
edge and his pet pass in the same two things,  
not the weight that time. In this case, I just 
want to print it out and see how it looks like.  
So bus network dot print. And this is our 
method that was that is created here. I'm  
actually calling all the vertices, so it's going 
to be printing it through here. Awesome. So let's  
run this baby up and see how it looks like so I'm 
gonna command from here. And I'm gonna say Java  
seed. The name of it is called Graph. God Java, 
it compiled. And now after that, I'm just gonna  
paste here. So over here we have the direction 
from Clifton to keep me and it takes 1000 miles.  
So that's exactly what we did here. Let me just 
minimize it quickly. And go back here. And if I  
look over here, I actually created a direction 
from clipped indicate man, it takes 1000 miles.  
And I didn't do the other way around. Like I said 
this was not undirected. It was directed because  
it was such true. And here you can see that 
there's just one way from Clifton to caveman to  
1000. And I can't go from caveman back to Clifton. 
And if I want to do that, I could easily do that,  
I could just modify this so input is weighted, 
that's set to true if I just leave this as  
nothing. So by default, it will consider that as 
false. So alright, so I'm just going to have to  
if I add in false here, and that's just going 
to make it undirected so it's gonna go both  
ways around. And if I do this, now it's 
gonna go bidirectionally. So I'll say this,  
and then after that, so over here we have clipped 
into Cape May 1000, and came back to Clifton 1000.
Using graphs to model complex networks is great 
but graph search algorithms are another way graphs  
can be useful. A graph search algorithm can be 
used to traverse the entire graph data structure.  
In search of a specific vertex value. There are 
two approaches to using a graph search to navigate  
a graph DFS and BFS DFS are depth first search 
follows every possible path to its conclusion.  
BFS on the other hand, or breadth first search 
expands the search from the point of origin to  
an ever expanding circle of neighboring vertices 
to track down what we visited, we add a list this  
list will be very crucial because it prevents a 
search from returning to the same vertex multiple  
times. This is especially important for cyclical 
graphs, where you could otherwise end up in an  
infinite loop. And we've seen this in our previous 
videos. So you might be wondering, how does one  
compute the runtime of graph search algorithms 
in an upper bound scenario, we will examine  
every vertex and edge. As a result, the big ol 
runtime for depth first and breadth first search  
is all of vertices plus edges. So you have the 
O and you have bracket vertices plus edges. Now,  
here's a question. What if you don't need to find 
a path, but you do need to find a list of all the  
values in a graph? What should be the solution 
there? Well, it turns out that in addition to  
pathfinding depth first search is pretty adept 
at organizing vertices, or vertex values,  
with a clear order of visitation from beginning to 
end. So you could use depth first search to find a  
path and you know, like, instead of pathfinding 
about you go to organize and show the layout of  
the complete graph structure. Using depth first 
search there are three main traversal orders that  
you'll come across for graph traversal, pre order, 
post order, and reverse post order, also known  
as topological sort, pre order, in which each 
vertex is added to the visited list, and added  
to the output list before getting added to the 
stack. So that's just one thing to remember here,  
in post order in which each vertex is added to the 
visited list and added to the output list after it  
is popped off of the stack. And then reverse post 
order, which is also known as topological sorting,  
which returns an output list that is exactly the 
reverse of the post order list. So post order and  
reverse post order are just like the opposites 
of each other. Here I have a cool graphical  
representation of a graph, take a look at this 
directed graph structure that I've depicted here,  
let's say that we want a list of all vertex 
values starting with one in the order that  
they are added to the stack. Now a pre ordered DFS 
traversal would come in handy. Now over here, we  
would assume that the algorithm prefers visiting 
things in numerical order if there is a choice,  
so our target value is one. And normally you would 
get a target value from the program. So our target  
value is one here. So we're starting with one, 
we'll go with one. So this is the first thing  
that's visited, this is also going to be on top 
of the stack. So over here, if we have a choice,  
we're going to prefer visiting the minimum number. 
So over here, we have three and four, we're going  
to check three, so we're going to go and visit 
three. And we're also going to put it on top  
of the stack over here. After that, we see that 
there's four and two. So we're going to look at  
the smaller number. And we're going to we're going 
to visit it, so two is going to be over here, two  
is also going to be over here. And then we're also 
going to check for five. So because it's five,  
and there's no other option, so we're going to 
have to check five, we'll put on the stack as five  
over here. And the visited will go over here as 
well. Now the important part came, and you could  
see that there's nothing after this. So we'll have 
to pop this thing out of the stack. So we're going  
to have to just pop it out like this. And now 
we'll check to so two still has nothing with it.  
So we'll pop that out as well. And then we'll 
check three, so three has something so it has  
thing that was not visited, and it was four 
and it's not in the visited set. So we're  
going to add that visit four over there. So 
just add four to the top of the stack here.  
And we're going to add four here as well. Now, 
we're going to check for the four, and we're  
going to see, well the four doesn't have anything. 
So we're going to pop that out on the stack as  
well. And then after that we have three, so we're 
looking at for three something and a number that  
is already that is not visited. So everything 
is visited four and two are visited. So we're  
going to remove three, we're going to look at one. 
And if there's anything that is not visited, we'll  
have to check. But there's nothing everything is 
visited three and four are there. So we'll remove  
that. So this is how our list will appear 13254. 
So this is the pre order DFS traversal. Alright,  
so like I said, that pre order is, is the kind 
of order in which each vertex is added to the  
visited list, and added to the output list before 
getting added to the stack. So this was our pre  
order traversal. Now we want to look at post 
order traversal, in which each vertex is added  
to the visited list, and add it to the output list 
after it is popped off of the stack. So if we look  
at take a look at the post order traversal, we'll 
go like this. So for the first thing, it's one,  
so we're just going to look at one, we're not 
going to add it to the list or anything yet,  
then we're gonna look at the smaller number 
which is three, then we're going to look at  
something even smaller than that, which is 
two, then we're going to look at something  
and then we have five. So there you go, the last 
number came, so it's going to go like this five.  
And then after that, it's going to go and see the 
two because it's going to be popped off as well.  
So five, two, and then we're going to look at 
three. So three actually has something for this.  
So we're going to have to add four. And 
then we have nothing over here, so four,  
and then we have back to three. 
So back to three. And then we have  
we have the last one, which is one. So this 
is our post order traversal. This is how it's  
going to appear. And the reverse post order, 
which is also known as the topological sword  
will return an output list that is exactly 
the reverse of the post order list. So this  
is a post order traversal. And the exact 
opposite of this is 1342 and then five.  
So this year is the reverse posed order, also 
known as the topological sword. And these are  
just different ways to traverse the graph. The 
most common was the first one which was pre order,  
and that's the default thing. And it's easy for 
us to get a full overview of the graph like that.  
Alright, so let's have a conceptual overview 
of how the depth first search DFS is going to  
work. So let's suppose we have our target value 
as one. So we're gonna go and visit one here.  
And we're also going to put it on the stack. 
So that's the top of the stack, then we'll  
have to look at the number that is smaller from 
this choice. Over here, we got three and four,  
we're looking at a smaller number. And we'll put 
three on top of the stack here. And we'll put it  
as our visited set as well. So we have three, 
and then after that, we look at the smaller  
number from these two, and the two is a smaller 
number. So we'll put it in the visited set.  
And we'll also put in the DFS stack. So we'll 
put it up on the top over here. And now we can  
see that five is the only option. So we'll have 
to use five here as the visited. And then we'll  
have to put five here on the top of the stack as 
well. Since there's nothing over here on this,  
there's nothing after the five, so we're going 
to have to pop this out. So to do this, we're  
going to have to just select this number and just 
pop it out. And now we're going to look at two,  
so there's nothing with two as well. 
So we're going to have to pop this out,  
three has some unvisited vertex, which is 
this four, one, because it's not in the set  
over there. So we're just going to have to use 
this now. So we're going to use four, and we're  
going to put it over here. So four is going to be 
over here, and four will be on top of the stack  
as well. Now we look at four, because this is our 
current current vertex. And there's nothing over  
here that's unvisited. So we're gonna have to 
pop this out again. So let's just pop it out.
So there you go, this is popped out. And now 
we look at three, there's nothing unvisited.  
So we'll just pop this out, look at one, and 
there's nothing unvisited, so we'll just pop  
that out. Once the stack is complete from here, 
so it's empty, we'll have a list over here 13254.  
And this is a list of all of the vertices inside 
of this entire graph. So we have 1325, and four,  
this was our DFS depth first search. Now let's 
write the code for this. So here I have a class  
graph traverser. And it has a main method. And 
also I have a sample graph that I've created  
earlier. And it just contains up some vertices. 
And yeah, it just has a method here that says Get  
starting vertex. And we'll get the first vertex 
here from the graph. Now, our job here is to write  
the code for depth first, traversal reversals are 
extremely useful when trying to find a specific  
value or path in a graph. We'll start with the 
depth first traversal method for recursively  
traversing a directed graph. To summarize depth 
first traversal, iterate down each vertex, one  
neighbor at a time. In this video, I'll focus on 
traversing the entire length of a single path, and  
putting the data value of each vertex. Now in test 
graph dot Java, I've created a sample graph for us  
to test the traversals against this is all linked 
to my last video about graphs. So we created a  
graph here, and we have this input is weighted 
as false and is directed as true. So there's no  
weight, but it's directed meaning it's, it has 
directions, right. And we have a vertex, start  
node, and we have tests, we have now add vertex, 
and we have the name. So these are the names  
of our vertices. And yeah, so they're all these 
vertices here. Now I have all of these vertices  
that I added, and then I created these variables 
to associate to them. And then after that, what we  
did is add edges. So connections were done. After 
that, we created a cycle here as well. And this is  
not exactly the same graph that I've made in the 
diagram. So what I have, what I have here in the  
diagram was just simple so that you could easily 
understand how DFS works. But here I just created  
a complex one so that we could test out cycles as 
well. And other things. After that, we have this  
graph traversal dot java. To keep things simple. 
I created a separate graph traversal utility class  
in graph traversal, dot Java, and I'll implement 
the traversal iterator as a static method here.  
Now I've seen implementations in which they 
created the iterator inside of the graph class. So  
now let's start writing the code here in the graph 
traverser dot Java utility class, we're gonna,  
first of all, let's just add a method that is 
for the depth first traversal. So we say public,  
and we say static, because it's a static method 
and void. And we're gonna say depth first.  
Because we're using a static method here, because 
this is a utility class. So depth first traversal.  
And here, I'm just going to pass in 
the vertex to start with. So a one I  
need the very start vertex. And also I 
need a list of all the visited vertices  
for this start one, so that will be called 
as an ArrayList. And I'm gonna put in the  
vertex type here. And we're also going to put in 
the name as visited, and then we have vertices.  
Cool. So now we're done with this. Let's add 
in the things here. First, let's just print  
out the value of our start data. So we have 
a system dot out dot print Island, and we say  
start dot get data. So you might be asking, Where 
do I get this get data from. So I already have  
vertex dot Java included here, and I've created 
this in my previous video. So we have a Get Data  
method, and it's just returns the string data, 
now that we're gonna have to iterate through  
this vertex, and we're gonna check its edges, so 
all of the edges for the start vertex, so we could  
use an edge at V of E. So for all the edges E in 
the Start dot get edges. So this is also a method  
inside of the vertex class. So over here, I am 
saying that for every edge inside of the start,  
edges, so that's this means all of those, 
all of those neighbors that are connected,  
so we have to get the neighbor vertex to get that 
we got to use E dot get. And, and this will give  
us a vertex. So you can see that returned gave 
us a vertex, and we're gonna save it as a vertex,  
neighbor any igvh vor. Now, one thing to note 
here is that this e is an edge and the get end is  
from the edge class. So this is also here. So get 
end is going to be somewhere over here, there you  
go. And it returns the vertex, and from there, so 
it's just pretty simple. This one, the end vertex.  
Now, right after this, I'm gonna have a 
conditional here. And I'm going to check if,  
if my visited vertices does not contain this 
thing, so I'm going to add it inside. So now  
we even know. And we could, we could mark that 
that we already visited or not to keep track,  
if we visited vertices or not, we're going to add 
this conditional. So if we're going to use visited  
vertices, and then we say, dot contains. And 
then we have the, the neighbor, and I say if  
that contains inside of the visitor vertices, 
because you know that the visited vertices was  
passed here. And I'm saying if it's not inside 
of the visitor vertices, then we want to add  
it. So we'll just put a negation here. And let's 
also quickly add this import. So just over a year  
and quick fix, import the ArrayList as well 
on top. Okay, cool. Now over here, in this  
inside the conditional, I'm going to add in the 
visited vertices, and I'm going to say dot add.  
And I'm going to add in the neighbor 
vertex here. So I'm going to say neighbor,  
since our visited vertices holds the vertices, 
vertices, and we could easily add a vertex here,  
the really important recursive call here is that 
we're gonna do a recursive call that will go to  
the graph traversal again, so you're gonna call 
the graph traverser, which is this current class,  
and we're going to call the method which is depth 
first traversal. And now it's requiring us a start  
and visited, so the visit of vertices will be 
the same thing. But now we're gonna go with  
the neighbor. So an E, I VHBO. Art of so we're 
done with that. And the conditional is done. And  
here's the for each loop, it's going to iterate 
through all of the edges for our Stryver index,  
and it's going to go until it's done. So that's 
pretty much it with our depth first traversal,  
we could test it out in our main method, 
we're going to create a test graph.  
And we're going to say test. And what 
we're going to say is new test graph.  
Okay, so where am I creating this from this 
is actually from this place. And this is just  
creating a test graph. Remember, like I said, it 
created this whenever this is a Public Test graph  
constructor, and in the constructor is just doing 
all of the work for us. So normally, we would put  
this in a main method, but we're putting this 
in a constructor. So it's creating a gigantic,  
ginormous kind of graph with so many vertices. 
So V one v two v one one, we want to all these a  
1234567899 vertices, and they're connected edges. 
And what's it going to do is it's going to show us  
through this, so we're just going to create it 
here. And we're going to pass it in. So before  
that we actually need the starting vertex of 
our test graph as well. And we have created this  
handy method here, which was get starting 
vertex, which returns us the first vertex  
in our graph. So we could use test, and then we 
say, Get starting vertex. And this would just give  
us the starting vertex and we go save it somewhere 
inside because of return. This actually returns a  
vertex type. So we could say vertex, and we say, 
starting vertex, so we'd say, starting vertex, and  
we'll just equal it. Okay, cool. So now that it's 
equal, now, we can add in the visited vertices. So  
now let's add up the visited vertices list. So 
array list. And I'll put the type as a vertex.  
And I'll call this as visited vertices, visited 
vertices. And here we're gonna pass in a new array  
list. And here, we're gonna just instantiate it. 
So like that, and a semicolon at the end. So we've  
created a visited vertices array list as well. And 
we're going to add in the starting vertex, because  
it's already visited. So we're just going to add 
it before all of the operations. And we'll just  
add in starting vertex here. Cool. Now when it's 
done, we're done with this initial thing. Now,  
we could finally call our depth first traversal. 
So this thing is really easy. It's the name of the  
graph traverser dot depth first traversal. And 
it's asking us for the start vertex. So we'll  
say starting vertex, and the visited vertices, 
and this should have printed out. So let's go  
into this place, which is right here. And command 
prompt it here. And let's go down and let's say  
Java C, and we say, graph traverser, dot java. 
And now let's just run it so Java graph for  
a sir. So here we have, the way how this will 
work. That's pretty pretty dope. Now it's time to  
focus on breadth first traversal. As a reminder, 
the breadth first traversal iterates through the  
graph and layers, it goes down one layer, which 
comprises the start vertex has direct neighbors,  
then it proceeds down to the next layer, which 
consists of all the vertices that are neighbors of  
the vertices in the previous layer. And for this 
example, I'll focus on traversing down one layer,  
and then take a similar approach as we did with 
the depth first traversal by keeping an array  
of visited vertices to prevent us from iterating 
through the same vertices over and over, however,  
we will iterate through all of the direct neighbor 
vertices instead of iterating. Down the neighbors  
first edge, like we did in depth first traversal, 
we will also use a queue to traverse through  
the graph instead of recursion to explore the 
different ways we can implement the traverse,  
I'll reuse the same task graph that was used in 
the depth first traversal implementation. Alright,  
so what I have is a directed graph. And I'm going 
to have to apply a breadth first traversal. So  
what I'm going to do is I'm going to get my target 
value, suppose we have it as one starting value,  
and I'm just going to put it in the visited. 
And I'm also going to put it in our BFS queue,  
we're going to look at our adjacent vertices and 
see the smaller number. So here we have three,  
and we're going to choose that as the first one. 
So we're going to say three, as our visited.  
And we're also going to put three here as well. 
Now that we've done that, we look at the other  
adjacent one, which is four, and we're going 
to add that in our visited set. And we're also  
going to add it here in our queue. Now that we've 
exhausted our current vertex, since there are no  
more unvisited vertices, so we're going to have to 
remove this one from our queue. So we're going to  
remove this one, and now three will be our new 
current vertex. And we'll look at the adjacent  
ones here. So we have two and four, but two is 
smaller. So we're going to choose two first.  
And here we have two in the visited and two in the 
queue. Now we also have four, but four is already  
visited here. So we're not going to look at that. 
Now that we've done this, we're going to have to,  
since three is exhausted, now we're going to have 
to remove that as well. So we're going to DQ it.
And we're going to now look at four now 
four is over here, and there's nothing  
that we could visit. So we're going to have 
to remove this as well. So we'll remove four.  
And after that we could see two is now our current 
vertex, and two has a neighboring a neighboring  
vertex, which is five, so we'll put five here and 
it's the only neighboring vertex. So we'll just  
put the BFS queue over here. So now that we've 
exhausted two, we'll remove it from there as well.  
And five is also nothing. So there's nothing with 
five as well. So that's completely exhausted as  
well. So here we have completely visited the 
entire graph using breadth first search 1342  
and five awesome now let's write the code for 
this. So I'm going to the same file where I  
created my depth first search and I'm going to 
add my breadth first search right after this.  
So this is my depth first search and right after 
that, I'm going to create my breadth first search.  
So I'm gonna say public. And we're also going 
to make this as a static method. Since this is  
a utility class and br E A D, E H, F fi rst and 
then sc search. So depth first search. So breadth  
first search, adding the vertex start, just like 
that. And also the array list, which is the vertex  
And this is going to be called the visited 
vertices, just like what we did up on the  
top for our depth first traversal. Now, since 
you saw the graphical implementation there,  
I use a queue. So I'm going to create a queue 
here as well. So queue, and I'll call it visit to.  
And here, we're going to equal it to new Q. So 
Q u, u. And we'll just put that as well. Now,  
you might be asking, where is it Q 
coming from? Well, I actually have the Q  
file here as well. So this is the queue dot 
java file. And we've created queues before,  
but actually modified here a little bit. So the 
same exact queue that we've created in our video  
series. But I just modified it a little bit, 
just to add vertex as the data now instead  
of a string or some kind of integer. So removing 
that, and now let's just go here. And over here,  
now we created our queue, it's called our 
visit to, and we're going to have the visit to  
dot n Q, the first thing, which is the start, 
which was passed in as the input parameter,  
and that's the vertex there. Now, we're adding 
a while loop. And this is going to go until the  
visit queue is not empty. So I'll say visit to 
because this is a queue, it has this method,  
which is empty, and I've created that one. So I'll 
say if it's not empty, we're going to go inside of  
this visit queue and keep doing those removing 
queue things and, you know, traversing and  
using breadth first search there. So for that, I 
could, let's just get something down and actually,  
DQ the, the elements in the queue, so we 
could say visit. So we can say visit u.dq.  
And here we have a vertex that we have to 
do. So we'll put it inside of a current  
variable. So we'll say current. All 
right, so now that it's in current,  
we could print out the value here, as well 
as just say, system dot out, dot print.  
ln, and then we say, you know, current dot data. 
And there's a Get Data method that was in the  
vertex class. So there you go, it's working 
there. Now we're using a for each loop to go  
through each of the edges inside of this current 
vertex. Because that's what I showed you in the  
graphical implementation. Now, I'm just mapping 
all of that entire explanation down in code.  
So I'm gonna saying edge for every edge of the 
current vertex. So it's a current dot get edges,  
which is returning an array list of 
edges. And what we could do here is that,  
so now we're gonna get the neighboring vertex of 
the current vertex. To do that, we could easily  
get it from E dot get an end. And that returns 
us a vertex, that's our neighboring vertex.  
And we pass it in to this vertex variable, 
and we'll call it as neighbor. And over here  
we'll apply a conditional. And we'll say if the  
now since I'm using a visited vertices array list 
over here in my input parameter that checks if  
something is not repeated twice, so I'm saying if 
it's not existing, so I'll say if visited vertices  
dot contains. And neighbor thing, and e i g, h 
vor. So I'm saying if it does not contain it,  
then you should add it. So I'm saying, if 
it does not contain that neighbor vertex,  
then you should add it. So we'll 
say visited vertices dot add.  
And so visited vertices dot add, 
and then we'll add in the neighbor,  
vertex. Perfect. And then the last thing that 
we could do here, because we created this visit  
queue, and we'll include this inside of our visit 
queue, so we'll just say visit cube dot n q,  
which is this, and we'll put in a vertex data. So 
we'll put in that vertex, which is the neighbor  
and e i g, h, V o r, so this will be inside 
of our visit Q, which is this queue, and it  
just currently had only the start. But once you 
get the edge of the neighboring vertex, you also  
pass that inside of the visit queue. So that will 
be now the current vertex and it will go until  
there's a dead end and then we'll just remove 
from the in queue and then so once it's exhausted,  
like you'll see over here in this while loop, so 
it's just gonna say until it's empty, not empty,  
so it's just gonna keep going. And once it's 
exhausted, like you can see over here DQ so  
just see the other words sees that are there to 
traverse. Now let's go Downey in the main method,  
and just have everything over here set like this. 
So just pause the video and type along. And over  
here for the starting vertex test dot starting 
vertex, here we have a ArrayList vertex visited  
vertices, the same thing. And this is the same 
exact thing. So instead of depth first traversal,  
we're gonna say, be our breadth first 
traversal. And the rest is history. And  
compiling it and running it. Let me just label 
them as well. So don't net out dot print, ln,  
or we just have a line here, so print and then 
we say d f s, I will say B, F s, run this.
So here you go. The difference between the two 
of the traversal techniques here we have DFS at  
the other side, we have BFS. So we have over 
here 011, and something like that. And then  
we have two over here, so something's going on 
differently. But if you look at the total numbers,  
1-234-567-8910 123456789, and 10. So the total 
number should be 10. It's there's 10 over here,  
and there's 10 over here. And if we look at 
the test graph dot Java here, so the start  
node 123456789, and 10. Awesome. So that was 
it. That was my code for depth first traversal.
Welcome to another video, today we're going 
to be talking about Dykstra algorithm. A very  
important algorithm in the computer science world, 
finding the shortest distance between vertices is  
one of the most common applications of graph 
searches. Finding this distance has a number  
of applications, including determining the best 
route to a destination and transferring data over  
a computer network. Consider the graph finding 
the shortest path between vertex A to vertex E may  
appear simple in your mind. But telling a computer 
how to do so is a bit more difficult. Fortunately,  
there is an algorithm that computes the shortest 
distance between any two vertices in a graph. This  
is known as Dykstra algorithm. Now, let's look 
at the conceptual overview of how the Dijkstra  
algorithm is going to work, we're going to start 
with the starting vertex. And you can see that the  
start is pointing to eight. So this is my target 
vertex. Here I have a distances cube, and also  
have this unvisited, which is on the bottom. Now, 
I'm going to look at the first step here in this  
algorithm. And the first step is to pop off the 
minimum distance of the unvisited vertices that  
you can see over here, the minimum distance here 
is zero, and these rest are all set to infinity,  
meaning that the distance from A to itself is 
zero. And the distance from A to any one of  
these vertices is infinity for now. And if we look 
at the minimum distance, right now, it's 00. So  
we're going to pop this off, so we're going to pop 
it off from here, and then we're going to look at  
the adjacent vertices corresponding to this first 
vertex. So you can see over here, so from A to B,  
the distance is four. Now if you compare this with 
the original distance, which is infinity, now four  
is less than infinity, so we could replace this 
infinity with four. Since we replaced that now,  
we could also go and check the next corresponding 
distance, now A to C has a weight of two. Now  
you can see that two is less than the infinity. 
Now, we can also replace this infinity with two.  
Now we're done with that. And we're going to this 
is our first iteration of the algorithm. Now we're  
gonna go to the next iteration. So now we're going 
to pop off the minimum distance of the unvisited  
vertices. And you can see for now, we can see that 
too, which is the for C is the minimum vertices,  
we're going to pop that out from here. And we're 
going to start with C. So you can see C has  
at A, C only has one neighbor, and that 
is E, and the distance from c to E is one,  
and you have to look at the distance from A to C 
two. So the agency was to and from C to E was one  
total distance from A to E is three, so two plus 
one is three. So what we're going to do here is  
we're going to make from A to E as three and then 
we're going to look at the E portion and we got to  
see that three is less than infinity. So we're 
going to replace this infinity with three. Now.  
Since there is no more neighbors left, we're 
going to need to do the next iteration for  
this out Rhythm C has no more neighbors. So now 
we're going to pop off the minimum distance of  
the unvisited vertices, you can see now that 
the minimum distance is three, so it's an E,  
so we're gonna pop this off, and we're going to go 
to E and look at the, the neighbors for each. So  
E has only one neighbor. And that is indeed, the 
wait for that as five, the distance will be three  
plus five, which is eight, and eight is less than 
infinity. So we can replace this infinity with  
eight. Now that we have replaced that, we can also 
see that there is no more corresponding vertices.  
So we could stop here and do the next iteration 
for the algorithm. Now, we're going to pop up the  
minimum distance of the unvisited vertices. So you 
can see that the minimum distance is b. So we're  
going to pop this off. And over here, we're going 
to look at the corresponding neighbors. Now B has  
one, two, and three corresponding neighbors, 
we're going to start with the first one, which  
is C. So B to C is one. And now you can see that 
from A to B, which was already existing was four,  
and from there to see it's one, so five, so from 
A to C will be five. And if we look at the C,  
it already exists here, and and you can see 
five is greater than two, so we're not going to  
change this value, then we're going to look at 
the distance from B to E, and that's three. So  
from A to B, it's four, and from there to E, it's 
seven. So if we look at the distance from A to E,  
that should be seven. And that is greater than 
the value that we already have here. So we're  
not going to change that at all, either. Now we're 
going to look at the last and final neighbor of B,  
and that is D, now we look at the weight, this 
is two, and the distance from here was four, two,  
so it's going to be from A to B, it's four, and 
from B to D, it's going to be two, so the total  
distance here from A to D will be six. And we will 
look at the distance over here that is actually  
lesser than what we have existing. So we could 
replace this eight with six. And that now will  
be the end of our iteration. And now we'll go to 
the next iteration of our algorithm. Now we're  
going to try to pop up the minimum distance of the 
unvisited vertices. Since we only have one versus  
left, which is D, I will look at the minimum 
distance here. And that is the minimum distance  
rest everything has been visited. So that's D, 
so we're going to try to bring it up, pop it  
off. And we look try to look at any neighbors 
for D but there's nothing. So that's the end  
of our algorithm there. And that's how Dykstra 
is algorithm is implemented. So you went over  
there and saw all of the possible distances for 
so from a to itself, the minimum distance is zero,  
from A to B, the minimum distance is four till 
here, from A to C, the minimum distance is two,  
right here, from A to D, the minimum distance 
is six, so, four to two here, and from A to E,  
the minimum distance is three, so eight 
to eat at the minimum distances three.  
So, that sums up our dexterous algorithm 
conceptual overview. Now, we're going to start  
writing the code for this. But before getting on 
to the code, let's think of what we should add  
in or what objects and what structures should we 
create. Looking into this algorithm. We're going  
to instantiate a dictionary that will eventually 
map vertices to their distance from the start  
vertex. So like you can see over here we're going 
to put that in a dictionary. A quick recap before  
we start the code for this Dykstra does algorithm 
finds all of the shortest distances between a  
starting vertex and the remaining vertices in a 
graph. The algorithm operates by keeping track  
of all distances and updating them as it performs 
a breadth first search Dykstra the algorithm is  
implemented in all of E plus V of log of V, and E 
means edges. And v means vertices, we will first  
implement the algorithm to find the shortest 
distance to every vertex. So let's go through  
the code and all of the conceptual overview 
that I gave. Now I'm going to try to map this  
out in code. So here I have imported java util dot 
asterisk, meaning I'm importing everything that's  
available in the utility package, and have it over 
here that you can see is public class Dykstra,  
and there I have a main method. Here I have a main 
method, which is actually creating a test graph.  
And the weighted and directed properties are set 
to true. And we also add these vertices here,  
so A, B, C, D, E, F, G, and we also add their 
connections to each other. So those are done.  
So what we mainly have here is a test graph 
in our main method to test the output of the  
method. What we're going to create in this video, 
so we're going to try to create that method,  
which is called Die extras. So for that, we're 
gonna have the public and we're gonna say static  
dictionary And we put in this. So we're going to 
return an array of dictionaries. And I'll tell you  
why we're doing this in just a second. So here 
we have the name of the algorithm, Dykstra, and  
we're going to tell the parameter to add in these 
two values. First thing is to have the graph. So  
d r a p h, and we call that as G, we also need to 
pass in a vertex. And that will be will be called  
as starting vertex. So we're done with these two 
input parameters. Now, we're going to create two  
dictionary objects here. And one will be used for 
the distances queue, the other one will be used to  
keep track of your previous vertex. And this is 
very crucial in this algorithm, we're gonna make  
a dictionary and a dictionary is just a base of 
key value pairs, we have a string, which is the  
key and integer as the value. And we call this 
as distances. And we create a new hash table.  
And we put in these angle brackets and the 
round bracket, and then we semicolon at the end.  
So that's the distances Q. Now 
we also need another hash table.  
And this one will be for the 
previous. So we add this as well.  
And for this, we're not going to have 
the integer as the value but the vertex,
this is going to store the data, and the also 
value that exists. So like I was doing it over  
there in the diagram, this A, and it maps out to 
zero, and this b that maps out to four, so the  
string is the letter, and the value is going to be 
the integer. And for the second dictionary, which  
is previous, it's gonna keep track of the previous 
vertex. So that will have a string, which is the  
current vertex, and vertex will be the previous. 
Now, we also need to add in a priority queue.  
So I have added some files here. And this isn't 
one that's called queue object dot java. This is  
actually a class that implements the Comparable 
queue object. And you can see that it has the  
vertex and the priority as class variables. And 
you can see the, the constructor is actually  
creating this object, and it's overriding the 
compare to method with some priority base. So if  
it's equal in priority to the input parameter, we 
just return zero. If the class variable priority  
is greater than the priority that was passed in 
is, then we will return one out, we will return  
minus one. So this is just just a file. And it's 
just a fancy queue. It's just known as a priority  
queue. The main difference between this queue and 
the priority queue is that this will look at the  
smallest value, smallest possible value, and it 
will allow us to pop that one off. So like what  
we're trying to do here, we were trying to look 
at the minimum value and the where you're trying  
to pop that off, that exact implementation is 
priority kilojoule for us and without writing  
extra code. So that's one of the biggest benefits 
for using that. So let's add the priority queue.  
And this is the priority queues. priority queue. 
And we're gonna add in the queue objects here.  
So if qu e we are gonna say, object that we 
created. And then we got ADD name for that as Q,  
Q, U, e, u e, is equal to now we're going to 
add in the new and it was a priority queue.  
And here, we're just going to add in the queue 
object once more queue, you deal with obj eects,  
and then a semicolon at the end of perfect. 
So this is our priority queue created. And  
I'm just adding the same exactly, just 
after that. Now, you might be asking,  
well, the priority queue is actually empty 
right, now we got a queue something inside.  
Now the thing that we're going to queue inside 
for the first thing is the starting vertex,  
since we know the distance for that is zero to 
itself. So we're just going to queue that up  
in here. So to say qu e dot add. And here 
we're just going to say a new Q object.  
And we're going to pass in the vertex V and 
the int p, which is the priority of the vertex  
v is just going to be the starting vertex. 
And the priority for this would be zero.  
Awesome. Now we're gonna try to iterate through 
this entire graph that was passed in as an input  
parameter. And we're going to try to iterate 
through and try to find all the vertices here. So  
we can use a for each loop for this purpose, we're 
gonna say, for every vertex v. So we can say,  
for every vertex V, in the G dot, get vertices. 
And this is returning an ArrayList of vertex. And  
you're just doing this really easily. And this is 
also added here. So I have a graph dot java file.  
And this is also added. So that's why I'm 
able to get the method get vertices. So  
this is get vertices. And it should be over 
here. So we're good vertices. So this is the get  
vertices method. And I'm also adding this edge 
dot Java as well as this vertex dot Java, you  
could look at my older videos. And from there, 
I'm actually using all of those classes that  
have created in the graph dot Java, the vertex, 
dot Java, and the edge dot Java are all done in  
a single video, which was called graphs in Java. 
So watch that video. And for this cool object,  
I'm just gonna let you see this code for now, you 
can just pause the video and copy this. And once  
you have all of these, we could go back here 
in the Dykstra dot Java, and we're just going  
to iterate through the vertices which are in this 
graph, which was passed in as an input parameter.  
Now, we're going to have to iterate through this. 
And we're going to actually update our distances,  
which was over here. So we're going to actually 
have to update our distances and previous  
dictionaries. So we're going to try to add all 
these vertices from this graph to this distances  
and previous dictionaries, we could do. First of 
all, we don't want the starting vertex to have a  
maximum integer of max value, because we know 
that the starting vertex to itself is zero. So  
we're going to give a condition here and say, 
if the vertex you get is the starting vertex,  
and this is just going to work. So we're 
gonna say if that one is the starting vertex.  
We don't want that. So if it's not, right, so 
we want to update the distances, and we're going  
to have to add input. This is a method available 
in the dictionary. And this is, this allows us  
to add a key and value pair. So the string is 
the key, and the value is the integer. So what  
we could do here is for the string, we could say 
V, which is the vertex, or we say golf dot get.  
So we could say, Get Data, and that will return 
a string here. And this is also added in the  
vertex dot java. So that's why it's working here. 
And for the integer, we're just adding the maximum  
or we want to use the infinity symbol, right, 
we're going to use integer dot max value, this  
would give us the maximum value for the integer 
in Java, and that will be stored inside of the  
value pairs. So key values are done. And for the 
other case, where we have the previous dictionary,  
so we'll say previous, previous a previous output. 
And for this second dictionary will also have a  
key value pair, but the value is a vertex. So the 
key is going to be the get data, the same thing.  
But for the value in this case, will be the 
previous vertex so that we could keep track of  
this. So we're just going to add in a vertex that 
will be set to null for now. And then after that,  
we're going to update it inside of our code. So 
right now just set everything to know, including  
the starting vertex. All right, so right after 
this, we needed to add in the starting vertex here  
in our distances, because we don't have it. So to 
do that, we'll just add in the distances again.  
That was a foot. And now we want to add in 
the key value pair for that. And for this add  
in the starting vertex, and we actually need 
the value for this, I'm gonna say, Get Data,  
and that will give us the string data. And for the 
value, I'm not going to give the maximum value,  
we're not going to give infinity because if 
we look at this code over here, initially,  
it was set to zero, so we want to just set it to 
zero here, I'll put it there. And there you go.  
So we created this entire thing, what you can see 
over here, so you can see this entire thing that  
we've created, which has a set to zero, and the 
rest are all set to the infinity or the max value.  
Now, let's go back. And we're going to 
actually do the second step for this  
algorithm. Now it's the fun part. We're going 
to have to iterate through the while loop. And  
we're going to check if the queue is not empty. 
So we say qu e u e, this, this is our priority  
you I will say the size method here. And if 
we say of that size is not equal to zero.  
We're going to do Do some operations inside of 
this queue. First of all, we're gonna get the  
current vertex here. And that is pretty simple Q 
dot call, retrieves and removes the head of this  
queue, or returns null if this queue is empty. 
So we're gonna actually remove an item from the  
queue using this method. And we want the vertex 
here. So we just say the vertex, because we had  
this over here as this queue object, and we 
wanted to vertex here. So we're removing that  
from the priority queue. So the first thing will 
just be the starting vertex. And that was added  
in our queue. So this was added over here to 
to Add New Objects, starting with x with the  
value zero. So that was zero was actually it's a 
value to itself. So this is now set to current,  
and we removed it from the queue. 
Perfect. Now we're going to iterate  
through this current variable, which is the 
starting vertex. So we're going to look at  
all of the edges or the neighbors for a 
year. So we say, for every edge of Eid.
And we say, mapping out to the current 
dot get edges, which is the ArrayList,  
returning of edges. So for every edges, or every 
neighbors inside of this current, so every edge,  
an edge contains vertices, remember, so we're 
actually going to first look at the value of what  
the edges giving us remember, like I did in this 
first one, that we were looking at the values,  
and we also judging inside of our distances. So we 
looked at, let's say, for, for the distance to D,  
we had some already included distance was 215, 
which was eight. So that was already passed in.  
But we also want to keep track of the newer one. 
So this is like four two, which is six. And now  
this is an alternative one, we have to add that 
somewhere, and then we have to judge something  
like if it's less than the original one, then we 
could replace it. So we won't have an alternative.  
And we want to also have the original. So for 
the alternative case, we'll add in an integer.  
And I'll say alternative. And I could 
add the distances here. So distances,  
and this is the distances dictionary, and I'll get 
the current dog get data. And that is the string.  
And we also want the plus to the eat, get wage, 
so we're going to get the weight as the end. So  
this is the distance from the current distance of 
the variable and the edge distance. So what this  
means is, whatever the distance is existing for 
this current nugget data, the starting vertex is  
actually zero to the distance where it's leading 
to with its vertex. So the edge where it's leading  
to with its edge, it's make sense because this is 
zero to itself. But if we're moving forward, we  
have an edge with it, and we have some weight, so 
we're adding that weight as well. So get weight.  
That's the alternative. And we all 
need a reference to our string,  
neighbour variable. So we got to have that as 
any igvh vor. So this is our neighbor value.  
And we just have to keep it just keep it inside. 
So we could eat, get and so this is the vertex.  
And we want the value for this. So we 
have Geat EDA and we have get data.  
So over here, it's pretty simple, we have a 
neighbor value, and we want to have the edge  
vertex. So we want to have the edge and we want to 
get the end. So we're gonna get the vertex through  
this. And to get the data, we just say this, so 
we're gonna get the vertex through this get end,  
and we're gonna get the data so that string is 
actually stored in the neighbor value. Now that  
the string is stored, we could use a conditional 
here to check if the alternative value is lesser  
than the original value. So what we're gonna 
do here is pretty simple, we'll say alternative  
is less than the distances and we want the 
dictionary so this is the distances dot get, and  
we want to get the value for this, we can just 
use the neighbor value, so that's why I stored it  
over there, so that we can get the value of their 
neighbor value. Alternative value is less than our  
neighbor value. So what we're going to do is that 
neighbor value is actually the original distance  
that was stored inside of our distances object 
which is on top. So over here we have distances.  
If that is possible. We're just trying to override 
it and so we're going to say distances dot put  
it I'm going to get the neighbor value. So 
that exact neighbor value, but we're going  
to change it the value to the alternative. So 
we're going to get the key and the value. So  
this is the string neighbor value, and then the 
integer will be now the alternative distance.  
Also, we're going to have to modify our 
previous, so we're going to have to add in  
the neighbor value as well. So for the neighbor 
value, we actually need the previous reference.  
And the previous reference will now be for our 
current instance, with the current one, which  
is now which is actually starting vertex will 
be the previous vertex for our neighbor value,  
which is the current one over there. So it's 
just gonna keep iterating this and updating our  
previous reference. And the last thing, what we 
want to do is we want to add the neighboring value  
to our two u two u, eu object, and we have to add 
in the vertex here, so we're gonna say e dot get,  
and so that's just gonna give us the vertex 
here. And to get the priority, we could say,  
the distances structure dot get. And to get the 
value, I'm just going to add in neighbor value,  
and that will give us the value. So this is 
a neighbor value is the key, and it will give  
us the value which is associated to this key. And 
that will be updated to our cue. And that's going  
to be our priority. So that will be added. And 
once it's done, we're actually going to break out  
from this for loop when all of these edges are 
done. And that will be updated. And after that,  
until the wild size is not less than zero. 
So this is just a line that will pop off the  
minimum distance of the unvisited vertex. And the 
rest is history over here, what you saw all in the  
conceptional overview, everything is happening 
and adjusting, and the right at the end, so  
when the while loop breaks, so that I Dykstra 
is requiring us to return a dictionary array,  
right? So we want to return that. So over here, 
right after the while loop, we could return  
a new dictionary. And so over here, we're going 
to return a new VI, C T, IO N ar y. And we're  
going to get this way racket over here, which 
is the array for this dictionary. And this is  
the array of the dictionary. And we want to pass 
in the distances, distances with the previous  
structure here, this is a return statement, 
we're going to return a new dictionary,  
and it will have the distances and the previous 
dictionaries. So we'll have both the distances  
and previous dictionaries inside of this 
dictionary array, which is returning here  
in our function. So we're going to hear that 
dictionary arrays returning. So this is the  
return statement at the end. And yeah, so 
that was pretty much it with this function.  
This is minimizing it, so you can see the entire 
thing. So this is the entire method for extra.  
Now, we also have this helper method on this 
bottom, so I'm just going to paste this in.  
This is called the Dykstra result, printer method. 
And what it accepts is an array of dictionaries,  
well, how convenient, we're just going to use 
this entire thing, I'm just going to return it  
and so we can pass it inside of this. And this 
will just actually print all the distances. So  
what you'll see over here, so it's gonna 
print out the updated distances like this.  
And it's also going to print out the previous 
positions. So you're going to see that as well.  
So since the these both were dictionaries, we're 
going to use enumeration as keys to get the values  
of all of this and it's just going to give 
us the key and value pairs, and it's going  
to be pretty cool. So these both are going to be 
allowing us to print these structures. So we're  
going to add this process here. So let's just 
create this call. So we had this test graph.  
And what we want to do is we want to use this 
method here, which is Dykstra. To use this we  
have to pass that inside. So we're going to use 
Dykstra here. I ran a passing the test graph,  
alternate paths in the starting vertex, and that 
is a because over here is the first vertex and  
that's going to be our starting vertex. You 
can set anything you want later on. And then  
after that, we're actually calling this inside 
of this method, which is dexta result printer,  
since it's accepting a dictionary array of 
D, so I'm gonna paste this thing inside,  
and we're gonna wrap it around the Dykstra. So 
there you go. And this will just print out the  
things. So cool. So now let's run this code. So 
let's go and add an CMD here. And let's run this  
code. So Java C, ed i j, k, s t r a dot java. 
And now let's just run it using Java DIJKSP  
Ra. Alright, so we have an error here, something 
no pointer exception, okay? What's the shortest  
path between two vertices. To calculate 
that we'll just create a new method here.  
And we'll call this as public static, void. 
And we'll call this as shortest path between.  
Inside here we'll have a graph DRA 
p h, and we'll call as graph G,  
we're also going to have the vertex, 
and we're gonna get the starting vertex.  
And we also need the targeted vertex. 
So we're gonna say, target work at x.
Here, we have the shortest path between method in 
which we're going to input the graph the starting  
vertex and the target of vertex because 
we want the minimum distance between two  
vertices. So we're gonna use this method for 
that case, we're gonna have the dictionary  
array object here, and we're going to 
call this as Dykstra has dictionaries.  
And that will be equal to the dictionaries. 
So we're going to call the extra method here,  
we're going to call it using the graph and the 
starting vertex. What actually it gives us is  
the distances and the previous dictionaries. And 
I'm getting an error here. It's actually di J.  
The method Dykstra is defined for undefined 
for the type Dykstra. So the reason why I'm  
getting an error here is because I don't have a 
k. So di, j, k. And if I do that, I'm all set.  
Now we want to put the distances and 
previous in their own variables. So  
we're gonna have the scope for that. 
So I'm gonna say, distances dictionary.  
And it will contain all the values which we had, 
and then we're gonna manipulate this. So we're  
gonna say dictionaries. So Dykstra, D ij, k, 
s, t, R, A, and we have Dykstra dictionaries.  
And we have this sub zero, that will contain 
our Dix distances. And for the second one,  
and for the second one, we could have 
that as one. And that will be our previous  
awesome, to get the distance of our target 
word that we're gonna say distances.  
docket, and we need to get the target vertex. And 
we want the value for that we can say get data,  
that will return a string. And that will actually 
map us to the value from our distances, which will  
be something like, you know, the value of what it 
will take for us to reach from A to that point,  
and that we could store in 
some variable called distance.  
So make sure you have the type set to 
integer here. And then that should go away.  
Now, what we want to do here is we want a 
print screen, that will just show us the  
shortest distance path between these two. So 
what we could do is, we could paste this in.  
And this is just going to print out the shortest 
distance between the starting vertex get data and  
the target vertex dot get data. So just in between 
the two vertex, this is just going to give us the  
letters, you know the distance between A to 
whatever. And system dot out dot print ln will  
just print us the distance, which was inside of 
the target vertex. Now we actually need the, the  
generated path that we should follow to create the 
path, we're going to create an ArrayList for us.  
And that will be of type vertex. And we will 
call that as path we initialized an ArrayList  
to get the target vertex and assign it to a 
variable is very important here. So we're gonna  
have target vertex and assign it to a variable. 
So we're gonna go from the target vertex to the  
starting vertex. It's a bit like the reverse 
linked list. So we're going to use some kind  
of functionality like that. We're going to use 
a while loop and we say while the V, the vertex.  
So if the V is data, and the Get Data will pass 
in a string I'd say that is not, no, because we  
know that the first one which has started will is 
no, we're gonna add in the path. So the path is  
actually the ArrayList, we're gonna say the path 
dot add, we're gonna add a zero here, because  
the path is actually making us add something 
inside of this. So we're going to add in a zero.  
And this will mean that it will be popped in the 
for direction, it's not going to go backwards,  
it's not going to queue there. But every time a 
new value exists, it will come in the beginning,  
every time a new value is added to this 
ArrayList, it will be added in the beginning.  
So patha, add zero will be added. So every value 
will be added to the beginning of the queue,  
not the end. And the other thing that we 
want to do is we want to pass it that VT,  
so that vertex that we set up will be also 
passed in here. And then the next step here is to  
get the previous instance here. So we can say 
previous structure, which is a dictionary,  
dot get. And what we need is the data here, so we 
say v dot get data. That would give us a string,  
previous dot get, and we got the value 
over here, and we're going to assign that  
to the vertex. So since we have that get 
process here, we actually need the vertex here.  
And that will assign it to the vertex. So 
it's just going to keep going like that.  
After this while loop, we could just print out 
system dot out dot println in the shortest path.  
And what we'd have now is the shortest path 
as well. So we could go from vertex path  
vertex to from the path structure, which is over 
here somewhere. So vertex path vertex. So so we  
have this path, which is this entire array list 
that now contains all of the vertices for that  
directed path. Now all we're going to do is 
iterate through this for every path vertex,  
we're going to print path vertex dot get 
data, and I will just print the letters of  
the port corresponding path. Now the only 
thing that I'm going to do right now is,  
like I said, I called Dykstra dot Dykstra 
result printer, and I passed in these two.  
So what I happened here was that I was on an 
error. And whenever I was running this code, I was  
getting this error over here at line number, 26, 
and 94. So over here in line number 26, and 94,  
it doesn't give me any clue of what's happening. 
But you could tell that alternative is less than  
distances dot that get the more value. So I was 
looking at the alternative value very carefully,  
here, I noticed that I did get an error while I 
was doing this. So this is actually a syntactical  
error, I was trying to get the alternative 
path distance, and I was getting the value  
from the distances dictionary, and I wanted to 
current dot get data. And this is what's gonna,  
this was going to actually give 
us the value for this one. So  
I didn't need this parenthesis over 
here, I actually needed that closed here.  
And now it was just going to give us the value 
here, which was string. So it was going to give us  
the value of that current data. So it's just going 
to be an integer here. And then that was going  
to be added with the edge dot gateway. So that 
will also be an in so both of these ends added  
will result in this alternative value. So 
now it's proper. And if I run the code now  
you can see now that this created it for 
me. So here what I had was these vertices,  
12345677 vertices, and these were the 
connections to them. I just called the  
Dykstra nothin past in the past graph, and 
put in the starting vertex. After that,  
I use the shortest path between method. 
And this is all showing up pretty cool.
So now we're gonna test it out and see over 
here that the distance is, is updated. And  
it's according to what these vertices are. 
So these are, I believe, seven vertices,  
and over here we have the connections to them. So 
you can see a is connected C a is connected to b,  
a is connected to D, I want you to see over here 
is that the previous here we have a as no and the  
rest, when I said a is connected to B, D, and C, 
if you look at B, D, and C, they're all connected  
to a, so d is connected to a. So over here, 
you can see that this is the structure here,  
where we have all these vertices and their 
corresponding values. So these are all the  
values that have been have been updated. So the 
distance from A to itself is zero, the distance  
from A to D is minus 30 A the distance from A to 
F F to 3020. So we just pass it these values here,  
and then just allowed us to get the minimum 
distance from this graph to just telling if the  
distance from A to B is slope. So the minimum 
distance from A to B is three, the minimum  
distance from A to D is four and so on over here 
in the previous, we have a has a previous of No,  
but the rest vertices show their previous vertex 
as well. For the last method that we created,  
we want to call that shortest path between task 
graph. And we've got the starting vertex and the  
target vertex. Now we want the path shown, and 
also the shortest path. So what we can do is  
short paths, we pass an A and G. And this is going 
to call this method over here, which is going to  
call that method and it will return us some cool 
looking path here. So we'll clear the screen and  
then run it and then see the shortest path here 
we got the shortest distance from A to G, which  
is correct, we got a to g, and it was minus 38, 
the shortest path and it showed how it was working  
here, so A to D to eat to G. So if we map this out 
and draw this in a diagram, or if we look at it,  
everything will be correct according to these 
results. And that actually sums up our video