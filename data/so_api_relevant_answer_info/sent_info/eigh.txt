There is nothing wrong with eigh, anymore than with eig.
The method eigh returns smallest eigenvalues (and their eigenvectors) first.
So you see a difference in the behavior of eig and eigh that isn't really there.
eigh is only for symmetric matrices and thus uses a faster (and different) algorithm.
I've never used these methods and am just going off of my linear algebra knowledge and what I found about eigh and eig online, so please correct me if I'm wrong.
[There is a gotcha (hyper-link)] with the scipy.linalg.eigh() function:
Be very careful using the eigh() routine to get eigenvalues, though.
In my experience (and there are many questions here to back this up), you NEVER want to use eig when eigh is an option - eig is very slow and very unstable.
The relevance of this is that I believe your question is backward - you want to normalize the eigenvectors of eig to be like those of eigh, and this you know how to do.
The only thing that is true is that for each eigenvalue $A v = lambda v$, the two matrices returned by eig and eigh describe those solutions, it is natural that eig inexact but approximate results.
But I never tested carefully the behavior of eig vs eigh.
Here is a related question I asked some months ago : [JqPlot : Set a fix height value for the graph area not including y axe labels (hyper-link)]
Probably you've defined test as a function somewhere, or eighvalsh.
You can generate similarly incorrect eigenvalues from numpy by using its numpy.linalg.eigh function as well.
And the function you mentioned, linalg.eigh, isn't "vectorized" (in the numpy or Numba sense of the word) or even written in Python.
For this, use the scipy.linalg.eig function, not eigh, because eigh only works with complex Hermitian (conjugate symmetric) or real symmetric matrices, which will not be the case here.
Using eigh requires N*N+3*N floats.
eigh is then within a factor of 2 from the minimum requirement, so the easiest solution is to stick with it.
eigh guarantees you that the eigenvalues are sorted and uses a faster algorithm that takes advantage of the fact that the matrix is symmetric.
Attention, eigh doesn't check if your matrix is indeed symmetric, it by default just takes the lower triangular part of the matrix and assumes that the upper triangular part is defined by the symmetry of the matrix.
However, in the mean time, we have also noticed that the optimal workspace array sizes were not correct in the scipy.linalg.eigh.That is also going to be corrected once the decision over how to change the signature of the the underlying ?SYEVR/?HEEVR wrappers.
As a bonus, probably one would be able to compute the eigenvalues selectively since originally these routines allow for it but were not exposed in scipy.linalg.eigh.
Functions [np.linalg.eigvalsh() (hyper-link)] and [np.linalg.eigh() (hyper-link)] both call LAPCK's DSYEVD as stated in their documentations.
Nevertheless, they deliver different eigenvalues: eigh() fails.
[np.linalg.eigh() (hyper-link)] fails.
The height rule on .progress-bar appears to be the culprit.
