["An #include with angle brackets will search an \"implementation-dependent list of places\" (which is a very complicated way of saying \"system headers\") for the file to be included.\n", "At least for GCC version <= 3.0, the angle-bracket form does not generate a dependency between the included file and the including one.\n", "For headers whose names are enclosed in angle brackets ( \"<>\" ), the header shall be searched for only in directories named in -I options and then in the usual places.\n", "The simple general rule is to use angled brackets to include header files that come with the compiler.\n", "Angle-bracket form\n", "The argument of \u2018#include\u2019, whether delimited with quote marks or angle brackets, behaves like a string constant in that comments are not recognized, and macro names are not expanded.\n", "You can use the -I flag for GCC to tell it that, when it encounters an include with angled brackets, it should also search for headers in the directory after -I. GCC will treat the directory after the flag as if it were the includes directory.\n", "When you use angle brackets, the compiler searches for the file in the include path list.\n", "So, by convention, you use the angle brackets for standard includes and the double quotes for everything else.\n", "Then calculate the angle (which runs from the positive X axis at P1 to the positive Y axis at P1).\n", "But arctan may not be ideal, because dividing the differences this way will erase the distinction needed to distinguish which quadrant the angle is in (see below).\n", "EDIT (Feb. 22, 2017): In general, however, calling atan2(deltaY,deltaX) just to get the proper angle for cos and sin may be inelegant.\n", "After that, deltaX will now be the cosine of the angle between the vector and the horizontal axis (in the direction from the positive X to the positive Y axis at P1).\n", "And deltaY will now be the sine of that angle.\n", "If the vector's length is 0, it won't have an angle between it and the horizontal axis (so it won't have a meaningful sine and cosine).\n", "The signs of deltaX and deltaY will tell you which quadrant the angle is in, in relation to the positive X axis at P1:\n\n\n+deltaX, +deltaY: 0 to 90 degrees.\n", "Answer is in radians, so the usage, to view angles in degrees, is:\n", "A formula for an angle from 0 to 2pi.\n", "Code: (Assuming imageView, angle, pivotX & pivotY are already defined)\n", "Set desired rotation angle using example:angle parameter.\n", "mImageView.setRotation(angle) with API>=11\n", "As of API 11, you can set the absolute rotation of an ImageView programmatically by using the imageView.setRotation(angleInDegrees); method.\n", "This type parameter is specified using angle brackets and the type can change each time a new instance of the class is instantiated.\n", "You'll notice that we're using the same ArrayList class to create both lists and we pass in the Employee or Company type using angle brackets.\n", "Scalar (dot) product of two vectors lets you get the cosinus of the angle between them.\n", "To get the 'direction' of the angle, you should also calculate the cross product, it will let you check (via z coordinate) is angle is clockwise or not (i.e.\n", "To compute angle you just need to call atan2(v1.s_cross(v2), v1.dot(v2)) for 2D case.\n", "Edit: this is counter clockwise angle, clockwise angle is just opposite\n", "However, if your specific problem would allow loosing some precision in angle discretization and you are ok with loosing some time in type conversions, you can map the [-pi,pi) allowed range of phi angle onto the allowed range of some signed integer type.\n", "It's better to set your priorities on writing autovectorizable or parallelizable code when this angle computation is done a lot.\n", "Also, if your problem details are such that there is a definite more likely outcome for the angle direction, then you can use compilers' builtin functions to supply this information to the compiler, so it can optimize the branching more efficiently.\n", "Just like the [dot product (hyper-link)] is proportional to the cosine of the angle, the [determinant (hyper-link)] is proprortional to its sine.\n", "So you can compute the angle like this:\n", "The orientation of this angle matches that of the coordinate system.\n", "x pointing right and y down as is common for computer graphics, this will mean you get a positive sign for clockwise angles.\n", "If the orientation of the coordinate system is mathematical with y up, you get counter-clockwise angles as is the convention in mathematics.\n", "That axis of rotation does not come with a fixed orientation, which means that you cannot uniquely fix the direction of the angle of rotation either.\n", "One common convention is to let angles be always positive, and to orient the axis in such a way that it fits a positive angle.\n", "In this case, the dot product of the normalized vectors is enough to compute angles.\n", "This might be easier to implement in some APIs, and gives a different perspective on what's going on here: The cross product is proportional to the sine of the angle, and will lie perpendicular to the plane, hence be a multiple of n. The dot product will therefore basically measure the length of that vector, but with the correct sign attached to it.\n", "To calculate the angle of segment P3:P1 \nsweeping clockwise to segment P3:P2.\n", "The anti-clockwise angle theta from x to y, with respect to the viewpoint of their given normal n (||n|| = 1), is given by\n", "(3) = anti-clockwise angle between x axis and the vector (cos(theta), sin(theta))\n", "A formula for clockwise angle,2D case, between 2 vectors, xa,ya and xb,yb.\n", "acos can cause inaccuracies for very small angles, so atan2 is usually preferred.\n", "If your two angles are x and y, then one of the angles between them is abs(x - y).\n", "The other angle is (2 * PI) - abs(x - y).\n", "So the value of the smallest of the 2 angles is:\n", "This gives you the absolute value of the angle, and it assumes the inputs are normalized (ie: within the range [0, 2\u03c0)).\n", "If you want to preserve the sign (ie: direction) of the angle and also accept angles outside the range [0, 2\u03c0) you can generalize the above.\n", "x is the target angle.\n", "y is the source or starting angle:\n", "It returns the signed delta angle.\n", "This gives a signed angle for any angles:\n", "If angles are within [-180, 180] this also works:\n", "For UnityEngine users, the easy way is just to use [Mathf.DeltaAngle (hyper-link)].\n", "An efficient code in C++ that works for any angle and in both: radians and degrees is:\n", "So all you need is an formula to calculate the angle between two vectors.\n", "If you mean the angle that P1 is the vertex of then using the [Law of Cosines (hyper-link)] should work:\n", "You have a simple triangle, so your problem is solveable with the [law of cosines (hyper-link)].\n", "Angle = arccos ( (B^2-A^2-C^2) / 2AC )\n", "You mentioned a signed angle (-90).\n", "In many applications angles may have signs (positive and negative, see [http://en.wikipedia.org/wiki/Angle (hyper-link)]).\n", "If the points are (say) P2(1,0), P1(0,0), P3(0,1) then the angle P3-P1-P2 is conventionally positive (PI/2) whereas the angle P2-P1-P3 is negative.\n", "Angles can also extend beyond 2*PI and while this is not relevant to the current question it was sufficiently important that I wrote my own Angle class (also to make sure that degrees and radians did not get mixed up).\n", "The questions as to whether angle1 is less than angle2 depends critically on how angles are defined.\n", "You can then invert the dot product formula:\n[image]\nto get the angle:\n[image]\n", "I ran into a similar problem recently, only I needed to differentiate between a positive and negative angles.\n", "The best way to deal with angle computation is to use atan2(y, x) that given a point x, y returns the angle from that point and the X+ axis in respect to the origin.\n", "you basically translate the two points by -P1 (in other words you translate everything so that P1 ends up in the origin) and then you consider the difference of the absolute angles of P3 and of P2.\n", "The only singular point for atan2 is (0, 0)... meaning that both P2 and P3 must be different from P1 as in that case doesn't make sense to talk about an angle.\n", "Here's a C# method to return the angle (0-360) anticlockwise from the horizontal for a point on a circle.\n", "This C# or, Java method calculates the angle (\u03f4)-\n", "Vector3f.angleBetween(otherVector)\n", "To get angle from point A to B\n", "angle = atan2(A.x - B.x, B.y - A.y)\n", "To get angle from point B to C\n", "angle2 = atan2(B.x - C.x, C.y - B.y)\n", "echo some string \\< with\n  angle \\> brackets >>myfile.txt\n", "The only way I can think of removing HTML tags but leaving non-HTML between angle brackets would be check against a [list of HTML tags (hyper-link)].\n", "Basically, you need to determine the relative positions using trigonometry, by building a function which returns an element_text object, given angle (ie degrees) and positioning (ie one of x,y,top or right) information.\n", "Frankly, in my opinion, I think that an 'auto' option should be made available in ggplot2 for the hjust and vjust arguments, when specifying the angle, anyway, lets demonstrate how the above works.\n", "Found with a GitHub search for the relevant argument names: [https://github.com/search?l=R&q=element_text+angle+90+vjust+org%3Acran&type=Code (hyper-link)]\n", "If for some (wired) reason you wanted to rotate the tick labels 90\u00b0 clockwise (such that they can be read from the left) you would need to use: q + theme(axis.text.x = element_text(angle = -90, vjust = 0.5, hjust = -1)).\n", "[ggplot 3.3.0 (hyper-link)] fixes this by providing guide_axis(angle = 90) (as guide argument to scale_.. or as x argument to guides):\n", "From [the documentation of the angle argument (hyper-link)]:\n", "Compared to setting the angle in theme() / element_text(), this also\nuses some heuristics to automatically pick the hjust and vjust that\nyou probably want.\n", "#include \"headers/my_header.h\"), while the angle-bracket form is for \"global\" includes -- those found somewhere on the include path passed to the compiler (e.g.\n", "If you add your own include folders into Header Search Paths, you can use angled brackets without any problem.\n", "Or set Always Search User Path to YES so you can use angle brackets.\n", "With angle brackets e.g.\n", "<Name.h> - Angle brackets tells to preprocessor to search in a special pre-designated system's directories.\n", "One of the issue with getting the angle between two points or any angle is the reference you use.\n", "In maths we use a trigonometric circle with the origin to the right of the circle (a point in x=radius, y=0) and count the angle counter clockwise from 0 to 2PI.\n", "The code below (in C#) gets the angle in radians then converts to a geographic angle:\n", "To get consistent results, you need to tweak your angle function.\n", "[Calculate angle from points - JSFiddle (hyper-link)]\n", "Alternatively, if you only know the length of the sides of the triangle, you can use the [Law of cosines (hyper-link)].\n", "I would use the [law of cosines (hyper-link)], since you can easily calculate the length of each side of the triangle and then solve for each angles individually.\n", "Suppose that you want the angle at A.\n", "Then you need to find the angle between the vector from A to B and the vector from A to C.  The vector from A to B is just B-A.\n", "Once you have these three vectors, you can use the algorithms you already found along with the fact that all the angles will add to 180 degrees.\n", "The minus signs in the dot product come because we're trying to get the inside angles.\n", "Given y and x, the angle with the x axis is given by:\n", "With (0.5, 0.5) the angle is:\n", "Good answers already posted, unfortunately nobody addressed that OP wanted code to calculate the direction, being rather a global angle.\n", "atan (mentioned in other answers) would give you an angle \u00b10..90\u00b0.\n", "Afterwards you'd need to figure out which quadrant the vector is in, and modify the angle accordingly; and don't forget the special cases of either x or y equal to zero!\n", "and you want to find the azimuth angle \u03c6 about the xz plane, and the inclination \u03c8 above the xz plane.\n", "The way to reverse the process and find the angles is as follows\n", "is the angle between the difference vector (connecting vector2 and vector1) and the x-axis,\nwhich is problably not what you meant.\n", "The (directed) angle from vector1 to vector2 can be computed as\n", "A robust way to do it is by finding the sine of the angle using the cross product, and the cosine of the angle using the dot product and combine the two with the Atan2() function.\n", "Nobody pointed out that if you have a single vector, and want to find the angle of the vector from the X axis, you can take advantage of the fact that the argument to atan2() is actually the slope of the line, or (delta Y / delta X).\n", "A = angle of the vector/line you wish to determine (from the X axis).\n", "I think a better formula was posted here:\n[http://www.mathworks.com/matlabcentral/answers/16243-angle-between-two-vectors-in-3d (hyper-link)]\n", "If you care about accuracy for small angles, you want to use this:\n", "angle = 2*atan2(|| ||b||a - ||a||b ||, || ||b||a + ||a||b ||)\n", "See [https://math.stackexchange.com/questions/1143354/numerically-stable-method-for-angle-between-3d-vectors/1782769 (hyper-link)]\n", "However, that has the downside that in two dimensions, it loses the sign of the angle.\n", "You don't have to use atan2 to calculate the angle between two vectors.\n", "Caveat 1: make sure the angle remains within -pi ... +pi\n", "The formula, angle(vector.b,vector.a), that I sent, give results\n", "The angle can be bigger or smaller than pi, and can be positive\n", "Here a little program in Python that uses the angle between vectors to determine if a point is inside or outside a certain polygon\n", "That way it will always be the inner angle.\n", "Getting the outer angle vs the inner angle is determined entirely by the order of your subtractions (think about it).\n", "You need to subtract the smaller theta from the larger in order to reliably always get the inner angle.\n", "I think what you're looking for is the [inner product (hyper-link)] (you may also want to look over the [dot product (hyper-link)] entry) of the two angles.\n", "Inner angle between 2 vectors (v1, v2) = arc cos ( inner product(v1,v2) / (module(v1) * module(v2)) ).\n", "I hope I understand your question correctly as wanting the acute angle rather than the obtuse angle of the intersection of two lines.\n", "Acute and obtuse angles of an intersection are 180 deg complements of each other.\n", "The function acuteAngle illustrates what you need to do, mathematically.\n", "However, it cannot be used for values of angles in the neighbourhood of PI/2 because binary comparisons of angles with results in that neighbourhood is questionable whether an obtuse or acute angle is represented.\n", "By virtue of Pythagoras' theorem,\nA hypotenuse is formed if the angle is exactly PI/2 or 90 deg.\n", "If the 3rd line is longer than\nL3Hypo, the angle is obtuse.\n", "If shorter, the angle is acute.\n", "When you use atan(slope) you lose (literally) one bit of information, that is there are exactly two angles (theta) and (theta+PI) in the range (0..2*PI), which give the same value for the function tan().\n", "Just use atan2(deltax, deltay) and you get the right angle.\n", "If you use abolute value you will always get the acute angle.\n", "If you want in between angle in 0 degree to 360 degree then use following code; Its fully tested and functional:\n", "atan2(s_y, s_x) should give you the correct angle.\n", "I use the acos function to get back the angle from the given s_x cosinus.\n", "But because several angles may result to the same cosinus (for example cos(+60\u00b0) = cos(-60\u00b0) = 0.5), it's not possible to get back the angle directly from s_x.\n", "So I also use the sign of s_y to get back the sign of the angle.\n", "for the specific case of (s_y == 0), it does not matter to take +acos or -acos because it means the angle is 0\u00b0 (+0\u00b0 or -0\u00b0 are the same angles) or 180\u00b0 (+180\u00b0 or -180\u00b0 are the same angles).\n", "The reflected amount (just looking at the maths) would be (180 - angle)\n", "result = 180-(your angle)\n", "As already explained, you find the opposite angle by subtracting your angle from 180 degrees.\n", "Aah, seems the problem came from negative numbers after all, I ensured them being positive and now the rotation does fine, I don't even need to recalculate angle...\n", "just 360-angle will flip your angle horizontaly but not verticaly\n", "angle - 360\n", "Math.Normalize(angle - 180)\n", "float flipped_vertical = angle - 360\nfloat flipped_vertical_and_horizontal = Math.Normalize(flipped_vertical- 180)\n", "This solution is for -Y oriented angles (like a watch)!\n", "For perfect particles (& light) the angle of reflection is equal to the angle of incidence, as illustrated by this diagram (from commons.wikimedia.org).\n", "I think an easier way to do this is to use the velocity of the missile instead of calculating angles.\n", "Once you get into more complicated obstacles that are not at straight angles or are moving, it will be a lot easier to work with X and Y velocities than with angles.\n", "However, once you've got the game working well with vertical and horizontal walls, probably the next thing you'll think is, \"what about walls at arbitrary angles?\"\n", "a = 2w - b\nwhere:\na => resulting angle\nw => wall or floor or ceiling angle\nb => ball angle\n", "This is what I come up after trying to find the simplest formula for computing just the resulting angle of ball bouncing the walls, ceiling and floor.\n", "The result could go beyond +360 or -360 degrees but they are still equivalent angle.For example if the ceiling angle is 270deg and the ball angle is 30deg, the resulting angle is 510deg which is equivalent to +150deg or -210 deg.\n", "To use difference and sum operations appropriate to angles.\n", "In C for angles in degrees this is the remainder function, in the math library:\n", "Right angle brackets are legal within a <pre> tag or as text within an element.\n", "Personally, I just escape these whenever I need to use them, just to match left angle brackets...\n", "It is used in many contexts, like HTML markup, as a delimiter of a kind, in a bracket-like manner, but the real angle brackets, as used in some mathematical notations, are rather different, such as \u201c\u27e9\u201d U+27E9.\n", "If you need to include angle brackets in an HTML document, you have some serious issues to consider, but they relate to fonts (and semantics), not to any potential clash with markup-significant characters.\n", "You'll want to draw it from (0, 0) to (x_length, tan(angle)*x_length).\n", "The gradient will be tan(angle).\n", "Starting point you know (x1, x2), end point is (x1 + l * cos(ang), y1 + l * sin(ang)) where l is the length and ang is the angle.\n", "Then if you are given a length [L] and an angle from the x-axis [a]:\n", "If the angle is from the y-axis - swap the cos and the sin.\n", "You may find an ambiguity as to which direction you want the line to go,\nyou need to be careful how you define your angle.\n", "m can be calculated by angle; m =  tan(angle)\nAnd if you know a start point then you can find n.\n", "So n = startPoint_Y - (tan ( angle) * startPoint_X )\n", "If you want to draw a line-segment and you know the length, the start point and the angle, there will be two equations.\n", "where a is a tangent of an angle between a line and X-axis, and b is an elevation of the line drawn through (0, 0).\n", "Line equation given angle and a point\n", "You can easily calculate a (since you know angle), but you don't know b.\n", "Draw a segment given point, angle, length\n", "We want to draw a segment from starting point so that it's length is L and angle to the x-axis is fi.\n", "You should imagine a right-angled triangle whose acute angle positioned at (x0, y0).\n", "You know Hypotenusa (L) and an angle (fi).\n", "from a point (x1, y1), and an arbitrary angle \u03b1 we need to distinguish two cases:\n", "Angle becomes 20 (which is good) but in the next iteration Clamp(20, 300, 380) angle becomes 300 (which is causing the weird jump).\n", "TargetAngle, the angle which you do not want to deviate from by more than a small amount\n", "Deviation, the min and max angle (TargetAngle - Deviation, TargetAngle + Deviation)\n", "InputAngle, the angle the algorithm should fix\n", "TargetAngle - Deviation >= 0 && TargetAngle + Deviation < 360\n", "angle = MathHelper.Clamp(InputAngle, TargetAngle - Deviation, TargetAngle + Deviation);\n", "TargetAngle - Deviation > 0 && TargetAngle + Deviation > 360\n", "Lets see what happens if we take TargetAngle = 350 and deviation = 20 the acceptable ranges are now 350-360 and 0-10.\n", "TargetAngle - Deviation < 0 && TargetAngle + Deviation < 360\n", "Lets take TargetAngle = 10 and deviation = 20.\n", "this is the angle object'll want to move\n", "You can take your transform's forward, and the vector to your target, and get an angle or rotation from those:\n", "Here is a Pandas/Numpy based solution for interpolating an angle series with NaN data.\n", "Quaternios and Axis-angle are both 4D representations of 3D rotations/orientations and both have pro's and cons.\n", "Axis-angle: represents the rotation by its angle a and the rotation axis n. For example, a rotation of 180 degrees around the Y-Axis would be represented as a = 180, n= {0,1,0}.\n", "That's where the sine and cosine of the half angle come from.\n", "In the case of the angle function applied to the point -1 in the complex plane, any odd multiple of \u03c0 is theoretically a correct answer.\n", "Angle values are normalized to be in the range [-\u03c0, \u03c0], however, which leaves only two odd multiples of \u03c0 to choose between:\u00a0\u00b1\u03c0.\n", "If you approach -1 from above in the complex plane, then \u03c0 is the is the answer that respects continuity since the angle of values slightly above the real line are close to \u03c0.\n", "If you approached -1 from below, however, then -\u03c0 is the continuous answer since angles just below the real line are close -\u03c0.\n", "Accordingly, when we evaluate angle near -1 the sign of the imaginary part is significant \u2013\u00a0even if its value is zero (\u00b10.0) \u2013\u00a0so we give different answers for -1 \u00b1 0.0im:\n", "angle(-1 + 0.0im) == +3.141592653589793\n", "angle(-1 - 0.0im) == -3.141592653589793\n", "These answers respect the continuity of angle with respect to the sign of the imaginary part of the argument.\n", "To convert an angle from a north=0 to east=0, I use:\n", "No idea if I understand your problem, but a method that calcaluates an angle between -90 and 90 degree from an input value in the range 261 to 395 would simply look like this:\n", "never causes a return for the angle in question; since maxAngle is negative and minAngle is positive, angle can never be both greater than a positive minAngle and less than a negative maxAngle.\n", "As a result, even when the angle is between the two limits, execution for this joint falls through to the part where, it looks like, the angle is forced towards the closest limit.\n", "You need some special case code to replace the quoted test above for cases where maxAngle is negative and minAngle is positive.\n", "To convert degrees to radians multiply the angle by /180:\n", "Note: if you just want to convert an angle in degrees to angle in radians you can use the formula above:\n", "Let's compute angles of the triangle with a help of [Law of cosines (hyper-link)]:\n", "now put triangle lengths\n", "into formulae above and you'll get angles (in radians, if you use c# Math.Acos)\n", "if a point P is inside triangle ABC, then\n", "If angle2 were always 0, and angle1 were always between 0 and 180, this would be easy:\n", "I've done this before by comparing angles.\n", "So it comes down to having an angle algorithm between two vectors p and q which is simply put like:\n", "It supports angle ranges larger than 180 degrees (as well as larger than 360 degrees and negative angles).\n", "The method uses this normalize() helper function to convert angles into the right space:\n", "where (in case of checking angles) modN() would be implemented as\n", "If you have angles $$a$ and $b$, and wan't to see if angle x is between these angles.\n", "You can calculate the angle between a->x and a->b.\n", "The distance between to angles, a and b\n", "Is angle T between angles A and B, there are always two answers: true and false.\n", "We need specify what we mean, and in this case we're looking for the normalized small sweep angles and whether our angle is between those values.\n", "Given any two angles, there is a reflex angle between them, is the normalized value of T within that reflex angle?\n", "If we subtract the angle from test, then add 180\u00b0 (so A is relative to T+180).\n", "We subtract 180\u00b0 giving us a value between [-180\u00b0,180\u00b0] relative to T+180\u00b0-180\u00b0 aka, T. So T is now angle zero and all angles fall within the normalized range.\n", "Now we check to make sure the angles have a sign change and that they are not more than 180\u00b0 apart, we have our answer.\n", "Normalize will move angle a into the range [-180\u00b0,180\u00b0] relative to angle t.\n", "I'm just reposting a portion of an answer which I posted here: [https://stackoverflow.com/a/42424631/2642059 (hyper-link)] That answer also deals with the case where you already know which angle is the lefthand side and righthand side of the reflexive angle.\n", "But you also need to determine which side of the angle is which.\n", "1st to find the leftmost angle if either of these statements are true angle1 is your leftmost angle:\n", "angle1 <= angle2 && angle2 - angle1 <= PI\n", "angle1 > angle2 && angle1 - angle2 >= PI\n", "For simplicity let's say that your leftmost angle is l and your rightmost angle is r and you're trying to find if g is between them.\n", "Since you're calculating the lefthand and righthand sides of the angle, you'll notice there is an optimization opportunity here in doing both processes at once.\n", "a1 and a2 are ends of the first sector, b1 and b2 are ends of the second sector, ma and mb are bisectors, da and db are half-angles:\n", "If dy is negative, then so is the initial p. So for positive dx we already have a range -1 <= p <= 1 monotonic in the angle.\n", "There is a way to obtain the range [0 \u2026 4] (for real angles [0 \u2026 2\u03c0]) without introducing a further case distinction:\n", "In this form the max error is only ~0.07 radian for all angles.\n", "I kinda like trigonometry, so I know the best way of mapping an angle to some values we usually have is a tangent.\n", "But there is a function that maps [1,+inf[ to [1,0[ known as inverse, that will allow us to have a finite range to which we will map angles.\n", "That gives the following piecewise function, which is a continuous and monotonous function of the angles, with only one discontinuity (which is the minimum) :\n", "Note that this is very close to [Fowler angles (hyper-link)], with the same properties.\n", "Formally, pseudoangle(dx,dy) + 1 % 8 == Fowler(dx,dy)\n", "As you can see on the graph the angle-pseudoangle relation is also nicely close to linear.\n", "If you can feed the original vectors instead of angles into a comparison function when sorting, you can make it work with:\n", "If angles are not needed by themselves, but only for sorting, then @jjrv approach is the best one.\n", "Of course, for more precise calculations, isangleless should be equipped with bigfloat from time to time, but the same can be told about pseudoangle.\n", "For the record, the \"computation\" is 360 - angle, if the angle is in degrees, or Math.PI - angle if the angle is in radians.\n", "(Or ... maybe, you just want -angle.\n", "Your terminology - \"clockwise angle\" and \"anti-clockwise angle\" is ambiguous.)\n", "float newAngle = (trackBox.angle > 90 ?\n", "180 - trackBox.angle : -1*(trackBox.angle));\n", "If this does not work, please post your code for extracting the roll angle so that we can have a look at the numbers.\n", "You should realize that 360 is the same as 0, so you can compare angle with targetAngle and also with targetAngle+360 and move it to the direction to which it is closest (consider -360 as well for angles close to 0 and targetAngle close to 360)\n", "angle is closest to targetAngle-360, so you would decrement it, instead of incrementing it\n", "Angle Bisection:\n", "This should bisect an angle on the \"smaller\" side.\n", "Given an angle a, to constrain it to -180, 180 you can just do:\n", "So if figured out a way to effectively do what i want using Mystical's approach to constraining the Angle.\n", "Map angle(+PI ~ -PI) to signed int value (or short value):\n", "So as in your example, if A=-170 and B=160, then the angle halfway between them is\nA + 0.5*(angleRef(B,A) - A) = -185\n", "or if you prefer A=160 and B=-170\nA + 0.5*(angleRef(B,A) - A) = 175\n", "Firstly, since you're in radians it's probably beneficial to define your angle as such:\n", "Additionally, in the question you want distance X and angle Y...\n", "Are you sure the angles you are passing in are correct for angles > 90 degrees?\n", "You can normalize angles in such a way that ang become 0 and min and max is mapped to [-180; 180).\n", "Then you can check if angle is in provided range like this:\n", "If you want to clamp the angle so that it stays within the range but it wraps around when it reaches max or min (instead of clipping to the limits) then you could use this fairly simple function I worte using python:\n", "So calculate the clockwise angle, then add 2*pi until it is above zero, then take the result mod 2*pi, and you will get a result in the range [0, 2*pi).\n", "The following function should allow for input angles both smaller and larger than 0...360 to be converted into that range:\n", "And then subtract angle of received symbol from ideal symbol to get phase error.\n", "For example, there's a function called angle(), but you can do this:\n", "alpha is the angle you want to rotate by\n(in degrees!)\n", "I think you're after 180 - yourAngle.\n", "[http://en.wikipedia.org/wiki/Supplementary_angles (hyper-link)]\n", "If you view your \"angle\" as a 2D vector in the plane, you simply change the sign of the component normal to the \"mirror\" plane.\n", "So, for example, a 45 degree angle (1, 1) \"mirrored\" in the yz-plane becomes (-1, 1).\n", "I was playing around with a rope physics project of mine and used this to mirror angles.\n", "This will work with values over 360 degrees because the modulus operation normalizes your angle, and subtracting that result from 0 will mirror it horizontally.\n", "As ChrisF mentioned,\nthe idea of taking an \"angle between two points\" is not well defined.\n", "If you were calculating the angle using Cartesian coordinates, and both points were in quadrant 1 (where x>0 and y>0), the situation would be identical to screen pixel coordinates (except for the upside-down-Y thing.\n", "Converting screen pixel coordinates to Cartesian doesnt really change the angle.\n", "similar to the angle when we drawArc\n", "An angle by definition has no direction, but is rather the measure of the radial distance between two intersecting lines.\n", "Various libraries/css methods might measure the angle from a certain direction - like up for example, but this totally depends on the context.\n", "Javascript itself has no concept of directions to angles - it is something that has to be built on top of javascript's angle functions.\n", "On a regular unit circle, the y axis points up, so the angles increase counter-clockwise:\n", "But in an HTML document, or the canvas element, the y axis points down, so if you increase the angle t and plot points on x, y with cos(t), sin(t), the result will be clockwise:\n", "As the other answers say, that's not because of how angles work in JavaScript, but because of how the coordinate space is oriented.\n", "The other possibility is using just numpy and it gives you the interior angle\n", "You can also specify a viewing angle to compute the angle via projection:\n", "Or compute the signed angle via projection:\n", "For the few who may have (due to SEO complications) ended here trying to calculate the angle between two lines in python, as in (x0, y0), (x1, y1) geometrical lines, there is the below minimal solution (uses the shapely module, but can be easily modified not to):\n", "If you want to have signed angles you have to determine if a given pair is right or left handed (see [wiki (hyper-link)] for further info).\n", "Easy way to find angle between two vectors(works for n-dimensional vector),\n", "You can check if a number is less than 0 and add 360 to it if you want all positive angles, too.\n", "Numpy's [arctan2(y, x) (hyper-link)] will compute the counterclockwise angle (a value in radians between -\u03c0 and \u03c0) between the origin and the point (x, y).\n", "You could do this for your points A and B, then subtract the second angle from the first to get the signed clockwise angular difference.\n", "This difference will be between -2\u03c0 and 2\u03c0, so in order to get a positive angle between 0 and 2\u03c0 you could then take the modulo against 2\u03c0.\n", "One advantage of the numpy version is that you can also pass two (2, ...) arrays for p1 and p2 in order to compute the angles between multiple pairs of points in a vectorized way.\n", "This is supposed to be a 90 degree angle from A to B.\n", "A formula that calculates an angle clockwise, and is used in surveying:\n", "The formula gives angles from 0 to 2pi,start from the North and\n", "Since sign of cosine function is periodically changed, angle() is also oscillated.\n", "The angle function can be expressed as angle(z) = imag(log(z)) = atan2(imag(z),real(z)).\n", "[https://www.mathworks.com/help/matlab/ref/angle.html (hyper-link)]\n", "The angle on the positive numbers should be 0 and the angle on the negative numbers should be an odd-integer multiple of pi in general.\n", "If you're not clear why the negative numbers don't have angle = 0, plot it out in the complex plane and keep in mind that the radial part of the complex number is positive by definition.\n", "That is z = r * exp(i*theta) for positive r and theta given by this angle you're computing.\n", "If I understand you correctly you will always have triangle with one right angle and two other 45 degrees.\n", "If short side (both of them will have same length) of such triangle is X, then long side is square root from 2*X*X\n", "Also, I believe this will give you the angle from 0 to the hypotenuse of the triangle you've provided (not entirely sure).\n", "I'd suggest trying Math.PI - angle.\n", "What your code currently does is find the angle of the vector b in reference to 0,0 and subtract the angle of the vector a in reference to 0,0.\n", "tan(angle) = opposite/adjascent\n", "arctan(opposite/adjascent) = angle\n", "so the angle you need is: Pi - angle(a-b).\n", "if you are looking for the \"angle between vectors a and b\", you want the delta of the angle for vector a and the angle for vector b:\n", "But the diagram doesn't match \"angle between vectors\".\n", "Then you know that z^2=x^2+y^2-2*xycos(ANGLE YOU WANT)\n", "therefore, that angle is cos^-1((z^2-x^2-y^2)/(2xy))=ANGLE\n", "where a is the side opposite angle \u03b1, b is opposite angle \u03b2, and c is opposite angle \u03b3.\n", "So \u03b2 is what you called angle ABC.\n", "Your method will yield the same angle for ABC and CBA.\n", "One correct method for calculating the angle is as \"oslvbo\" suggests:\n", "Obviously rotating both vectors doesn't affect the angle between them.\n", "OTOH after such a rotation one just has to find out the angle of the 2nd vector relative to X-axis.\n", "Here is a quick and correct way of calculating the right angle value:\n", "Here's an OpenCV way to get the angle between 3 points (A, B, C) with B as the vertex:\n", "To do this calculate the z-delta by tangens of the desired angle.\n", "But the normal definition is the bisector of the included acute angle.\n", "There are many ways to do this, but a simple one is to increment or decrement one of the angles.\n", "If the angles are a and b, then this will do it:\n", "Note that if your angles are always normalized to [0..360) none of these loops ever execute more than once.\n", "Let \u03b81 and \u03b82 be your two angles expressed in [radians (hyper-link)].\n", "Then we can determine the x and y components of the unit vectors that are at these angles:\n", "Finally, you can determine the angle of this resulting vector:\n", "You want to bisect the angles not average them.\n", "First get the distance between them, taking the shortest way around, then divide that in half and add to one of the angles.\n", "In a comment, you mentioned that all \"angles\" to be averaged are within 90 degrees to each other.\n", "So, you just need to detect that special case, and when it happens, treat the angles in the 270-359 quadrant as -90 to -1 instead.\n", "Mainly, I needed it to rotate clockwise when the angle increased.\n", "now for orientation of circular values to keep angle between 0 and 359 can be:\n", "So your current system shows you the cosine of your angle divided by 2, as I would expect a 90\u00b0 value for West.\n", "That angle system is very weird.\n", "It seems like your \"angle\" is calculated as sin(radians(d/2)) where d is actual angle in degrees (with south being 0\u00b0 and east 90\u00b0).\n", "Let's define a proper function angle that takes as arguments two vectors x1 and x2\n", "Note that we do a numeric stability check to ensure that for angles close to 0, we get a numeric result (instead of NA).\n", "Then to calculate the angle (in radians) between two vectors, e.g.\n", "Also, i would guess that a new Rectangle doesn't by default have a RotateTransform, so you probably need to create a new instance of that, too:\n", "You need to apply a skew transform for change angles in Rectangle, look at this: [How to: Skew an Element (hyper-link)]\n", "It derives from my own rectangle\n", "The position of the rectangle is the middle (centre) point of the rectangle, not uppper left corner.\n", "Then I translate the position system to the centre of the rectangle and perform the rotation\n", "Then, I draw the rectangle.\n", "This part will be obviously different, based on how you want to draw the rectangle.\n", "You would propbably use either FillRectangle (as I do) or DrawRectangle which draws only the borders:\n", "Finally I restore the original state of the graphic device, which cancels the translation and rotation I used only for drawing the rotated rectangle\n", "If the difference between the output of atan2 and your previous angle is greater than pi, then you know that some wraparound occurred, and you have to correct for it by adding/subtracting 2*pi.\n", "No deal with angles, cosinus or sinus ...\n", "i think you're looking for math.acos not math.cos, you want to return the angle whose value is the ratio of those two sides.\n", "Trig functions will convert an angle into a length of a certain leg of a certain triangle.\n", "math.tan(7/7) is the length of the right triangle opposite an angle of 1(=7/7) radian.\n", "As noted, you're looking for an inverse trig function to convert a length back into an angle.\n", "This accepts two inputs as two heights of the triangle and you can get the output angle in proper degree format.\n", "The relation between sides and angles of triangle is:-\n", "where 'a' is the side opposite angle 'A'.\n", "You know one angle let's say it's A = 90.\n", "Then you can calculate other two angles from above equation.\n", "You have the lengths of the sides, if you us tangents, you can find the angle for the corresponding side.\n", "Also, once you find one angle, all you need to do is subtract 90 from it to get the final angle:\n", "Solution: How would I find the angle of the triangles\n", "Somehow DrawArc calculates the angles/drawing based on an arc with regular radius and it therefore takes the longer side.\n", "(were alpha is the angle between the vectors)\n", "What this means is that that sum shown on the left is equal to the product of the absolute values of the vectors times the cosine of the angle between the vectors.\n", "and you just need the arccos function (or inverse cosine) applied to cos(\u03b8) to get the angle.\n", "Depending on your arccos function, the angle may be in degrees or radians.\n", "It follows that the R code to calculate the angle between the two vectors is\n", "Another solution : the correlation between the two vectors is equal to the cosine of the angle between two vectors.\n", "so the angle can be computed by acos(cor(u,v))\n", "where theta is the angle between the vectors x and y expressed in radians.\n", "If the above information makes sense then the angle() function that follows should be clear without further comment.\n", "For 2D-vectors, the way given in the accepted answer and other ones does not take into account the orientation (the sign) of the angle (angle(M,N) is the same as angle(N,M)) and it returns a correct value only for an angle between 0 and pi.\n", "Use the atan2 function to get an oriented angle and a correct value (modulo 2pi).\n", "Check that angle2 gives the correct value:\n", "if you install/upload the library(matlib):\nthere is a function called angle(x, y, degree = TRUE) where x and y are vectors.\n", "If you want to calculate the angle among multiple variables, you can use the following function, which is an extension of the solution provided by @Graeme Walsh.\n", "They're using the very large negative and positive numbers to make sure that the normalization caps angles to the range [-180, 180] degrees properly.\n", "Your seconds calculation doesn't seem to be correct for negative angles (again, this is tied to the previous issue and whatever sign convention you have decided to implement).\n", "Unless the convention is that negative angles must have negative deg, min and sec, the way you are computing seconds is wrong because you are always adding the minutes and seconds terms no matter the sign of deg.\n", "If you deal with small values it's okay, but imagine you have some angle like 1e+25, that'd be 1.59e+24 iterations or about 100 million years to compute if you have a decent CPU.\n", "If you have the right settings, the squares should be isolated and you will be able to calculate the angle.\n", "If you find a more or less straight path, you can use the extreme points as you are doing now to determine the angle.\n", "Since the checker-board rotation is only relevant within 90 degrees, your angle should be modulo 90 degrees or pi over 2 radians.\n", "Find the angle for each, then interpolate between the two angles.\n", "Those points are very close one to another, so a slight error in pixel location of of the points leads to a large error in the angle.\n", "Find the line angle of every square.\n", "You have at least 9 squares in the image, 4 lines in each square which give you total of 36 angles (18 will be roughly at 3[deg] and 18 will be ~93[deg]).\n", "Remove the 90[degrees] and you get 36 different measurements of the angle.\n", "Now calculate the angle between them.\n", "Just smooth the image, calculate gradients in X and Y directions (gx,gy), calculate the angle of the gradient in each pixel atan(gy,gx) and make histogram of the angles.\n", "For problems like yours, a robust solution is to find edge points along the dark-to-light transitions with sub-pixel accuracy, then fit lines to the edge points, and use the line angles.\n", "From the line equations for each of your four line fits, calculate the line angle.\n", "That algorithm finds the angles independently for each black checkerboard square.\n", "All that said, if you're willing to settle for a slight loss of accuracy, and if you know that the image does not suffer from radial distortion, etc., and if you just need to find the angle of the parallel lines defined by all checkboard edges, then you might try..\n", "Find the angles between corner points.\n", "The problem is that [Math.Acos (hyper-link)] returns only angles in the range [0, \u03c0].\n", "This is because there are always two angles between two vectors, and your calculations will always return the smaller one.\n", "To fix this you need to redefine your notion of \"angle between dinosaurs\".\n", "To resolve this ambiguity you can calculate a clockwise angle between vectors:\n", "I've found the solution here: [Direct way of computing clockwise angle between 2 vectors (hyper-link)]\n", "Inner angle of regular n-gon is 180*(n-2)/n ([wiki (hyper-link)]) : 90 for square, 120 for hexagon.\n", "(90 - CurrentAngle) + 90;\n", "Then the angle has to be rewrapped to the 180/-179 plane.\n", "To rotate current direction vector to new one, you need to calculate relative angle.\n", "If the angle is in degrees, first do:\n", "Where d is the distance from the origin and theta is the angle.\n", "If your angle is in degrees, divide by 180/Pi.\n", "this should return an angle in radians which is in the range [-pi, pi].\n", "The first 3 sets of (X,Y) define a right angle (th=90).\n", "So those points sit on top of each other and there is no angle.\n", "This version removes points where dx2+dy2=0 (lines of length=0), in other words repeated points at the same location, and calculates the angles for the remaining points.\n", "Note that I'm using \"internal\" angles (<180).\n", "Finally, we plot the data to show that these are indeed the proper angles:\n", "Otherwise the angles are distorted.\n", "a (angle)\n", "Angle range; x; y\n", "I just wrote [Fastest way to sort vectors by angle without actually computing that angle (hyper-link)] about the general question of finding functions monotonic in the angle, without any code or connections to C++ or the likes.\n", "targetVectorX and targetVectorY are not both equal to zero at the same time) will result in finite pseudoangle values.\n", "The resulting pseudoangles will be in the range [\u22122 \u2026 2] for real angles [\u2212\u03c0 \u2026 \u03c0], so the signs and the discontinuity are just like you'd get them from atan2.\n", "For Objective C we have to normalize the angle like below function.\n", "[There are 2 ways (hyper-link)] to represent the same rotation with Euler angles.\n", "I personally don't like Euler angles, [they mess up the stability of your app.\n", "[Quaternion to Euler Angles (hyper-link)]\n", "[Euler Angles to Quaternion (hyper-link)]\n", "If you end up needing quaternion's to Euler angles, but you need an arbitrary rotation order, I came across a site with conversion code.\n", "(Btw, the orders that have the same letter twice, like XYX, are proper Euler angles, but the ones like XYZ are Tait-Bryan angles).\n", "My solution takes in account wraparounds and works for any angles.\n", "Do you really need the angle in radians / degrees, instead of as a unit vector or rotation matrix?\n", "An xy unit vector can represent angle instead of absolute direction; the angle is the angle between the vertical (or horizontal) axis and the unit vector.\n", "Trig functions are very slow compared to simple multiply / add / subtract, and still slow compared to div / sqrt, so representing angles as vectors is usually a good thing.\n", "This will return the angle between a horizontal vector from (x1,y1) to (x1+1,y1) and the vector from (x1,y1) to (x2,y2).\n", "I think that you are asking how to change the angle of the view so the pins near the distance you say are visible in a different perspective, if im correct this is the answer:\n", "You need to use the method setCamera on the MKMpaView, this receives an MKMapCamera, you can instantiate a camera like this let camera = MKMapCamera(lookingAtCenter:CLLocationCoordinate2D, fromDistance: CLLocationDistance, pitch: CGFloat, heading: CLLocationDirection)\nwhere pitch is the angle, all the other parameters are super clear.\n", "It's not written anywhere in the documentation, but it's still being able to calculate the viewing angle of MKMapCamera manually.\n", "For instance, SCNCamera has a property called fieldOfView, which is vertical viewing angle and it equals 60 degree.\n", "To do this for the  three points you'll need to call atan2() twice: once to find the angle of AB, and once for the angle of BC.\n", "Take the difference between these two to find the angle between AB and BC:\n", "Note that this is assuming that B is the \"center\" point of the angle you're interested in.\n", "This function should return the angle in radians.\n", "For multiple vectors stored on the columns of a matrix, one can calculate the angles using this code:\n", "The [PlgBlt (hyper-link)] function performs a bit-block transfer from the specified rectangle in the source device context to the specified parallelogram in the destination device context.\n", "I assume you want the angle between the two points and the origin O(0,0).\n", "Well each point makes a triangle bounded by its height, its base and its hypotenuse, so you get two angles alpha1 and alpha2.\n", "The idea is to find each of these and compute your required angle beta, by doing beta = alpha1 - alpha2 where alpha1 is such that alpha1 > alpha2.\n", "It's just float angle = atan2(p1.y - p2.y, p1.x - p2.x).\n", "Of course the return type is in radians, if you need it in degrees just do angle * 180 / PI\n", "This is why many games institute a \"Calibration\" phase during start-up of a level, etc... the software requiring calibration lets the user know not to change the angle after calibration by default.\n", "The main idea is storing the number of tracked joints for each angle and choosing the angle with maximum number of joints tracked.\n", "You need to check boundary conditions (apparently, if points are colinear) and apply the proper calculation to find the angle.\n", "Also, a triangle can't have any (interior) angle greater than 180 degress.\n", "Sum of angle of triangle is 180 degrees.\n", "AngleN is the amount turned at each junction (ie point N+1).\n", "A positive angle is a right turn and a negative angle a left turn.\n", "You can then subtract this angle from 180 to get the actual interior angle that you want.\n", "if it is to the left just add 180 to your angle\n", "Math.sin() and Math.cos() expect the angle in radians.\n", "You should transform your angles to radians (angle*Math.PI/180).\n", "Them being angles makes no difference, unless you want to take into account the fact that as you go round a circle, an angle of 405 is the same as an angle of 45.\n", "In which case you can just use a % 360 to get the angle betweeen 0 and 360.\n", "I needed to calculate id a gps location is inside a rectangle.\n", "Or, I needed to see if an angle x is between angle check+r and angle check-r.\n", "If you need a<x<b, find the angle check in the middle of a and b and then the distance (r) of check from a or b.\n", "The method normalize, changes the angles from -infinity...infinity to -180...180.\n", "The method check, takes the arguments\nx: the angle that we need to see if it is between the angles check-r and check+r.\n", "check: the angle to check with.\n", "r: the radius around angle check.\n", "1st off, every angle is between 2 other angles, what you're really asking is:\n", "You can just go ahead and define a as the leftmost angle and b as the rightmost angle or you can solve for that, for example if either of these statements are true a is your leftmost angle:\n", "For simplicity let's say that your leftmost angle is l and your rightmost angle is r and you're trying to find if g is between them.\n", "Let a be the start angle and b the end angle and we are checking whether c is between them clockwise, that means when you go from a to b you must pass c. The approach of checking whether c is in the range from a to b gives you false positives when b is greater than a numerically.\n", "Actually the angle is negative for the values -90 to 0 also, but you add 90 to the angle, so you don't see that.\n", "Simply add 360 to the angle when it's negative:\n", "atan2 gives angles in radians, in the range [-pi,pi], you want angles in degrees in the range [0,360].\n", "Your conversion gives you angles in degrees in the range [-180+90,180+90] = [-90,270].\n", "I think you may be looking for the [Vector2.Dot (hyper-link)] method which is used to calculate the product of two vectors, and can be used for angle calculations.\n", "Is this what you're looking for, or do you need the exact angle?\n", "The actual angle in radians is\n", "CGFloat angle = atan2(card.transform.b, card.transform.a);\n", "Also the kinect sensors don't push any data while it is adjusting its angle.\n", "=> move the angle up when the head is too close to the top of the screen\n", "=> move the angle down when the head is under half the screen heigth\n", "I'd suggest moving the angle up and down untill you get a tracked skeleton (and abort after a few tries so it doens't just keep adjusting)\n", "Depending on how your application is operation you can monitor either one of these and, when clipping of the Skeleton is detected, adjust the [KinectSensor.ElevationAngle (hyper-link)] accordingly.\n", "First make sure that the angles are comparable, then it's a simple range comparison:\n", "As one commenter already said, there is only an angle between three points or between two intersecting vectors, that can be derived from this threee points.\n", "I assume you want the angle, that the gun and the target (vector 1) and the X-Axis (vector 2) has.\n", "Here is a link to a page, that explains how to calculate that angle.\n", "[http://www.euclideanspace.com/maths/algebra/vectors/angleBetween/index.htm (hyper-link)]\n", "The tangent of the angle between two points is defined as delta y / delta x\nThat is (y2 - y1)/(x2-x1).\n", "This means that math.atan2(dy, dx) give the angle between the two points assuming that you know the base axis that defines the co-ordinates.\n", "Your gun is assumed to be the (0, 0) point of the axes in order to calculate the angle in radians.\n", "Once you have that angle, then you can use the angle for the remainder of your calculations.\n", "Note that since the angle is in radians, you need to use the math.pi instead of 180 degrees within your code.\n", "Your code to calculate the angle between the gun and the target is thus\n", "The Python ATAN2 function is one of the Python Math function which is\n  used to returns the angle (in radians) from the X -Axis to the\n  specified point (y, x).\n", "You can just use the as_polar method of Pygame's [Vector2 (hyper-link)] class which returns the [polar coordinates (hyper-link)] of the vector (radius and polar angle (in degrees)).\n", "In general, the angle of a vector (x, y) can be calculated by math.atan2(y, x).\n", "Therefore the angle of the line is math.atan2(y2-y1, x2-x1).\n", "The unit of the angle in the Python math module is [Radian (hyper-link)], but the unit of the angle in PyGame functions like [pygame.transform.rotate() (hyper-link)] is [Degree (hyper-link)].\n", "Hence the angle has to be converted from Radians to Degrees by math.degrees:\n", "This can be simplified by using the [angle_to (hyper-link)] method of the pygame.math.Vector2 object.\n", "This method computes the angle between 2 vectors in the PyGame coordinate system in degrees.\n", "Just calculate the angle between the vector and (1, 0):\n", "[angle_to (hyper-link)] can be used to calculate the angle between 2 vectors or lines:\n", "The angle Q that our object will make with the ray beginning at the origin and pointed at the positive X-axis is given by Q(t) = Q0 + Wt, where Q0 is the angle the object makes at time t = 0 (the initial condition).\n", "If we can assume angle to be -90 <= angle <= 90, then this could be as easy as:\n", "If you want them to count to the higher angle, just use <= instead of <.\n", "If you want a more generic approach to snap an angle to an arbitrary list of snapPoints:\n", "Now, whatever angle (say, N) , it will always be: 10-N < 100-N < 190-N\n", "So let's step through your code for angle = 50:\n", "The problem is that you are not using your converted value of angle.\n", "So what happens is right now you are basically just printing your angle in radians.\n", "It depends on whether your angles specify a rotation in the clockwise or anti-clockwise direction.\n", "But let's consider only the short way around, assuming that angles are specified in a clockwise direction:\n", "After subtracting the angles, the result can be in the range of -360 (-180 minus 180) to 360 (180 minus -180).\n", "Angles with an absolute value between 180 and 360 correspond to the \"long way around\" rotations, and adding or subtracting 360 converts them to the \"short way around\".\n", "If the angles are specified in an anti-clockwise direction, then the meaning of the return value is reversed (1 means left, -1 means right)\n", "The definition of positive and negative angles is heavily depending on the reference system or reference point.\n", "Despite of its 'correct' definition, the basic calculation can be pretty much done based on the [slope (hyper-link)] between two points and the resulting angle of incline which can be calculated by applying the inverse [tan (hyper-link)] to the slope.\n", "Both of these functions, regardless of the implementation in the math module or numpy package, return the calculated angle in radians which is basically based on the number Pi instead of degrees which makes some further conversion necessary.\n", "I read your problem statement as follows: given 2 points A and B, and a center O, find the angle A to B as the angle, positive if anticlockwise, between the vectors A\u2192O and A\u2192B.\n", "find the angle between A\u2192B and a horizontal, rightward line passing in A,\n", "find the angle between A\u2192O and a horizontal, rightward line passing in A,\n", "find the angle A to B as the difference of said angles,\n", "The last line normalize your result AB to be in the correct range -\u03c0 < AB \u2264 \u03c0, adding or subtracting 2\u03c0 that doesn't change the meaning of the measured angle.\n", "If you consider the coordinates x0=xavg-xA, y0=yavg-yA and x=xPoint-xA,y=yPoint-yA, the formula f(x,y) gives the signed angle that is positive as counter clockwise.\n", "well, it seems to move at different speeds for different angles.\n", "like plot x will not appear in a 45\u00b0 degree angle to the x-axis.\n", "The first value is the cosine of the rotation angle, and the second is the sine of the rotation angle - as long as you don't have any more transforms accumulated on that element.\n", "Lat and lon are spherical angle coordinates.\n", "Once you have those it's easy to calculate the angle in radians using the dot product.\n", "angle between two vector is Math.acos([Dot Product (hyper-link)]) result is in radiants, thus you'd multiply by Math.Pi/180\n", "Looking at this [post (hyper-link)], I notice that if you want to convert this vector into angles, you can use the following algorithms.\n", "(Personally, I update the rotation angle in the startDeviceMotionUpdates method, and update this transform in a CADisplayLink, which decouples the screen updates from the angle updates.)\n", "The formula for the angle (also called the slope of the line) is as follows:\n", "Also, note that angle is returned in radians so if you need to get the angle in degrees you need to multiply by 180 and divide by PI:\n", "As Miky D points out the angle is in radians, but you'll probably need it in that form for calculating the angle of the arrow head anyway.\n", "Just pass in an X and a Y value, and it gives you an angle.\n", "It converts x/y coordinates to angles and takes care of all of the messy math for you.\n", "ANGLE takes advantage of this and does extensive loop unrolling:\nIf you have for ( int b = 0; b < numberOfSplitpoints; b++ ), the numberOfSplitpoints has to be constant expression, otherwise the shader won't compile.\n", "What does your \"Angle\" class represent?\n", "Calculate the angle between the two vectors, i.e.\n", "[https://math.stackexchange.com/questions/974178/how-to-calculate-the-angle-between-2-vectors-in-3d-space-given-a-preset-function (hyper-link)]\n", "you calculate two angles.\n", "There is a well-known identity linking the cross-product of two vectors to the angle between them:\n", "Where theta is the smaller angle.\n", "However, this can be in the range [0, 180], over which the inverse sine function is multi-valued: an acute angle theta is such that sin(theta) = sin(180 - theta), so we can't directly obtain it from this formula.\n", "Here are the necessary changes to the AngleModel class to make it work:\n", "The phrase \u201cangle shouldn't be higher from 90\u00b0 on the left and right\u201d does not have a well-defined meaning in English, so I am not sure what you intend.\n", "However, the following figure shows the relations between various angles and the signs of rise and run when point (x1, y1) is located where the lines cross and (x2, y2) is in particular octants.\n", "With color it represents the variation of color intensity in a direction represented by angle.\n", "Here the figure shows the color variation in horizontal direction (angle is set 0).XML code:\n", "Here the figure shows the color variation in vertical direction (angle is set 90).XML code:\n", "android:angle\nInteger.\n", "The angle for the gradient, in degrees.\n", "More simply, give the angle value relative to the point where you want it to start.\n", "It will start with startColor according to the angle value.\n", "and add a return at the end of the function angle():\n", "So you should be looking at the cos(phi/2)*cos(psi/2) term for the angle.\n", "angle = 2 * cos^-1(w) = 2 * cos^-1( cos(phi/2)cos(psi/2) )\n", "The theta value of 30 arc degrees is a data-space angle.\n", "The srt graphical parameter specifies text rotation in device-space, meaning the text will be rendered to follow the specified angle on the physical device, regardless of the aspect ratio of the underlying plot area.\n", "The correct way to do what you want is to (1) dynamically query for the data-space aspect ratio as measured in device-space distance units and (2) use it to transform theta from a data-space angle to a device-space angle.\n", "There are several mathematical approaches that could be taken here, but I think the simplest is to take the tan() of the angle to get the trigonometric y/x ratio, multiply it by the aspect ratio, and then convert back to an angle using atan2().\n", "Angles 0, 90, 180, and 270 are not affected, which makes sense; a change in aspect ratio should not affect those angles.\n", "A vertical elongation pulls angles towards the y-axis, and a horizontal elongation pulls angles towards the x-axis.\n", "Obviously the most important change is that I added a call to dataAngleToDevice() around theta, with the second argument passing calcAspectRatio().\n", "Additionally I used smaller (fontwise) but longer (stringwise) column names to more clearly demonstrate the angle of the text, I moved the text closer to the diagonal lines, I stored theta in radians from the beginning, and I reordered things a bit.\n", "The problem is caused because Mathematical angles are defined counter-clockwise from the x-direction, while your nautical course seems to be defined clockwise from the north-direction.\n", "The above code generates 15.4 degree and 29.6 degree as your angles.\n", "Alternatively, you can stay with angles:\n", "You can then convert this variable into the range of your angles.\n", "If you set angle to zero it will shoot raycast in forward direction of transform the script is attached to.\n", "Also take in mind in what unit your angle is?\n", "Mathf.Sin and Mathf.Cos take in angle value in radians, if you want use angles in degrees (0, 90, 180, 270) you need to convert them to radians before calculating Sin and Cos. To do this just multiply if with Rad/Deg value like this:\n", "Then the angle between v and w is the angle between vx+i*vy and wx+i*wy is the argument of w/v (as complex numbers) which is up to positive factors\n", "As previously said, the angles used are in radians, so you have to convert to degrees if desired.\n", "Can you calculate this directly from the angle and the edge strength?\n", "H, or hue, is the angle you are looking for.\n", "The function minAreaRect seems to give angles ranging from -90 to 0 degrees, not including zero, so an interval of [-90, 0).\n", "The function gives -90 degrees if the rectangle it outputs isn't rotated, i.e.\n", "the rectangle has two sides exactly horizontal and two sides exactly vertical.\n", "As the rectangle rotates clockwise, the angle increases (goes towards zero).\n", "When zero is reached, the angle given by the function ticks back over to -90 degrees again.\n", "So if you have a long rectangle from minAreaRect, and it's lying down flat, minAreaRect will call the angle -90 degrees.\n", "If you rotate the image until the rectangle given by minAreaRect is perfectly upright, then the angle will say -90 degrees again.\n", "This lets you easily see how the angle, and shape, of a manually drawn rectangle compares to the minAreaRect interpretation of the same rectangle.\n", "I wanted to have the angle between the longer side and vertical (to me it is the most natural way to think about rotated rectangles):\n", "After experiment, I find that if the long side is in the left of the bottom Point, the angle value is between long side and Y+ axis, but if the long side is in the right of the bottom Point, the angle value is between long side and X+ axis.\n", "The angle is from 0 to 180.\n", "After much experiment, I have found that the relationship between the rectangle orientation and output angle of minAreaRect().\n", "The following description assume that we have a rectangle with unequal height and width length, i.e., it is not square.\n", "If the rectangle lies vertically (width < height), then the detected angle is -90.\n", "If the rectangle lies horizontally, then the detected angle is also -90 degree.\n", "If the top part of the rectangle is in first quadrant, then the detected angle decreases as the rectangle rotate from horizontal to vertical position, until the detected angle becomes -90 degrees.\n", "In first quadrant, the width of detected rectangle is longer than its height.\n", "If the top part of the detected rectangle is in second quadrant, then the angle decreases as the rectangle rotate from vertical to horizontal position.\n", "If the rectangle approaches vertical position but has not been in vertical position, its angle approaches 0.\n", "If the rectangle approaches horizontal position but has not been in horizontal position, its angle approaches -90 degrees.\n", "This answer seems to cover the topic quite well:\n[Work out whether to turn clockwise or anticlockwise from two angles (hyper-link)]\n", "RE: angles that are less than 0 or greater than 360.\n", "So if you translate the incoming angle so that it lies between 0 and 360, all your problems are solved (presuming your code works for values between 0 & 360 as you suggest).\n", "Simply unwrap the angle.\n", "Then you'll always have angles from 0 to 360.\n", "Unwrap the starting angle and the target angle, then perform your turn.\n", "Here's a working example (the only method you really need is UnwrapAngle()).\n", "I found the answer: I have to normalize the Vectors in the AngleBetweenTwoVectors method.\n", "Then I get the real angle.\n", "The Math.asin() function returns the angle in radians.\n", "Use the atan2 function to get an angle in the full circle,\n", "Here is a function which takes minimum_rotated_rectangle polygon and calculates its azimuth (0-180) based on the longer edge.\n", "The cosine formula implementation looks right; did you take into account that acos() returns the angle in radians, not in degrees?\n", "In order to convert into degrees, multiply the angle by 180 and divide by Pi (3.14159...).\n", "The way I have done it is to calculate the two angles separately using atan2(y,x) then using this function.\n", "Here's a way that circumvents the law of cosines and instead calculates the angles of the two vectors.\n", "The difference between the angles is the searched value:\n", "Your answer gives the angle at the wrong point:\n", "To get the angle in green (which is probably angle you want based on your variable names \"first\", \"second\" and \"third), use:\n", "CGFloat angle = acos(((a*a)+(c*c)-(b*b))/((2*(a)*(c))));\n", "Using [this answer (hyper-link)] to compute angle of the vector:\n", "The Java atan2 function can be used to get the angle of the vector in radians.\n", "To get the angle relative to the up vector, going clockwise, pass the arguments to atan2 in the order x,y rather than y,x (which gives a result going anticlockwise from a right-pointing vector).\n", "Also note that angle is in radians.\n", "You're using the dot product of the two vectors to calculate the angle between them, but, since the dot product is commutative a.b = b.a - therefore, there is no way to get the sense of the angle, only its magnitude (as you've found out) - acos is ambiguous over 180\u00ba.\n", "You can get full-range angle (-Pi..Pi for the most of math libraries) using both scalar product and cross product:\n", "A more general approach to plot the angle between any pair of vectors would work as follows:\n", "This answer very similar to Roland's, but breaks things down into more steps and has some special-case handling when the angle is a multiple of pi/2.\n", "viewer.model.getData().metadata[\"custom values\"].angleToTrueNorth\n", "Here is the code to calculate the angle between two vectors (Explanation below code):\n", "We then call the method AngleBetweenTwoVectors and give it two parameters.\n", "If we would just give it the Vector of the Joints, we would not get the correct angle.\n", "We first have to substract the surrounding Vectors from the Vector (Vector we want to get the angle from).\n", "We then pass the two Vectors to the method AngleBetweenTwoVectors.\n", "With the dot-product we can calculate the angle.\n", "It seems I had to get the inverse angle, and apply the math to the rectangle's x and y, instead of the dot's.\n", "So take your dot product, divide by the magnitudes of each vector, and take the arccos to get your angle.\n", "I believe the method you're looking for is [Vector3.SignedAngle() (hyper-link)].\n", "My guess is that you've converted the angle to degrees but are treating it later as a radian angle when you do your drawing.\n", "Also, you are changing the 2D course vector into an angle, and then changing it back to a 2D course vector.\n", "The general formula for calculating the angle(bearing) between two points is as follows:\n", "Note that the angle(\u03b8) should be converted to radians before using this formula and \n\u0394long = long2 - long1.\n", "using [this (hyper-link)]  referance to calculate Angle:\n", "Based on Nayanesh Gupte's answer, here is a Python implementation of how to calculate the angle between two points defined by their latitudes and longitudes if anyone needs it:\n", "Where an angle of 0 degrees indicates a northward heading.\n", "Here's a sample on how to compute the angle (in degrees) between two points expressed in Lat/Lon.\n", "By using ComputeBearing you will easily get an angle expressed in degrees easily usable as heading\n", "After getting Latlng of 2 points, use sperical util to get angle\n", "SpericalValue is the angle.\n", "The second azimuth is at the second point, because the angle between the two points along a geodesic is not constant.\n", "These parameters are the same as GeodSolve, except that azi12 is a constant angle between the points.\n", "In The Javascript, I create a function name angleFromCoordinate in which i pass two lat/lng.\n", "First: You have to assume that the Kinect is your level of reference, if it is necessary to get the pans angle relative to the ground then make sure the Kinect is level with the ground.\n", "Third: Assuming you wish for horizontal angle find the highest and lowest grounds of data and average their depth from the camera.\n", "Fourth: Now you can essentially do the math for a triangle.\n", "Given you know the width of the pan(saves steps to know the objects size otherwise you have to estimate that too) you can solve for a triangle with sides a: distance to point 1, side b: distance to point 2, side c: size of pan and finding the angle of where points a and c or b and c meet will give you the horizontal angle of the pan relative to the Kinect.\n", "Fifth: For verification your measurements came back correct you can then use the angle you found to calculate the width of the pan given the angle and distance of the top and bottom most points.\n", "You can force the angle to be in the range of 0 to 360 by adding 360 and taking the remainder modulo 360.\n", "it seems you are trying to find angle between two lines.\n", "Angle is the difference between two slopes.\n", "Using triangle rules, instead of finding the angle at vertical, you can find the angle the line makes at X1, Y1 will the horizontal X line subtract it from 90.\n", "For your second angle, it is same but you don't need to subtract from 90.\n", "In most similar problems, the angle of the ray from (x1, y1) to (x2, y2) is wanted, but your problem is the other direction.\n", "Another difficulty is that you want the angle that goes clockwise from the negative y-axis, but standard trigonometry uses the angle that goes counterclockwise from the positive x-axis.\n", "The third difficulty is that the atan2 function sometimes returns negative angle values, but you want only positive values.\n", "You can use SensorEvent or Position Sensor for get rotation angle.\n", "minAreaRect prints -90 for both because it defines the rectangle differently for those lines (you can swap the width and height and end up with the same rectangle).\n", "If you need something that can distinguish between them then you can take the rectangle corners and find the longer side.\n", "You can use that line to calculate an angle.\n", "tan, sin, and cos are actually measuring the ratios between two edges of a 3-edged object aka a triangle.\n", "Hence in your case, to form that triangle, you will need the lengths of two edges.\n", "In fact, you have to ensure that the signs are correct too, else you will get a different angle as your answer.\n", "According to Wikipedia's article on inverse trigonometric functions (which includes the arctangent function), they are 'used to obtain an angle from any of the angle's trigonometric ratios' i.e.\n", "Your vector starts at (x1, y1) so subtracting those components from second point effectively centers the vector at (0, 0), then dividing the y-component by the x-component will give you the trigonometric ratio (aka gradient in this case) that can be passed through the arctan function to get the angle.\n", "To handle wrapping at the top end, you need to check again, adding another 360 to the angleOfTarget value:\n", "The reason is that the difference in angles is facingAngle - angleOfTarget although due to wrapping effects, might be off by 360 degrees.\n", "Then you can check the angle difference easily, whether it is within -45 to 45 degrees.\n", "You can use the dot product of two vectors to calculate the angle between them:\n", "If you take A as the facingAngle vector it will be [cos(fA), sin(fA)], and will have magnitude |A| of 1.\n", "It works correctly for any angles (can be outside of 0-360).\n", "Remember, it checks COUNTER-CLOCKWISE from angle A to angle B.\n", "It returns YES (true) if the angle is between :)\n", "First, a simple conversion function to make all angles 1-360\n", "Check if angle is between :)\n", "To check if the angle 300 is between 180 and 10 degrees:\n", "Restating Alnitak's answer in a different way, a solution that avoids the angle wrap at 360 degrees is to restate the problem in a different coordinate system where the angles are always small.\n", "Assuming the vectors |facing> = [cos(facing)  sin(facing)] and |target> = [cos(target) sin(target)], when projecting the target into the facing vector, the angle will range from zero, when the target is exactly at the facing vector or will increase to either side.\n", "The formula for the angle is the following:\n", "That is, the cosine of the angle is the dot product between the vectors |facing> and |target> divided their modules, which is 1 in this case, which becomes:\n", "This doesn't answer my question so much as it only works on objects reflecting of horizontal or vertical objects but this function will get you the angle of reflection based upon the rotation of the object which is being reflected...\n", "A multi-axis accelerometer measuring static acceleration (acceleration due to gravity) could be used to calculate the angle relative the earth.\n", "It is not really possible to get that \"elevation angle\" to the line of sight since you have no idea where the user is...\n", "With that assumption, you can use [http://developer.android.com/reference/android/hardware/SensorManager.html#getRotationMatrix(float[], float[], float[], float[]) (hyper-link)] to get the orientation of the device and get the angle between the y axis and the (x,z) plane.\n", "As you iterate through the list, keep track of how many overlapping itervals there are at the current point, and what the best angle you've seen so far has been (and how many intervals were overlapping at that angle).\n", "Once you reach the end, you know what the optimum angle is.\n", "If you need more than one angle, you can rather easily adapt this approach to remember intervals with maximal overlap, rather than single angles.\n", "(Pi is greater than 3.14159265359 but less than 3.14159265360; how do you say that an angle equals Pi/2 besides symbolically?)\n", "This also has a bonus of giving you not just one, but all of the angles that satisfy your condition.\n", "Return an arbitrary angle within the range.\n", "If you don't care to keep track of the actual number of intervals that contain a particular angle, just that it's the maximum, the bookkeeping for intervals that cross 0 (or 2\u03c0) is easier: just take the complement of the interval (reverse the start and end) and subtract one from the counts in step 5 instead of adding.\n", "In those cases, as I understand it, the angle at which they abut (\u03c0/3 or 0) should be counted as being in two intervals.\n", "The above algorithm could be tweaked so that when an interval start coincides with a range end point, a new (range, count) pair is inserted after the pair in question; the new pair would have a single-angle range (that is, range.start == range.end).\n", "If you are developing your program in C++, then to calculating an angle between two vectors you can use the atan2 function, it is present in many programming languages.\n", "Finally you subtract the values of the vectors and what you get is the angle.\n", "The angle will be either positive or negative, depending which atan2 value you subtract from which one.\n", "The result is the cosine of the angle between the two vectors.\n", "After an acos you have your angle.\n", "Just like 2D Vectors , you calculate their angle by solving cos of their Dot Product\n", "[image]\n\nYou don't need atan, you always go for the dot product since its a fundamental operation of vectors and then use acos to get the angle.\n", "OK, it might be I finally understood your comment below about the result being independent of the y angle, and about how it relates to the two vectors.\n", "It seems you are not really interested in two vectors and the angle between these two, but instead you're interested in the difference vector and the angle that one forms against the horizontal plane.\n", "In a [horizontal coordinate system (hyper-link)] (often used in astronomy), that angle would be called \u201caltitude\u201d or \u201celevation\u201d, as opposed to the \u201cazimuth\u201d you compute with the formula in your (edited) question.\n", "The fact that you use a different order for these two angles might be somewhat confusing, so think about whether this really is what you want, or whether you want to reverse the sign of the altitude or change the azimuth by 180\u00b0.\n", "For reference, I'll include my original answer below, for those who are actually looking for the angle of rotation around some fixed x axis, the way the original question suggested.\n", "If this x angle you mention in your question is indeed the angle of rotation around the x axis, as the camera example suggests, then you might want to think about it this way: set the x coordinate to zero, and you will end up with 2D vectors in the y-z plane.\n", "Personally I'd simply call atan2 twice, once for each vector, and subtract the resulting angles:\n", "Then it is possible to find angles as\n", "if you want to find an angle of swipe you have to use trigonometry here..\n", "tan(angle) = opposite / adjacent\n", "angle = arctan ( opposite / adjacent )\n", "Given I believe you want angle to horizontal you'll want\n", "To measure an angle you need three points or a base direction.\n", "[Math.Atan2(y, x) (hyper-link)] can be used to measure the angle to the x-axis.\n", "To find the angle formed by three points, you can use the [dot product (hyper-link)].\n", "I assume you want to find the angle theta between the lines created by points dot1, dot2 and dot3, where they're points that you've collected from the user.\n", "The angle between these two vectors as defined by the dot product is:\n", "This gives you the angle in degrees (remember that Math.Acos() returns the angle in radians).\n", "similar to In silico's answer, you can use a combination of a dot product and cross product to get the angle, and not just the undirected angle.\n", "where a and b are vectors run from the point you want to calculate the angle from to the corners of your picture boxes, respectively.\n", "Add a little noise to your estimation, and you can easily obtain an angle that is slightly less\nthan (more negative than) -pi radians.\n", "If you give wrapToPi an angle slightly less than -pi radians, it will return an angle\nthat is slightly less than pi radians instead.\n", "That is, as far as wrapToPi is concerned, there is not much difference between\nyour angles phi and theta.\n", "If you compute wrapToPi(phi - theta), which is what\nyou should do if you really want to know how different two directional angles are,\nthe result will be a relatively small number (something less than 0.02, I think).\n", "As you can see the first one, the small road seems to hit the main road in an angle, but this doesn't happen on the main road on Google Maps.\n", "You are able to calculate the inner angle, but you want the reversed angle?\n", "why not just calculating 360 - angle\n", "Now using angular cosine distance to calculate the angle between two vectors is quite good, but in your case it might be better to use arc tangent as mentioned in the comments.\n", "Now assuming you want to calculate the counterclockwise angle between BCD, you can do this by using the numpy's [atan2 (hyper-link)] function.\n", "atan2(x, y) will give the angle between the origin point y to x.\n", "Angle not labeled is the angle you refer to in the question.\n", "The point F is on the circle centered at A. I forgot to label the radius and angle.\n", "I also assume that you know the basics of vector math and that the problem is not finding the angle between lines or vectors, but rather solving to find the points C and D that is giving you troubles (hope so as this is going to be a long answer for me).\n", "As A is at the origin then  F is at F.x = cos(angle) * radius, F.y = sin(angle) * radius\n", "This forms the right triangle mBC and we know the length of BC === L and just calculated length of line Bm === b thus the length of the line mC is (L * L - b * b) ** 0.5\n", "In your question it is a little ambiguous to me which angles you want.\n", "So I will just give you a method to find the angle between to lines.\n", "The cross product of these vectors divided by the square root of the product of the squared lengths gives us the sin of the angle.\n", "Note this method will find the the smallest angle between the two lines and is invariant to the order of the lines\n", "Note the angle is in radians\n", "You can't compute angle between two points.\n", "But in case of \"angle we'd have to move in to go from point 1 to point 2\" it's\n", "Computing this angle is the very thing [Atan2 (hyper-link)] is designed for.\n", "The equation AngleNoCur + 180 * Math.PI / 180 isn't making much sense for me - you're adding 180 divided by 180 and multiplied by Pi...\n", "Actually I think you constantly wanted to work with radiants, because you converted the angle - whatever it is, we should ignore it - to radiants.\n", "Then your part with the fixedAngleOpposite should work, but you should alter the AngleNoCur:\n", "However, I'd still suggest using Modulo for fixedAngleOpposite and you can shorten your equation:\n", "For more information about degrees and radiants I'd suggest to read through this: [http://www.vcskicks.com/csharp_net_angles.php (hyper-link)].\n", "If you just want to display layer rotated by angle alpha (that is don't need any pseudo 3D perspective effects) you can set layer's transform:\n", "Note: one thing that helped me was always keeping angles between -pi and pi.\n", "First code in an [ATAN2 (hyper-link)]() function, to calculate the absolute angle for the point relative to horizontal plane.\n", "Then subtract the angle of the slope.\n", "The add the angle of the slope back to get your final angle\n", "The angle is 44.48384\u00b0, if you are measuring the angle around the origin (as you would expect, since \"angle between two vectors\").\n", "Maybe you have your definition of which angle you wish to calculate envisioned incorrectly as I'm struggling to see how these two points could form the angle of 90\u00b0.\n", "The test in function displayangle() whether angle a[i] is twice angle a[0] is numerically unstable.\n", "therefore to rotate the vector V = (x, y) pi an angle A you would do the following:\n", "If dp is negative, the angle is greater than 90 degrees.\n", "To find the angle, use arc-cosine.\n", "Consider two triangles: if one edge is connected, they share two vertices but each have one un-shared vertex.\n", "If the angle between m and n1 is greater than 90 [dotP(m,n1)<0] then the polygons face away from each other.\n", "If the angle is less than 90, the polygons are facing toward each other.\n", "If the angle is 90 degrees, then I think that the polygons are co-planar (or one of your chosen points is on the line of planar intersection or I've missed a case in my thinking).\n", "The angle between two vectors can be calculated with the [dot product (hyper-link)] or [atan2 (hyper-link)].\n", "See also [Finding Signed Angle Between Vectors (hyper-link)]\n", "Actually there is no way to find out the angle between point and origin due to the fact that the origin is (0,0).\n", "We can calculate the angle between 2 points beacuse they are treated like vectors and as such they have a direction, but the origin has no direction.\n", "For that reason, if you want to find the angle using the example of a clock you can calculate the angle between the point and (1,0) for example being that point at 0 degrees.\n", "Quote [the documentation for emissionAngle (hyper-link)]:\n", "The average initial direction of a particle, expressed as an angle in radians.\n", "Calculating angles is simple Trigonometry.\n", "The variable h return [1,1] if ANGLE is active or something like [1,10] with native GL.\n", "If your acceleration vector is a = (x, y, z), then the angles between this vector and the three axes are given by:\n", "cos (angleXaxis) = x / sqrt(x^2 + y^2 + z^2)\n", "cos (angleYaxis) = y / sqrt(x^2 + y^2 + z^2)\n", "cos (angleZaxis) = z / sqrt(x^2 + y^2 + z^2)\n", "To get the angles themselves you'll need to use the inverse cos function\n", "Angle can be calculated using the inverse tangent of the y/x ratio.\n", "On unity3d coordinated system (left-handed) you can get the angle by,\n", "Also, it seems the angle you're measuring is from the y-axis which is fine but will change the ultimate formula.\n", "Normally, the angle is measured from the x-axis and trigometric functions will assume that.\n", "Finally, if using Cartesian coordinates, holding y constant will not keep the angle constant (and from the system you described for x, the angle would be in the range from -90 to 90 - but exclusive of the end points).\n", "The arctangent function mentioned above assumes an angle measured from the x-axis.\n", "It would not change the angle, but it would be a visual hint of the z value.\n", "This page may be helpful: [http://www.mathopenref.com/trigprobslantangle.html (hyper-link)]\n", "With the angle in the (0...360] range\n", "slope=abs(tan(angle))*100\n", "So, you can map all angles into the first quadrant, 0 <= angle < 90, with:\n", "Now you have an angle 0 <= angle < 45 that's effectively the \"distance\" from the nearest quadrant boundary, and you can do:\n", "There is no angle between two points.\n", "If you want to know the angle between the vectors from the origin (0,0) to the objects, use the scalar (dot) product:\n", "The angles are unchanged when the plane is translated.)\n", "The vertex of the angle is the point (0,0).\n", "Say at frame n you estimate the parameters of the rotated rectangle A, and in frame n+1 you have the rectangle with the estimated parameters B.\n", "Instead of drawing the rectangle with B you find C which is between A and B, and then draw a rectangle with C in frame n+1.\n", "PCA, gives the angle and a first approximation for the rotatedRect's center\n", "And as your data is 2D, you can use the cv::fitEllipse function to fit an ellipse to your data and use the coordinates of the generated RotatedRect to calculate the angle.\n", "The angle that you are looking for is arctanjant not tanjant.\n", "Here's a source from unity that I used as well: [http://answers.unity3d.com/questions/181575/transformrotatearoundvector3-axis-float-angle-what.html (hyper-link)]\n", "It can be polar in that one number is an angle and the other is a distance, or cartesian that represent the vector as the amount of change in x and y.\n", "The angles start at the 3 o'clock point (pointing to the right of screen) as 0 radians or 0 deg then clockwise 90deg is at 6 o'clock 0.5 radian, and 180deg 1 radian at 6 o'clock and so on.\n", "Given points A, B, and C, you want the angle between AB and AC?\n", "This result is the cosine of the angle between the two vectors, so take the arccos() and you have it.\n", "theta = arccos((A dot B)/(length(A)*length(B)) is the angle between vectors A and B.\n", "The angle of vectors v1 and v2 is a  = acos(v1\u00b7v2/(|v1|*|v2|))\n", "This should be numerically robust unless one of the legs of the angle has zero length.\n", "Note that this will also give you a signed angle, depending on whether BAC goes clockwise or counterclockwise; the acos() method will always give you a positive value.\n", "Of course, if you want only a positive angle, you can take abs(angle); the atan2() method will still be more robust, and probably faster.\n", "Math.atan2, on the other hand, can use the xy values given to figure out what quadrant you're in and return the appropriate angle for any coordinates in all 4 quadrants.\n", "It's not proportional to the angle, but \"related\".\n", "and is equivilent to the product of the lengths of the two vectors times the cosine of the angle between them.\n", "And dot product of normalized vectors (which is the same as the cosine of angle between the vectors) would be\n", "It's a general framework for solving polar \u2194 rectangular problems with only add/subtract/bitshift + table, essentially doing rotation by angles of the form tan-1 (2-n).\n", "In your case, take one vector as a fixed reference, and copy the other to a temporary vector, which you rotate using the cordic angles towards the first vector (roughly bisection) until you reach a desired angular accuracy.\n", "Although if multiplies are cheap enough to allow using dot product, then don't bother with CORDIC, perhaps use a table of sin/cos pairs for rotation matrices of angles \u03c0/2n to solve the problem with bisection.)\n", "(edit: I like Eric Bainville's suggestion in the comments: rotate both vectors towards zero and keep track of the angle difference.)\n", "The cross product is proportional to the angle between two vectors, and when the vectors are normalized and the angle is small the cross product is very close to the actual angle in radians due to the small angle approximation.\n", "I1Q2-I2Q1 is proportional to the angle between I1Q1 and I2Q2.\n", "If you don't need the actual euclidean angle, but something that you can use as a base for angle comparisons, then changing to taxicab geometry may be a choice, because you can drop trigonometry and it's slowness while MAINTAINING THE ACCURACY (or at least with really minor loosing of accuracy, see below).\n", "Calculating diamond angle is average 5.01 times faster than atan2 and using inline code in Firefox 18 the speedup reaches factor 15.2.\n", "Speed comparison: [http://jsperf.com/diamond-angle-vs-atan2/2 (hyper-link)].\n", "The above code gives you angle between 0 and 4, while atan2 gives you angle between -PI and PI as the following table shows:\n", "Note that diamond angle is always positive and in the range of 0-4, while atan2 gives also negative radians.\n", "So diamond angle is sort of more normalized.\n", "And another note is that atan2 gives a little more precise result, because the range length is 2*pi (ie 6.283185307179586), while in diamond angles it is 4.\n", "rad 2.3000000000000001 and 2.3000000000000002 are both in diamond angles 1.4718731421442295, but if we lower the precision by dropping one zero, rad 2.300000000000001 and 2.300000000000002 gives both different diamond angle.\n", "This \"precision loosing\" in diamond angles is so small, that it has some significant influence only if the distances are huge.\n", "The above code is enough for fast angle comparisons, but in many cases there is need to convert diamond angle to radians and vice verca.\n", "have some tolerance as radian angles, and then you have a 100,000 times loop where this tolerance is compared to other angles, it's not wise to make comparisons using atan2.\n", "Instead, before looping, you change the radian tolerance to taxicab (diamond angles) tolerance and make in-loop comparisons using diamond tolerance and this way you don't have to use slow trigonometric functions in speed-critical parts of the code ( = in loops).\n", "And if for some reason, you have to convert diamond angle to radians, eg.\n", "after looping and making angle comparisons to return eg.\n", "the minimum angle of comparisons or whatever as radians, the code is as follows:\n", "You cannot convert diamond angle to radians by simply multiplying by some factor, but instead finding a point in taxicab geometry of which diamond angle between that point and the positive X axis is the diamond angle in question and converting this point to radians using atan2.\n", "This should be enough for fast angle comparisons.\n", "Finally I found a page in [http://www.freesteel.co.uk/wpblog/2009/06/encoding-2d-angles-without-trigonometry/ (hyper-link)] which had the desired functions and principles.\n", "I realized that contrary to euclidean distances, the angle between start and end point has affect to the taxicab distance.\n", "Only lengths of vertical and horizontal vectors can be converted easily and fast between euclidean and taxicab, but in every other case you have to take the angle into account and then the process is too slow (?\n", "So as a conclusion I am thinking that in speed critical applications where is a loop or recursion of several comparisons of angles and/or distances, angles are faster to compare in taxicab space and distances in euclidean (squared, without using sqrt) space.\n", "Here on SO I still don't have the privilege to comment (though I have at math.se) so this is actually a reply to Timo's post on diamond angles.\n", "The whole concept of diamond angles based on the L1 norm is most interesting and if it were merely a comparison of which vector has a greater/lesser w.r.t.\n", "However, the OP did mention angle between two generic vectors, and I presume the OP wants to compare it to some tolerance for finding smoothness/corner status or sth like that, but unfortunately, it seems that with only the formulae provided on jsperf.com or freesteel.co.uk (links above) it seems it is not possible to do this using diamond angles.\n", "You can use [Vector.AngleBetween Method (hyper-link)] to get the angle\n", "you may have to change the value multiplying PI also to give a better spread of possible angles (reduce it)\n", "Then the output angle is directly opposite the incident.\n", "When we calculate angles in other solutions, we may have some errors in floating point calculations.\n", "You could also let [Vector.AngleBetween (hyper-link)] do the calculation:\n", "Use the inner-product (dot product) of the vectors describing the lines to get the inner angle and subtract from 360 degrees?\n", "where v and w are vectors and theta is the angle between the lines.\n", "The angle returned from inverting the dot-product will always be less than 180 degrees, so it is always the inner angle.\n", "If you need the angle there is no way around normalizing the vectors and do a dot or cross-product.\n", "You often have a choice if you want to calculate the angle via asin, acos or atan but in the end that does not make a difference to execution speed.\n", "If we have a better picture of what you're doing we might be able to give you some hints how to solve the problem without calculating the angle at the first place.\n", "Euler-angles are rarely needed.\n", "Why not calculate the delta as the minimum of the angle between the current angle and the desired angle and the delta you'd like to move?\n", "That way the last step moves you to exactly the desired angle.\n", "I would also change your code so that SetRotation does nothing but store the two values desiredRotation and speed and then the calculation in Update can compare the desired angle with the current angle, calculate the difference, limit that to the speed value x the number of seconds and then move by that amount (with the appropriate if statement for the direction +ve or -ve).\n", "All I needed was some trigonometry to find the smallest angle between the angles.\n", "See the two angles as vectors pointing out from origo (or rather two vectors with the angles between them and the x-axis), the smallest angle is pretty simple to find then.\n", "That will give me the smallest angle.\n", "Finding out when to stop rotating is just a matter of seeing if the rotated distance is larger than the smallest distance/angle between the two angles.\n", "It calculates angle between v1 and v2 as below image\n", "Assuming you want to calculate the angle between the two points relative to the origin of the 2D plane, you can use the dot product to calculate the angle between the points (like how the other [answer (hyper-link)] of this question described).\n", "It can be used for calculating the angle between 3D points as well.\n", "Note that angle is in [Radians (hyper-link)].\n", "Also make sure you don't use the squared delta for the angle.\n", "If you know that angle A is 35 degrees then angle B just needs to be 35 + 90.\n", "Allowing for \"wrap-around\" past 360 degrees for cases where angle A is greater than 270 degrees you can do this:\n", "You can calculate the projection angle to any plane by:\n", "Calculating the angle to the normal by a = acos(dot(d, n))\n", "Finally obtaining the angle to the plane by taking b = 90 - a (assuming units in degrees - NB most math library functions use radians)\n", "Special case: if dot(d, n) < 0, then the angle a will be greater than 90 degrees.\n", "In this case if you only want the acute angle, do b = a - 90 instead of 90 - a.\n", "To calculate the angle to the xy plane, use n = (0, 0, 1), i.e.\n", "is already the cosine of the desired angle, so you should write\n", "to get the angle in radians.\n", "Do not animate the rotation, instead animate a property of an object and bind the rotation angle to it.\n", "When it is negative (0,0,-1), the angles must be treated as CCW instead of CW (and vice-versa)\n", "You can compute the angle between the two vectors as following: first, get the two vectors v1 and v2 and then use np.arccos() which returns the angle in radians.\n", "The formulae for computing angle between two vectors can be found on this [Wiki link (hyper-link)]\n", "You can try to calculate the angle, but an easier way could be to check whether the Pythagorean Theorem applies.\n", "Rather than an exact comparison to 90\u00b0 (or 0\u00b0 in case of dot product), it is wiser to check for a small angle difference to 90\u00b0 (resp.\n", "Compute the cross-product of the sides of the angle and their squared lengths, and compare\nwith a precomputed tolerance:\n", "with \u03b1 = cos\u00b2\u03b4 where \u03b4 is the angle tolerance.\n", "You said, you want the angle to increase in clockwise direction.\n", "Rotating this line P1 -------- P2 such that P1 is above P2, the angle must thus be 90\u00b0.\n", "If, however, we rotated in the opposite direction, P1 would be below P2 and the angle is -90\u00b0 or 270\u00b0.\n", "Basis: Considering P1 to be the origin and measuring the angle of P2 relative to the origin, then P1 -------- P2 will correctly yield 0.\n", "However, atan2 let's the angle increase in CCW direction.\n", "The angle we want to find is \u03b1.\n", "We know that the hypotenuse of the triangle with d1 and d3 is R + ha, which is just the radius of the Earth plus the elevation of object A.\n", "We know that the total length of the base of the entire triangle is R + hb; essentially just the radius of the Earth plus the height of object B.\n", "First we use a function to get step values for x and y based on the angle (in radians):\n", "If you just want to draw a line at a certain angle you can do the following instead:\n", "If i guess right, i think you want the mouse act like a baseball bat, and you need to measure the current mouse angle, that is to store previous mouse position and do some math.\n", "That's what atan2 and angle do: They check for the sign of each component separately, and then determine if +/- pi should be added to the result of atan.\n", "You can use modulus to get all the angles in the range 0 - 360.\n", "then phi is not the angle of the point (x,y).\n", "This calls the inverse tangent function to find an angle based on the lengths of the opposite and adjacent sides of a right angled triangle.\n", "Otherwise you can cause an exception because the tan function breaks down if the angle is 90 or 0 degrees.\n", "This function finds the absolute value of the difference between the coordinates (so the length of the opposite and adjacent sides of the right-angled triangle formed from the two points) and then performs the inverse tan function on them, finding the angle.\n", "Here is a demo showing inside angles where you can drag the corner points:\n", "Here is a demo showing outside angles where you can drag the corner points:\n", "If you want to draw an angle-symbol on an inside angle you can call this function by supplying corner (vertex) points in counter-clockwise order: point3, point2, point1:\n", "If you want to draw an angle-symbol on an outside angle you can call this same function and supplying corner points in clockwise order: point1, point2, point3:\n", "As I mentioned in the previous answer, the ideal solution for this value is to calculate an \"average\" between the two angles so the angle is in the middle of the arc.\n", "To calculate the angle to the horizontal we need a third point.\n", "If the vertice of our angle is p1 this new point will have the same y coordinate as p1 but right below or above p2.\n", "To calculate the angle we need the normalised vectors from the vertice (p1) to each of the points (p2 and p2Hor) and their dot product.\n", "The angle (in radians) is:\n", "The shift in x coordinate is L*cos(a) and shift in y coordinate is L*sin(a), where a is the angle (\"direction given\") and L is 10 px in your case.\n", "They are working for angles between 0 and 45 degrees only.\n", "X = length * sin(angle) + xLocation\n", "Y = length * cos(angle) + yLocation\n", "In Java (I assume you are using Java for Android) you would do the following to find the angle:\n", "In quadrant 2, arcsin is between 90 and 0, the real angle is between 90 and 180.\n", "So if you are in quadrant 2, 180-calculated angle=real angle.\n", "The real angle is between 180 and 270. so again, 180-calculated angle = real angle.\n", "The real angle is between 270 and 360.\n", "So 360+calculated angle=real angle.\n", "Math.atan gives an angle between -1/2 pi and 1/2 pi, that is, the right half circle.\n", "Then we get an angle between -1/2 pi and 3/2 pi.\n", "So, in case it's negative, we sum 2 pi in order to obtain an angle between 0 and 2 pi.\n", "The case where both coordinates are (0, 0) is left undefined (all angles are equivalent when the magnitude of a vector is zero), so I'm arbitrarily setting the angle to zero degrees in that case.\n", "The result will be an angle defined for all cases and within the range [0, 360\u00b0), as desired.\n", "Some quick googling reveals the definition of the aspect angle.\n", "[http://www.answers.com/topic/aspect-angle (hyper-link)]\n", "It's the angle between the geographic north on the northern hemisphere and the geographic south on the southern hemisphere.\n", "Now it's easy to measure the aspect angle of the plane - It's the angle between the \"pole\"-plane N and the projected plane normal P given by acos(P dot N).\n", "The aspect angle is then the angle between (a,b) and (0,1).\n", "Note that planes parallell with the ground plane does not have a well-defined aspect angle since there is no slope to measure the aspect angle from.\n", "Essentially you would do some inverse trig on the readings of the three accelerometers, to figure out the angle of \"gravity\" from its vector components in the three measured axis.\n", "Then extract the quaternion, (or Euler angles, if you would prefer), using say [http://www.cg.info.hiroshima-cu.ac.jp/~miyazaki/knowledge/teche52.html (hyper-link)]\n", "Surely you could adapt any solution with negative angles to always be 0-360 by adjusting:\n", "float positive = (angle < 0) ?\n", "(360 + angle) : angle\n", "For turning any angle into a 0-359 range in C#, you can use the following \"algorithm\":\n", "To have an angle, you have to store the previous location of the mouse and consider the current angle as the angle between last measure and current.\n", "The computation of the angle is done with a classical atan2.\n", "I whipped up the example here as you can see image output along the way as well:\n[http://nbviewer.ipython.org/github/xamox/sandbox/blob/master/gas-gauge-angle/Gauge%20Angle.ipynb (hyper-link)]\n", "If you want angles then just use [SensorManager.getOrientation() (hyper-link)] from the API.\n", "Do not use yaw, pitch and roll for arbitrary orientations, [Euler angles are evil (hyper-link)].\n", "Use dot products and norms:  dot(V1,V2) = magnitude(V1)*magnitude(V2)*cos(a) where a is the angle by which V2 deviates from the direction of V1.\n", "EDIT: I had to remove first/last angles from the function, something I was doing after the fact with this function elsewhere.\n", "Also, the packages adehabitatLT and argosfilter contain functions to calculate track directions and angles.\n", "You can think of your angle as the hypotenuse of a right triangle.\n", "Just solved this one, all i needed to do was use the modulus operator to get the rotation relative to its original position rather than the total rotated angle.\n", "to get the angle of the line you can pretty easily do it with a simple math\n", "Honestly, I think you are over-complicating it by using angles.\n", "I agree with Andy's answer; you really only need a normalized vector between the two points, instead of an angle.\n", "But if you need an angle, you just form the vector between the two points, and then use [Math.atan2 (hyper-link)]:\n", "You don't need to derive the vector from the angle that you derived from the vector.\n", "I think the problem is that you evaluate the angle in the wrong way.\n", "If I understand correctly what are you trying to achieve, then you need the angle between 2 green lines.\n", "So you can evaluate cos(theta) - the cosine of angle between 2 green lines - like this:\n", "The stated answers are correct for real numbers but can loose accuracy near certain angles when computed with floating point numbers.\n", "For arcos() when the angle is near zero or PI, and for arcsin() near pi/2 and \u2013pi/2, as many a half the significant figures can be lost.\n", "Note, this gives the unoriented angle between the two vectors.\n", "If you're looking for the nearest neighbour, do you actually need the angle?\n", "Set the X co-ordinate value as the product of the r value, the sum of the product of the ct with the cosine value of the angle:\nx = (r) * ( ( (ct) * (cos(angle) ) ) + ( ) )\n", "Set the X co-ordinate value as the product of the r value, the sum of the product of the ct with the cosine value of the angle with the sum of the product st with the Sin value of the angle:\nx = (r) * ( ( (ct) * (cos(angle) ) ) + ( (st) * (sin(angle) ) ) )\n", "Removing unnecessary parentheses:\nx = r * (ct * cos(angle) + st * sin(angle));\n", "angle, however, will always come back in radians.\n", "That means you have to convert you angles before calling Math.cos and Math.sin:\n", "There are actually a few different ways you can calculate an angle between two vectors in 3D space.\n", "Using the typical acos function is common, but has large precision issues when the slope is near +/- 1.0, so it best to compute using angle bisectors.\n", "Even light precision errors with the cross-product cause even larger errors with the angle using acos, so after some research, I found this method is always consistent.\n", "The dot product of two vectors relates to the cosine of the angle between them.\n", "The cross product of two vectors relates to the sine of the angle between them.\n", "I know that Velocity.X = SpeedCos(Angle) and Velocity.Y = SpeedSin(Angle), but I needed to find the value of Angle.\n", "To do this, my line of thinking was to make a right triangle based off the starting position and the destination, then find Angle using trig.\n", "This code was making a right triangle.\n", "After making a right triangle, it takes the adj and hypo to obtain cos(adj/hypo), which I then call Acos on to give me the angle in radians.\n", "This didn't work however, it did not properly return my angle and created a lot of NaN errors.\n", "It made me realize that if I just translated the line startingPoint, endPoint to startingPoint = 0 I could call atan2 and be returned my desired angle.\n", "axesDefaults : {\n            tickRenderer :$.jqplot.CanvasAxisTickRenderer,\n            tickOptions : {\n                angle :30\n            }\n        },\n", "You use a dot product of vectors OA and OC divided by their magnitude to calculate cosine of the angle and then use acos() function to find the angle.\n", "You can find angle between vectors OA and OC through their scalar product and cross product:\n", "Example: O = (0,0), A = (-1, 0), C = (-2, 1)\n  SP = 2, CP = -1, Angle = -0.463\n", "Anyway you should use the cosine rule c^2 = a^2 + b^2 - 2ab cos(C) (where a,b,c are the lengths of the sides of the triangle, and C is the angle subtending c):\n", "If the following angle is convex, the third point must lie in this half space.\n", "If that's not the case, the angle is concave (which you apparently call reflex):\n", "The circularity of angles is not a major obstacle: to instead an interval like [270, 45) that wraps around, instead insert two intervals [270, 360), [0, 45).\n", "What might work better would be to find the angle between AB and BC, via the dot product.\n", "That will produce the correct angle even in the collinear case.\n", "You could use that the angle bisector remains the same if you rotate BA by +90\u00b0 and BC by -90\u00b0.\n", "If you try this out you will note that the jump in direction of the bisector now occurs for the angle -90\u00b0 between the vectors.\n", "Get the angle from the positive X axis to A' as angle_a = arctan(A_y, A_x).\n", "Get the angle from the positive X axis to C' as angle_c = arctan(C_y, C_x).\n", "Get the counter-clockwise angle from A' to C' as angle_ac = angle_c - angle_a.\n", "Get the angle from the positive X axis to M' as angle_m = angle_ac/2 + angle_a.\n", "Construct M' from this angle as M' = (cos(angle_m), sin(angle_m)).\n", "The vector BM bisects the angle ABC.\n", "When the dot product is negative, you have obtuse angle between input vectors.\n", "When the angle between a and b is greater than 90\u00b0, the angle between a and -b is less than 90\u00b0, and the length of a_norm - b_norm is large enough to give accurate direction.\n", "To get angle sequence (in degrees) like 90-45-0-45-90-45..., you can use this simple algo (pseudocode):\n", "hence we can find the angle using the above information\n", "I realize that an answer was already accepted for this, but from a \"strictly *nix purist angle\" it seems like the right tool for the job is pcregrep, which doesn't seem to have been mentioned yet.\n", "Finding the angle between v1 and v2 gives you this angle, which doesn't match what you mark in your diagram:\n", "Instead, solve for the angle between v1 and the plane normal to v2:\n", "We can do this in unity by projecting v1 to the plane normal to v2 using [Vector3.ProjectOnPlane (hyper-link)], and then finding the angle between that projection and v1 using [Vector3.Angle (hyper-link)]:\n", "Basically you want to check which angle gives you the smallest [arc (hyper-link)] length (L).\n", "Normalize the angles between 0 and 360 degrees, and take whichever is smaller:\n", "Where r is the radius, cx,cy the origin, and a the angle.\n", "Note that most languages will use [radians (hyper-link)] for the angle in trig functions, so rather than cycling through 0..360 degrees, you're cycling through 0..2PI radians.\n", "Let BC be the length of the corresponding segment, theta be the angle in radians.\n", "5 links), you may have more than two solutions, and of course more angles, so you'd have to adapt the code above.\n", "All angles refer to your figure.\n", "Get the angle from our Particle.\n", "you are obtaining E angle from ellipse via E=atan2(...)\n", "and using it in equation where you need Mangle x=x0+rx*cos(M), y=...\n", "M is mean circular angle\n", "and E is ellipse angle\n", "In order to obtain the M angle\n", "and compute the angle there\n", "Math.Cos and Math.Sin take the angle in radians as opposed to degrees, your code should be:\n", "Once you launch a ball at an angle, say 50 degrees, add (cos(50)*speed) to his X position, and (sin(50)*speed) to his Y position.\n", "When you detect the ball's y position has reached the surface's y position, just change the angle to -50.\n", "But you must know that it only works if you want a reflection angle on a top surface, where it hits the top surface and bounces down.\n", "You pass in deltaX and deltaY from the center point to point 1 to get the first angle.\n", "Then repeat on the second point to get the second angle, then take the difference in angles.\n", "That's the angle of the arc.\n", "I have a project on Github called [TrochoidDemo (hyper-link)] that includes a one-finger tap gesture recognizer using this same math (for the gesture recognizer I calculate the change in angle from the starting point of your finger to the point you drag to.)\n", "the atan2 method permit to calculate the angle between a segment of your choice and the horizontal axis, so if you put some absolute value, it might works as is.\n", "otherwise you can use the Point2D method vector1.angle(vector2) which gives you the angle between both vector\n\ngiving you\n", "[getAngle(point) (hyper-link)], [getAngleInRadians(point) (hyper-link)] and [getDirectedAngle(point) (hyper-link)] all consider the given points as vectors.\n", "The result is in degree except for getAngleInRadians().\n", "In this case, if theta is the angle of rotation, then\n", "I went ahead and created a quick jQuery method that attempts to calculate the angle of rotation of a given HTML element.\n", "3: calc angle\n", "As far as I know, LeapDroid and BlueStacks are the only two using ANGLE so far.\n", "So you need to multiply the angle by 180/pi to get it back to degrees.\n", "Whereas atan will give the same answer for points on the opposite side of the circle, atan2 will give you the correct angle, taking into account the signs of both dx and dy.\n", "Just swap the start and end angles:\n", "Try to use Vector3.Angle(targetDir, forward);\n", "Since you want the shortest angle between them, then if the value returned is more than 180 degrees, just subtract 360 degrees with this value.\n", "Check out [http://answers.unity3d.com/questions/317648/angle-between-two-vectors.html (hyper-link)]\n", "a and b are the vectors for which you want to calculate an angle, n would be the normal of your plane to determine what you would call \"clockwise/counterclockwise\"\n", "For simplicity I reuse Vector3.Angle and then calculate the sign from the magnitude of the angle between plane normal n and the cross product (perpendicular vector) of a and b.\n", "Here's what i mean:\nif we are clockwise and the angle is negative, e.g.\n", "\"180-|angle|+180\"\nyou already know that the angle is negative, so, use \"180-(-angle)+180\" and add the 180's \"360 + angle\".\n", "Then if it's clockwise, CONTINUE but if it's counter clockwise, make the angle negative, this is because the other part of  the 360 angle (which is the compliment of 360 + angle) is \"360 - (360 + angle)\" or\n\"360 - 360 - angle\" OR \"(360 - 360) - angle\" and, again, OR \"- angle\".\n", "So there we go... your finished angle.\n", "I can suggest you more than a triangle.\n", "So though the other answer provides a great bunch of platforms to make triangle angles based on user input, I still felt obligated to work on this and make a workaround that didn't include all the additional graphs.\n", "Edit: This Pen is if you want the angle to be as in my original image: [http://codepen.io/anon/pen/sjIpx (hyper-link)]\n", "which means that programs can either use the installed (desktop) OpenGL driver, DirectX (via ANGLE), or an OpenGL emulation in software (Mesa) as OpenGL backends.\n", "Take the two locations, figure out the right triangle that has the two locations as  the acute angles, and compute.\n", "One thing -- if the locations are very far apart, you'll want to use spherical trig or the angles will be inaccurate.\n", "Well, there was a link ... [http://www.easycalculation.com/trigonometry/triangle-angles.php (hyper-link)]\n", "[How do I calculate the Azimuth (angle to north) between two WGS84 coordinates (hyper-link)]\n", "using [this (hyper-link)]  referance to calculate Angle as follows:\n", "and then rotate ImageView to this angle\n", "since angle returned by Math.Acos is in radian and to convert it into degrees you should be multiplying it to 180/pi\n", "Because you only want the angle between the initial and current position, it's actually no math involved, only a simple check to see which value is the greatest.\n", "Swapping the order of the arguments means that instead of the (counter-clockwise) angle with the X-axis you get the (clockwise) angle with the Y-axis.\n", "and this will return the counter-clock wise angle with respect to X- axis.\n", "If you interchange those two you will get the clock wise angle with respect to X- axis.\n", "In Cartesian coordinate system we consider counter-clock wise angle with respect to X-axis.\n", "The angle/numSections calculation MUST be in float AND that round MUST be round to integer; the kind of round that gives 1 for 1.4 and 2 for 1.6.\n", "As Jacob already pointed out in the comment the section can be found from round(angle/45) & the floor angle can be found from 45*(round(angle/45)).\n", "Conceptually, obtaining the angle between two vectors using the dot product is perfectly alright.\n", "However, since the angle between two vectors is invariant upon translation/rotation of the coordinate system, we can find the angle subtended by each vector to the positive direction of the x-axis and subtract one value from the other.\n", "The advantage is, we'll use np.arctan2to find the angles, which returns angles in the range [-\u03c0,\u03c0] and hence you get an idea of the quadrant your vector lies in.\n", "Taking from: [https://math.stackexchange.com/questions/180874/convert-angle-radians-to-a-heading-vector (hyper-link)] by [user61133 (hyper-link)]\n", "If you have an angle (A), in radians, in the range -Pi to Pi, then convert it to a vector (V) with:\n", "Below is the link that will show you how to find the angle bewteen two vectors:\n", "[http://www.wikihow.com/Find-the-Angle-Between-Two-Vectors (hyper-link)]\n", "I'm not sure what you mean by angle, since you only give one vector in your example.\n", "But, given two vectors, you can find the angle between them like so:\n", "Then, dot(a,  b) = cos(\u03b8), where \u03b8 is the angle between the two vectors.\n", "Presuming that you want to find the angle of the vector against the X axis (in JavaScript):\n", "where double angle trigonometric identities where used to simplify using\n", "Subracting every angle from 360 it draws line correctly towards clockwise direction and my requirement is achieved.\n", "The sine of the angle between the two vectors equals the magnitude of the cross product divided by the magnitudes of the two vectors:\n", "You can get the angle up to sign using the [dot product (hyper-link)].\n", "To get the sign of the angle, take the sign of Vn * (Va x Vb).\n", "Let theta be the angle between the vectors.\n", "Determine the angle between the two vectors\ntheta = acos(dot product of Va, Vb).\n", "This will give the minimum angle between the two vectors\n", "Determine the sign of the angle\nFind vector V3 = cross product of Va, Vb.\n", "Suppose Vx is the x-axis, given the normal Vn, you can get the y-axis by cross product, you can project the vector Vb to Vx and Vy (by the dot product you can get the length of the projection of Vb onto Vx and Vy), given the (x, y) coordinate on the plane, you can use atan2(y, x) to get the angle in the range [-pi, +pi]\n", "Assuming that the plane normal is normalized (|Vn| == 1), the signed angle is simply:\n", "which returns an angle in the range [-PI, +PI] (or whatever the available atan2 implementation returns).\n", "Explanation for why this works: let alpha be the direct angle between the vectors (0\u00b0 to 180\u00b0) and beta the angle we are looking for (0\u00b0 to 360\u00b0) with beta == alpha or beta == 360\u00b0 - alpha\n", "This is the Matlab code to compute the signed angle between two vectors u,v either in 2D or in 3D.\n", "For that reason, it might give you an angle pointing the opposite direction.\n", "The way around this is to use Math.atan2, which adjusts the angle according to the sign as necessary.\n", "This will give you the angle in radians:\n", "You will probably want to ignore angles for which dx or dy is less than a certain number (something like 16 would do it).\n", "[https://math.stackexchange.com/questions/974178/how-to-calculate-the-angle-between-2-vectors-in-3d-space-given-a-preset-function (hyper-link)]\n", "Just calculate the angle based on the direction vector.\n", "And calculate the angle:\n", "I'm not sure about setting a base angle, but you could subtract 45\u00b0 from your measurements of the accelerometer in your program, which would have the same effect.\n", "You don't say what the angle is measured relative to, or indeed what direction your axes go.\n", "Then you need to take the sine and the cosine of your angle and multiply these by the length of the line.\n", "You now have two numbers for your coordinates, but it depends what directions your axes go and from where you're measuring your angles which of these values is the x coordinate and which is the y, and whether either of them needs to be negated.\n", "Because law of cosine is only going to return an interior angle of 180 degrees or less.\n", "Law of Cosines blows up when your triangle in degenerate.\n", "It seems like your function AngleBetweenThreePoints is only ever returning an angle between 0 and Pi which is then being passed on.\n", "Looking at the angle between two lines will give a strange value for quadrant (quadrant relative to the first line) - is this what you want?\n", "As others have mentioned, what you are doing gets the inner angle which is always less than 180 degrees.\n", "I am assuming you want the quadrant as measured by the counter clockwise angle from one vector to the other.\n", "This works because dot product equals |A|*|B|*cos(theta) where || means magnitude and theta is the angle between A and B.\n", "Lets say we are measuring theta as the counter clockwise angle from A to B.\n", "With {x1,y1} = first point - center point, and {x2,y2} = third point - center point, the signed angle (-pi,+pi) is given by:\n", "Depending on your definition of the sign of the angle you may or may not want to add a minus in front.\n", "You are calculating the inner angle which is always less than 180 degrees.\n", "Here is a quick and correct way of calculating the right angle value:\n", "gives you an angle alpha.\n", "Lets say you want to calculate your new coordinates r pixels away from the point (X,Y) for an angle a.\n", "Been busting my brains trying to implement ear clipping for a few days and got it wrong at this point - the solution was the basic \"check if the center point of the triangle was outside the polygon and mark it as reflex\".\n", "Finding the angle between the mouse and sprite and applying it the way you are, will always face that direction.\n", "and output (the expected angle).\n", "What does Angle360 do?\n", "I guess you understand what it is supposed to do, but I think it is really two functions \n\nGet the angle between the two vectors (current direction and target direction)\nRotate map (or something like that)\n", "You're just using some library angle difference function - is it behaving as you expect?\n", "Why is it Vector3.Angle(right, to), and why not Vector3.Angle(to, right)?\n", "x1, y1 = starting position of line\nangleInRadians = angle on the line converted to Radians\n", "Then, when trying to figure out why this would be giving the values it is, i recalled something else - angle needs to be in radians.\n", "As your logic stands, you are never getting into your print(\"acute angle\") scenario for a valid triangle.\n", "Because a triangle can't be acute and obtuse at the same time.\n", "If at least one angle is 90; then it can't be an acute or obtuse\ntriangle\n", "If all sides are less than 90; then it can't be an obtuse triangle\n", "You did not have to use atan to get the angle and then calc sin/cos.\n", "which gives you the slope as a single number, where 1 represents the line which passes through the origin at a +45deg angle.\n", "A little fiddling around will turn the slope into the angle, be careful when the line is vertical, ie where the denominator of the ratio is 0.\n", "So a (representative) of a vector is a directed segment and by definition the angle between two vectors is the one formed when going counter-clockwise from the first vector to the second.\n", "In your case this angle is 2*pi- alpha.\n", "In this case, the angle would be 45\u00b0.\n", "To specify a different angle, first calculate cos(\u03b1) and sin(\u03b1).\n", "The cosinus specifies how far you have to go right, and the sinus how far to go up, to make a distance of 1 pixel in the specified angle.\n", "90 degree angle was moving div down instead of up.\n", "I would use the angle as object and degree and radian as different getter setter for the same internal angle value.\n", "As far as using your class is concerned, all that matters is that you get an angle - whether it was in degrees or radians to start with is irrelevant.\n", "If you want convenience methods to create angles from common units, they could be just that: helper methods.\n", "You should never write a Sin function that checks what kind of angle it was given, and does a different calculation.\n", "The point is not that you can have an \"abstract\" angle (which I don't believe is a useful concept), the point is to avoid ever confusing degrees with radians and to make the conversion between the two implicit.\n", "Having a abstract base Angle class increases syntactic noise (you need to use references everywhere) and will probably decrease performance.\n", "This solution also allows you to store your angles in your desired units, instead of hoping that you're getting the \"fast path.\"\n", "So the only problem you've got to solve is how to make constructing Angle objects in a readable way.\n", "Here's a function to give you the degree-angle of lines [x1,y1,x2,y2] and [x2,y2,x3,y3] assuming a clockwise sweep.\n", "A rotation angle is uniquely determined only up to multiples of 360 degrees (or 2*\u03c0 radians), for example -90 and 270 degrees describe exactly the same rotation.\n", "gives the rotation of the image view at a particular point in time, and that rotation \ncan be described using an angle between 0 and 2*\u03c0 (as you expect) or using an angle\nbetween -\u03c0 and \u03c0 (which is what actually happens).\n", "To normalize an arbitrary angle into the range 0 <= degrees < 360\nyou can do\n", "A div is always a rectangle.\n", "In general, from the 0 angle, the compass' angle should be something like\n", "You can use this function to normalize an angle:\n", "If anticlockwise is false and endAngle-startAngle is equal to or greater than 2\u03c0, or, if anticlockwise is true and startAngle-endAngle is equal to or greater than 2\u03c0, then the arc is the whole circumference of this ellipse, and the point at startAngle along this circle's circumference, measured in radians clockwise from the ellipse's semi-major axis, acts as both the start point and the end point.\n", "Otherwise, the points at startAngle and endAngle along this circle's circumference, measured in radians clockwise from the ellipse's semi-major axis, are the start and end points respectively, and the arc is the path along the circumference of this ellipse from the start point to the end point, going anti-clockwise if anticlockwise is true, and clockwise otherwise.\n", "Since the points are on the ellipse, as opposed to being simply angles from zero, the arc can never cover an angle greater than 2\u03c0 radians.\n", "In your case, startAngle = 0, endAngle = 3\u03c0, anticlowkwise = true, if we run the above algorithm, we end up in the else case (0 - 3\u03c0 < 2\u03c0) and endAngle is now (3\u03c0 % 2\u03c0 = 1\u03c0).\n", "We could achieve the same output without the anticlockwise flag by swapping startAngle and endAngle:\n", "How can I find the angle between start and end points of draw line?\"\n", "Given 2 points p1 and p2 you may calculate the angle between start and end points of the line drawn from p1 to p2 using the [atan2 (hyper-link)] method.\n", "If you consider the line as the hypotenuse and the distance in x (dx) & y (dy) as catheti you can write: let angle = Math.atan2(dy, dx);.\n", "This will give you the angle in radians.\n", "If you need the angle in degrees you have to: let angleInDegrees = angle*180/Math.PI\n", "Then with margin-right negative I tell how much in pixels the angle start, thus, aligning the circle with div.\n", "The inner angles of a triangle need to sum up to 180\u00b0.\n", "Also, the angle 99.96\u00b0 is supplementary to the triangle's angle next to it (calling it by A), i.e.\n", "Calling of B = 42.27\u00b0 the bottom angle.\n", "And for the last angle C, we can use that it is opposed by the vertex with the other angle that is equal to 2 * 28.85 = 57.7\u00b0.\n", "The new angle can be calculated by [math.atan2(y, x) (hyper-link)]:\n", "If angle direction is needed, then this will work:\n", "It's very straight forward, Vector3.angle.\n", "Essentially returns the angle that's generated from one position, to another.\n", "An example would be var characterDirection would be the \"from\" parameter, and lets say var enemyPosition would be the \"to\" parameter, and it will generate an acute angle.\n", "The thing is, if you try to call Vector3.Angle(transform1.position, transform2.position) you're going to get some weird results because it's expecting vectors, not positions even though they use the same object type.\n", "forward is just a shorthand for a vector along the z-axis, so this would be like looking at an angle in 2D space.\n", "Although you don't even need to calculate so many angles.\n", "To get a unit vector without angles just use\n", "Erhm... Just FYI; converting from cartesian coordinates to using angle, and then back to cartesian makes no sense here.\n", "Add this to a new or a related Swift file and all you have to do is call either myView.setGradient(colors: gradientColorsArray)\nor myView.setGradient(colors: gradientColorsArray, angle: 90).\n", "In my opinion, do not try to make OSG left-handed, rather translate the \"logical\" meaning of your rotation angles and apply them to OSG the way it is meant to be used.\n", "Place your loaded model under an osg::PositionAttitudeTransform (or MatrixTransform), then compute the correct rotation (attitude) to apply to it by concatenating 2 quaternions for the 2 rotation angles you expose to the user.\n", "You might have to invert the angle signs to get the correct result (passing from left to right hand).\n", "First of all, I would like to state that angles are over-used.\n", "Sure, angles may be the best representation in some cases, but there are plenty scenarios in which other representations are better suited (e.g.\n", "And most of these alternative representations do not come with the difficulties of angles.\n", "If, however, you find yourself in a scenario where angles should be used, there could be several reasons why you would want to limit the range of angles.\n", "If angles are used to represent a direction, then an angle of Pi is congruent to an angle of 3 Pi (resulting in the same direction).\n", "If you use a 32 bit floating point number to represent a cumulative angle of let's say 1000 full rotations and a bit, you loose more than half the bits of the mantissa to represent the actual direction (disregarding full rotations).\n", "Comparing two angles (e.g.\n", "to calculate the angle between their according direction vectors) is easier if they are in the same range.\n", "for joint angles of a skeleton), the reason for bounding the angles should be obvious.\n", "Mapping angles to linear quantities (e.g.\n", "when you want to draw a diagram or mapping to colors) is easier if the angles are already in a range that just requires scaling and a constant offset.\n", "Not bounding angles could make the code a bit more wordy than it needed to be (and would probably even come with a very minor performance impact).\n", "If all these reasons do not apply to your scenario, you can leave your angles unbounded.\n", "First result for me:\n[http://www.russellheimlich.com/blog/pure-css-shapes-triangles-delicious-logo-and-hearts/ (hyper-link)]\n", "Some guy in the comments noticed that it doesn't work when the angle is above 180deg and offered [a solution (hyper-link)], but it only works up to 360deg.\n", "I would re-write your CalculateDeclinationAngle() as\n", "In began, record the position of the point where the touch began, and in each touchesMoved call, calculate the angle wrt the original point, and rotate the view accordingly.\n", "The angle of each of the lines can be found from this:\n", "The angle calculated is:\n", "Using the slopes of two lines, you can just get the arc tangents to find their respective angles with respect to origin.\n", "Then, get the positive difference of two angles.\n", "First, find the angle for each segment by moving it to the origin:\n", "Then, use np.angle\n", "Then, you can simply calculate the difference between the angles.\n", "Consider the (abc) triangle:\n", "you can then determine the (ab, bc) internal angle with sin, cos or tan\n", "the angle you look for is 360 minus the (ab, bc) internal angle.\n", "this is not enough to allocate the angel uniquely since an angle and its complement has the same cos but has different sins , and here is where the cross product comes to solve the problem\n", "Pie chart \"rotation\" features in PowerPoint are limited to positioning the \"start\" angle of the first segment, with segments growing in the clockwise direction only.\n", "these are Euler Angles, you also have an option to get rotationMatrix, or quaternion format.\n", "Then, you can use time as this parameter t, and set the entity's x and y directly based on plugging the time into the parametric equations rather than setting an angle.\n", "Note:\nWith option 1, it involves updating the entity's x and y directly instead of setting an angle.\n", "If you do still want to update the angle so that the entity faces / fires in the direction it's moving, then you could keep track of where the entity is in the previous tick.\n", "Then using it's current position and previous position you can get a vector of the direction it's moving in, and use that to set the angle.\n", "First off, you need to use an easing animation that starts and ends with the same \"angle\".\n", "To calculate an approximation of the angle, you can look at the mail icon's current position and its next position (in the next animation frame).\n", "This is how you get the angle between the vertical pink line and the black line starting at the pink line intersection:\n", "The center of the rectangle is right between two opposite corners:\n", "The size of the rectangle is the distance between two points:\n", "The corners of the gray rectangle can be calculated from the center and the size, for example the top left corner:\n", "The angle is the arctangent of a side of the square:\n", "(I'm not sure exactly which angle it returns, or what angle you expect for that matter, so you get to test a bit.)\n", "You can use any coordinate pair on the same side to calculate the rotation angle.\n", "Note that mathematic angles normally assume 0 as long the +ve X axis and increase by rotating anti\u2013clockwise (so along the +ve Y axis is 90\u00b0, -ve X axis is 180\u00b0 and so on).\n", "If the shape is not rotated more than 90\u00b0, then life is fairly simple and you can use the tanget ratio of a right angle triangle:\n", "If the rotation is more than 90\u00b0, you will need to adjust the angle.\n", "where the angle is greater than 90\u00b0 but less than 180\u00b0, you'll get a -ve result from the above and need to add 180\u00b0:\n", "Based on the orientation of points in the OP, the following is a general function to return the center and clockwise rotation of the rectangle in degrees.\n", "A simple trig operation will convert the line formula to an angle.\n", "You can run an accumulator of spatial derivatives along different angles.\n", "If you will ask the satellite for its altitude angle using .alt then you should get the value that, in your diagram, is called \u201celevation\u201d:\n", "The altitude alt is one of a pair of coordinates, the other of which is the az azimuth angle.\n", "The confusion here is that the Earth-satellite community of engineers chose the word \u201celevation\u201d for how high in degrees a satellite was above the horizon, maybe without knowing that over in science, astronomers already had a name \u201caltitude\u201d for that angle.\n", "The reason why you get the unexpected angle is that your two rectangles have their corners defined in a different order.\n", "As can be seen from the image, that shorter side indeed has a steeper angle.\n", "As you indicate you cannot influence the order of the points in the rectangle's definitions, you could proceed as follows:\n", "Perform the calculation of the angle based on that edge\n", "To get angle between vector D = (dx, dy, dz) and coordinate planes, you can use scalar product of vector and its projection onto corresponding plane.\n", "Implementing the angle function is actually quite simple.\n", "Using the function [Math.atan2(y, x) (hyper-link)] you can get the angle from the x-axis to a coordinate.\n", "So we need to translate the second objects coordinates to be relative to the origin before doing the angle calculation.\n", "You are not using angles to represent your movement.\n", "\nMathUtils.cosDeg( angleInDegrees )\nMathUtils.sinDeg ( angleInDegrees )\n", "You can get the angle in radians from the transform like this:\n", "If you want the angle in degrees you need to convert it like this:\n", "Switching values of width and height of rectangle is the same as rotating it by 90 degrees.\n", "So if the range of angles was 180 degrees instead of 90 than same rectangle would have 2 representations (width, height, angle) and (height, width, angle+90).\n", "Having range of 90 degrees you can represent every rectangle and you can do that in only one way.\n", "I explained how you can convert the angle of the rectangle into [0-180] in [this thread (hyper-link)].\n", "The Angle is always calculated along the longer side.\n", "So, in fact, RotatedRect's angle does not provide enough information for knowing an object's angle, you must also use RotatedRect's size.width and size.height.\n", "How about this: use the same arithmetic for all of your move methods, and just vary what angle you move along.\n", "If you want to move the object in direction of the mouse, do not go over the insecure angle determination, just normalize the difference vector\n", "As the scaling is not isotropic, width and height can be different, the angles in these geometries will differ.\n", "To get the angle of your ImageView simply use imageView.getRotation(); this will give you an int value of the current angle of rotation.\n", "Finally, To get rotation Angle DURING the time animation is running there is a listener method called addUpdateListener :\n", "You can access angles that are written in inspector like this:\n", "Before assigning your angles you'll just have to clamp them.\n", "Then you can assign the angle to your transform.localEulerAngles\n", "If you want to find the angle between that vector and horizontal axes you can calculate:\n", "But if you are going to use the angle for AddForce, you can convert a_pos and b_pos from screen coordinates to world coordinates and use those points to make the vector for AddForce:\n", "An angle stored as a double will have up to 16 significant figures, and you are trying to concatenate 26,600 of them, this will take a while!\n", "To increase performance, I suggest you round off the angles, for instance to 2 decimal places, and then append them to a StringBuilder, which you can convert back to a string before putting it in your text box.\n", "Do something like \nsb.Append(angleIMG[i, j].ToString(\"F2\")).\n", "What we are trying to achieve is to calculate the angle between the eye and the Z axis when we look at (0, 0, 0) from (1, 1, 1).\n", "You'll notice that the centers of the two circles and the tangent point make a right triangle.\n", "The sine of the angle you need is Ra+Rb divided by the distance between the circle centers.\n", "You can compute the angle with the std::asin function.\n", "and then the angle you need to rotate that normal - and thus the matching polygon - so that the normal \"points up\" should be very simple.\n", "If you know the angle of the red line for some polygon (a, say), then the polygon is on one side or other of that line.\n", "If the polygon is above the line, the rotation angle is 180+a.\n", "where above and below correspond to the smaller-angle side and larger-angle sides of the line according to how you measure a.\n", "sin, cos, tan functions allow you to convert from triangle edge ratio to degrees.\n", "You can treat red line as hipotenuse of rectangular triangle and use arctan to get degrees.\n", "To get the angle at A from B to C compute\n", "At first, ANGLE command is from MATLAB core, PHASE from system identification toolbox.\n", "ANGLE command always give result in range [-pi, pi].\n", "At this time angle(X) command will give value near -pi for the second argument (wrap values into range [-pi, pi]).\n", "This will give you the angle between the vectr you have and a default coordinate basis.\n", "If these vectors are orthogonal (have 90 degrees between them) then you don't need to go through all the bother of calculating angles and using glRotate().\n", "If I understand you correctly, you have already d2 = 0.5 * d1, d1, (x2, y2) as well as the angles.\n", "the angle AOB is smaller than a flat, then the point P must be to the right of AO and to the right of OB (intersection of the two half planes),\n", "the angle AOB is larger than a flat, then the point P must be to the right of AO or to the right of OB (union of the two half planes).\n", "where XY|Z expresses that Z lies on the right of XY, which is equivalent to \"XYZ is clockwise\" and is determined by the sign of the triangle area.\n", "Then use a [bit of trigonometry (hyper-link)] to find the angle:\n", "As seen in the code I'm using the point recorded 4 steps back to increase the smoothness of the angle.\n", "Since the angle between two planes is the same as that between it's normals, I will constrain the discussion to angle between two vectors.\n", "We are dealing with the problem of distinguishing angles -T and +T, where T is some angle.\n", "Using the formula you used, these two angles would give the same result, due to the fundamental formula itself that is used:\natan2 (|a x b|, a.b)\n", "You need to keep track of the sign of a x b, to determine if the angle is positive or negative.\n", "There is actually no easy, official way to specify an angle.\n", "You can write your own angle function by manipulating 4 coordinates of the gradient\n", "However, if all the new angles are multiples of 45, you could avoid using sin and cos.\n"]