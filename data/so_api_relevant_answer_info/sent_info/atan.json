["[std::atan2 (hyper-link)] allows calculating the arctangent of all four quadrants.\n", "[std::atan (hyper-link)] only allows calculating from quadrants 1 and 4.\n", "With atan2 you can determine the quadrant as stated [here (hyper-link)].\n", "You can use atan2 if you need to\n  determine the quadrant.\n", "atan(x)    Returns the principal value of the arc tangent of x, expressed in radians.\n", "atan2(y,x) Returns the principal value of the arc tangent of y/x, expressed in radians.\n", "Notice that because of the sign ambiguity, a function cannot determine with certainty in which quadrant the angle falls only by its tangent value (atan alone).\n", "You can use atan2 if you need to determine the quadrant.\n", "Another thing to mention is that atan2 is more stable when computing tangents using an expression like atan(y / x) and x is 0 or close to 0.\n", "C++ atan2(y, x) will give us the value of angle \u03b1 in radians.\n", "atan is used if we only know or are interested in y/x not y and x individually.\n", "So if p = y/x\nthen to get \u03b1 we'd use atan(p).\n", "You cannot use atan2 to determine the quadrant, you can use atan2 only if you already know which quadrant your in!\n", "atan or atan2 themselves simply return a positive or a negative number, nothing more.\n", "So by convention, atan() returns an angle from the first or fourth quadrant (i.e.\n", "-\u03c0/2 <= atan() <= \u03c0/2), regardless of the original input to the tangent.\n", "And this is what atan2() does.\n", "It takes both, the sin(\u03b1) and cos(\u03b1) and resolves all four quadrants by adding \u03c0 to the result of atan() whenever the cosine is negative.\n", "Remark: The atan2(y, x) function actually takes a y and a x argument, which is the projection of a vector with length v and angle \u03b1 on the y- and x-axis, i.e.\n", "Conclusion:\natan(y/x) is held back some information and can only assume that the input came from quadrants I or IV.\n", "In contrast, atan2(y,x) gets all the data and thus can resolve the correct angle.\n", "I guess the important point is atan only was intended to feed positive values in a right-upwards direction curve like for time-distance vectors.\n", "atan doesn't return negative numbers, so you can't trace things in the 4 directions on a screen just by adding/subtracting its result.\n", "atan2 is intended for the origin to be in the middle, and things can go backwards or down.\n", "So atan2 can give you negative numbers, because its zero is in the center, and its result is something you can use to trace things in 4 directions.\n", "atan = gives angle value between -90 and 90\n", "atan2 = gives angle value between -180 and 180\n", "For my work which involves computation of various angles such as heading and bearing in navigation, atan2 in most cases does the job.\n", "If you are working in a 2-dimensional coordinate system, which is often the case for programming the inverse tangent, you should use definitely use atan2.\n", "Another way of saying this is that atan(y/x) is virtually always wrong.\n", "Only use atan if the argument cannot be thought of as y/x.\n", "atan2(y,x) is generally used if you want to convert cartesian coordinates to polar coordinates.\n", "atan(x) is simply the inverse of tan.\n", "In the annoying case you have to use atan(y/x) because your system doesn't provide atan2, you would have to do additional checks for the signs of x and y, and for x=0, in order to get the correct angle.\n", "Note: atan2(y,x) is defined for all real values of y and x, except for the case when both arguments are zero.\n", "In atan2, the output is: -pi < atan2(y,x) <pi \nand in atan, the output is: -pi/2 < atan(y/x) < pi/2  //it dose NOT consider the quarter.\n", "If you want to get the orientation between 0 and 2*pi (like the high-school math), we need to use the atan2 and for negative values add the 2*pi to get the final result between 0 and 2*pi.\n", "atan speaks in radians, not in degrees...\n", "atan returns a result in radians.\n", "The standard atan and atan2 functions, as well as all other C functions that work with angles, work with radians, not degrees.\n", "If you want your own function to output degrees, you have to multiply the return value from atanf with 180/pi; to keep everything in radians, add pi instead of 180.\n", "Atan takes single argument and Atan2 takes two arguments.The purpose of using two arguments instead of one is to gather information on the signs of the inputs in order to return the appropriate quadrant of the computed angle, which is not possible for the single-argument Atan\n", "Atan2 result is always between -pi and pi.\n", "Reference:\n[https://en.wikipedia.org/wiki/Atan2 (hyper-link)]\n", "docstring for math.atan:\n", "atan(x)\n  Return the arc tangent (measured in radians) of x.\n", "docstring for math.atan2:\n", "atan2(y, x)\n  Return the arc tangent (measured in radians) of y/x.\n", "Unlike atan(y/x),\n  the signs of both x and y are considered.\n", "To be very complete, here's what the doc says about atan2:\n", "math.atan2(y, x) Return atan(y / x), in radians.\n", "The point of atan2() is\n  that the signs of both inputs are known to it, so it can compute the\n  correct quadrant for the angle.\n", "For example, atan(1) and atan2(1, 1)\n  are both pi/4, but atan2(-1, -1) is -3*pi/4.\n", "atan2 returns the appropriate quadrant, unlike atan.\n", "As others said, the atan2 takes two arguments to be able to determine the quadrant of the output angle properly...\n", "It's possible to define an atan function that returns an angle in [0,2pi], as theodore panagos showed.\n", "In a nutshell, math.atan only works for quadrants 1 and 4.\n", "For more reference, take a look at [atan2 (hyper-link)].\n", "The other two use cases are those in which x > 0, which works well with atan.\n", "[http://msdn.microsoft.com/en-us/library/system.math.atan2.aspx (hyper-link)]\n", "Assuming -128 to 127 char, for atan2SC() the result of each octant is 33 integers: 0 to 32 + an offset.\n", "For atan2SC(), the result is 0 to 64.\n", "atan2SC() and atan2SC() can both use this helper function at2().\n", "For atan2SC(), to find the intermediate angle a, use a = at2(x,y)/2.\n", "For atanSC(), use a = at2(-128, y).\n", "Need to find the atan2 approximation with an equation that uses x,y maybe in the form at2 = (a*y*y + b*y)/(c*x*x + d*x).\n", "Depending on rounding mode and if this helper function is shared with atanSC() will dictate its details.\n", "But atan2(-1, 0.0) comes up with +pi.\n", "Note: atan2(-1, -0.0) --> -pi.\n", "The atan2() result is just less than +pi or +128 BAM.\n", "Code for a signed char atanSC(signed char x), if it needs to be fast, could use a few if()s and a 64 byte look-up table.\n", "You don't need to reinvent the wheel, you can use the DecimalMath class, which has an Atan method, the parameter of the method is decimal and the method returns a decimal too.\n", "I'm also experimenting a bug with atan on iOS13\nI use this method to calculate the angle between two points\n", "It seems like calling atan(0.0, 0.0) bugs out\n", "atan2 is a piecewise function, ie for certain values/ranges of values it performs different operations, some of which are just returning a constant value, which is quite fast, but others involve actual trigonometric calculations, which can take quite some time.\n", "If you want the particulars they are available at [https://en.wikipedia.org/wiki/Atan2 (hyper-link)]\n", "The first time the function is called, the page containing atan2 code is accessed and a page fault occurs.\n", "Xcode has in built atan,acos function you just need to pass value in radians.\n", "See the man page for cos, sin, tan, atan, etc.\n", "atan(x) = x^1/1 - x^3/3 + x^5/5 - x^7/7...\n", "So, atan(1) = 1/1 - 1/3 + 1/5 - 1/7 + 1/9...\n4 * atan(1) = 4/1 - 4/3 + 4/5 - 4/7 + 4/9...\n", "Another way to use atan and find pi is:\n", "pi = 16*atan(1/5) - 4*atan(1/239), but I think that's more complicated.\n", "(To be honest, I think the Gregory-Leibniz series was based on atan, not 4*atan(1) based on the Gregory-Leibniz series.\n", "tan x (sin x / cos x) = 1, atan x (1 / tan x) = 1.\n", "So if atan(x) = 1, x = pi/4, and atan(1) = pi/4.\n", "Finally, 4*atan(1) = pi.)\n", "Implementation argument: On intel CPU, the atan2 is part of the [x86 Instruction set as FPATAN (hyper-link)] while the other inverse trigonometric function are derived from atan2.\n", "Interesting reads on FPATAN: [How is arctan implemented?\n", "A simple one would be to use a special case for x near pi + k*pi/2, letting atan(c*tan(x)) = +- pi/2 depending on whether x is slightly smaller, or slightly larger, than pi/2 respectively.\n", "See the C++ std for [atan (hyper-link)]  and [atan2 (hyper-link)]:\n\natan(y/x) returns in range {-pi/2, pi/2}\natan2(y,x) returns in range {0, 2pi}\nYou have exchanged x,y in both cases.\n", "\natan(y/x) returns in range {-pi/2, pi/2}\natan2(y,x) returns in range {0, 2pi}\n", "The implementations of atan and acos depend on the compiler and the optimization settings.\n", "Another possibility: use [atan2 (hyper-link)].\n", "To obtain an output in (0, pi), the sine (first input of atan2) should be positive.\n", "However, it is always best to use atan2 to obtain an angle.\n", "You can probably code it prettier, but that's the logic, which I got from here:\n[https://en.wikipedia.org/wiki/Atan2#Definition_and_computation (hyper-link)].\n", "[ATAN2() (hyper-link)] allows for 2 or 1 argument call.\n", "atan is available in OPL scripting so you could do\n", "atan2 properly accounts for all 4 quadrants and can deal with x==0.\n", "atan2(-1,-1) properly returns -3/4*PI while atan(-1/-1) would return 1/4*PI\n", "Here's a link to more information about atan2: [https://en.wikipedia.org/wiki/Atan2 (hyper-link)]\n", "But these effects of rounding are of about the same size as the theoretical error of approximation of atan by your polynomial.\n", "Here is the plot where red is the difference (polynomial-atan) calculated without rounding to integers, and green is the difference (q4+q3+q2+q1+q0-atan):\n", "I do notice that your polynomial systematically overestimates atan.\n", "When I fit a 4th degree polynomial to atan on [0,1] with Matlab, the coefficients are slightly different:\n", "Now does the standard say that atan is constexpr?\n", "Note that your atan computation is equivalent to\n", "No, atan2 does not require normalized vectors, and if your vectors are not already normalized you shouldn't pre-normalize them as that may slightly reduce precision.\n", "CLDC 1.0 doesn't supports any floating point operations (not saying asin/acos/atan).\n", "CLDC 1.1 support FP operations, but still it's lacking asin/acos/atan.\n", "Try to google and find alternate java sources for acos/atan/asin\n", "We know that atan(x,y) is much more stable in the green region -- when x is close to zero we simply have something close to atan(0.0) which is very stable numerically, while the usual atan(y,x) is more stable in the orange region.\n", "holds for all non-origin (x,y), where it is undefined, and we are talking about atan(y,x) that is able to return angle value in the entire range of -PI,PI, not atan(y_over_x) which only returns angle between -PI/2, PI/2.\n", "Therefore, our robust atan2() routine for GLSL is quite simple:\n", "As a side note, the identity for mathematical function atan(x) is actually:\n", "Here both of the atan() functions return NaN.\n", "[The OpenGL spec for atan(y, x) (hyper-link)] specifies that it should work in all quadrants, leaving behavior undefined only when x and y are both 0.\n", "So one would expect any decent implementation to be stable near all axes, as this is the whole purpose behind 2-argument atan (or atan2).\n", "To test your GLSL renderer's implementation of atan(y,x), here's a WebGL test pattern.\n", "Test pattern using native atan(y,x): [http://glslsandbox.com/e#26563.2 (hyper-link)]\n", "The linked demo samples atan(y,x) for several values of x and y, including 0, very large, and very small values.\n", "The central box is atan(0.,0.)\n", "Test pattern using atan2(y,x) from accepted answer: [http://glslsandbox.com/e#26666.0 (hyper-link)]\n", "In situations where you can use this approach, you get a big win by bypassing the atan calculation completely, which is possible since the only reason you wanted to determine the angle was to calculate the sine and cosine values.\n", "cos, sin, and tan take an angle in radians as input and return the ratio; acos, asin, and atan take a ratio as input and return an angle in radians.\n", "(+ (- (+ (* 176 (atan (/ 1 57))) (* 28 (atan (/ 1 239)))) (* 48 (atan (/ 1 682)))) (* 96 (atan (/ 1 12943))))\n", "It seems like what you want is to use [Math.atan2 (hyper-link)] rather than [Math.atan (hyper-link)].\n", "Math.atan returns a value in the range of -\u03c0/2 to \u03c0/2 (i.e.\n", "This is because it would need the signs of both y and x to compute the correct quadrant out of 4, which is also why atan2 takes y and x as separate arguments.\n", "atan2 takes them separately so it can disambiguate cases like that.)\n", "Also see [What is the difference between atan and atan2 in C++?\n", "The function atan is not a member of std::num because it's defined as part of an impl.\n", "This is because atan is a member of Trigonometric which float implements.\n", "math.h's atan takes a double and returns a double, yet cmath's is overloaded so that a float argument (as used here) will be used as a float and yield a float result.\n", "To make them use the same type, either remove the f at the ends of the numbers or change the first atan to atanf.\n", "atan(sqrt(3))\n", "Read the documentation of [atan(3) (hyper-link)], [atan2(3) (hyper-link)] - it works with radians.\n", "Also, you could avoid having r and ang and use the sqrt(x*x + y*y) and atan2(y,x) expressions directly in the printf.\n", "Notice that atan2 is better than atan since you won't divide by zero if x is 0.0.\n", "logs [\"cos\", \"pow\", \"log\", \"tan\", \"sqrt\", \"ceil\", \"asin\", \"abs\", \"max\", \"exp\", \"atan2\", \"random\", \"round\", \"floor\", \"acos\", \"atan\", \"min\", \"sin\"] in no particular order.\n", "For sin (but not atan) you can actually get simpler than a table--just create\n", "First, you're taking atan(value) to get the angle, and then using value again with sin to compute h.  So we have the scenario where one side of the triangle is 1:\n", "When asking for atan(0) it could be 0 or pi (or every multiple of pi), so the result is in the range from -pi/2 .. pi/2.\n", "Looking at the .net documentation for [Math.Atan (hyper-link)], atan produces a value between -\u03c0/2 and \u2264 \u03c0/2, which doesn't include 10.\n", "EDIT: However, according to [http://msdn.microsoft.com/en-us/library/system.math.atan.aspx (hyper-link)], the atan method already returns -pi/2 < x < pi/2 or NaN if your input is undefined.\n", "double d = Math.Atan(1) * (180 / Math.PI);\nso d will be 45 in degrees\n", "[Math.Atan (hyper-link)] returns an angle, \u03b8, measured in radians, such that -\u03c0/2 \u2264 \u03b8 \u2264 \u03c0/2, so it makes sense to normalize to that range (since it obviously won't anything within that range anyway):\n[code snippet]\n", "For instance, Math.Atan(Math.Tan(-0.49999632679501449)) + 0.49999632679501449 will be greater than Double.Epsilon for 1.1235582092889474E+307 times.\n", "To be honest, just use [atan2 (hyper-link)].\n", "Also, atan2(0,0) will give you domain error as specified.\n", "In that case the Math library really doesn't contains atan function.\n", "So you have to calculate atan by yourself.\n", "atan should get number (double, float or long), but you are providing matrix.\n", "orientation = atan( grad_y / grad_x ) * 180/PI ;\n", "The canonical solution is using std::atan; return integrate(atan(a), PI/2);.\n", "Visual Studio will interpret 0 as an integer and fails at the call of std::atan because it doesn't know which floating type (float, double, long double) the integer should be cast to:\n", "To get rid of this, you should either use a specific version of std::atan, std::cos and std::tan by using static_cast<double> or static_cast<long double> in your quadrature,\n", "The compiler is able to evaluate 4*atan(1) at compile-time.\n", "This is true for atan and all other constexpr functions.\n", "To make the search for the root easier, you can get rid of atan by taking the tan of both sides and use tan(a-b) = (tan(a) - tan(b)) / (1 + tan(a)tan(b)) :\n", "You want to use [Atan2 (hyper-link)] here.\n", "atan(x) is the same as atan2(x,1).\n", "atan2(y,x) is the angle of the point (x,y), while atan(y/x) is the angle of the line through the origin and (x,y).\n", "The only inverse trigonometric function present as FPU on x86 CPU/FPUinstruction is FPATAN which implements atan2.\n", "Thus also asin(x) is implemented as atan2(x,sqrt(1-x*x)), acos(x) as atan2(sqrt(1-x*x),x).\n", "The idea looks ok, but I would suggest using [Math.atan2 (hyper-link)] instead of Math.atan.\n", "As to the numerical accuracy of Math.atan I would think that the authors had gone to great lengths to ensure it's numerical accuracy.\n", "There's nothing wrong with Math.atan.\n", "Once in one of those spaces, you can get the hue from the angle formed by the chroma channels, by doing hue = atan(cr/cb) (watching for cb == 0).\n", "CLDC 1.1 (JSR 139) has some trigonometric and double / float functions in [Math package (hyper-link)]\nof functions mentioned in question, sin cos tan are there, asin acos atan atan2 aren't\n", "Use [atan2() (hyper-link)] to do all this hard work for you.\n", "I get the mistake it should atan x y.\n", "The range of atan() is [-pi/2 ... +pi/2] with repetitions when going outside that range.\n", "To avoid this sort of thing, use angle (or phase) and/or atan2 (the 4-quadrant version of atan):\n", "atan2 returns all possible angles because it's not used just for drawing lines!\n", "atan, on the other hand, produces results in [-pi/2, +pi/2].\n", "One common application of atan2 is converting from cartesian coordinates to polar coordinates.\n", "Else you could just use atan(y/x).\n", "atan2 returns results in [-180,180] (or -pi, pi in radians).\n", "It should be noted that it is typical to express rotations in [-pi,pi] and thusly you can just use the result of atan2 without worrying about the sign.\n", "Your problem is that the result of atan2 is between -180 and +180 degrees.\n", "But the main problem is that atan returns a result in radians and not degrees (as your +/- 180 would suggest you expect).\n", "As dialer mentions in his comment, there is a function that can also handle quadrants, [atan2 (hyper-link)].\n", "The clean way to do this is use angle-subtraction formulas to get values proportional to the sine and cosine of the difference angle, and use atan() only once:\n", "Why not just benchmark your look-up table approach against the atan() provided with .net.\n", "With a small benchmark application, it appears that even if the fpu is used, the performance of Math.Atan2 is not as good as an alternative approximisation function.\n", "In my simple benchmark, the Math.Atan2 loop is taking 8 seconds, whilst the approximate version is taking 5.5 seconds.\n", "The \"Intel 64 and IA-32 Architectures Optimization Reference Manual\" (download [here (hyper-link)]) lists fpatan as having a latency of 150-300 cycles on recent hardware.\n", "implemenetation of this \nangles(i,j)=atan(im_y(i,j)/im_x(i,j));%angles are -pi/2 to pi/2 return Nan value in some pixles.\n", "atan2(-x, -y) towards origin\natan2(x, y) opposite to origin\n", "Math.Atan returns a value in radians.\n", "Atan(1) is equal to \u03c0/4.\n", "This means that 45 radians is equal to about 2578.31008 degrees, so the tangent you are looking for should be better expressed as tan(\u03c0/4) or if you don't mind \"cheating\": Math.Tan(Math.Atan(1)); // ~= 1.\n", "You shouldn't use atan here.\n", "Delete the line with atan and replace with these lines:\n", "atan2 isn't simply atan applied cell-wise.\n", "And then for how to implement atan2 by yourself (as I'm doing) see: [http://en.wikipedia.org/wiki/Atan2 (hyper-link)]\n", "Atan2 is not quiet atan as it takes into account the quadrant.\n", "see:  [http://en.wikipedia.org/wiki/Atan2 (hyper-link)]\n", "your first case is atan(x/y) - Pi\n", "Try using Math.atan2 instead of Math.tan.\n", "It's plausible that atan(1) isn't giving quite all the digits of pi/4 either (because atan as well as any other trigonometric function is an approximation).\n", "You are sort of going about it the right way but you should actually use the atan2 function.\n", "The atan2 function gives you an angle  which is anticlockwise from the positive x vector\n", "using the atan2 variant of the\n  arctangent function, or\n", "I would strong advise you use the inbuilt atan function, it is more than likely been well optimised for you architecture, as well as being a standard function recognised by most C++ programmers.\n", "To calculate the phase contribution we need to calculate the phase using the 2*atan(imag/(sqrt(real^2+imag^2)+real)) algorithm.\n", "If you ever need to calculate this manually, better use atan2(imag, real) instead of that complicated 2*atan(...) formula.\n", "Also note that you probably want to use Math.atan2(spdY, spdX) instead of the default atan method you use.\n", "atan2 will take care of these edge cases.\n", "There is a problem with the angle: atan returns an angle in radians.\n", "In the code where you used Math.atan should be changed to Math.atan2.\n", "atan only gives angle values between -90deg and 90deg.\n", "atan2 gives angle values between -180deg and 180deg.\n", "First, change atan to atan2\n", "If you want to get the angle of the mouse relative to the center, using atan2 should get you sorted:\n", "In order to get angles you can get the Acos of the dot product of those vectors or calculate Atan(Dcmx/Dcmx) like the paper you shared\n", "hFov = 2 * atan(tan( vFov/2 ) * width/height)\n", "There is an open source atan implementation [here (hyper-link)].\n", "normalized_atan(x) ~ (b x + x^2) / (1 + 2 b x + x^2)\n", "normalized_atan(x) ~ ( c x + x^2 + x^3) / ( 1 + (c + 1) x + (c + 1) x^2 + x^3)\n", "In the katan kernel, src should be passed by value instead of by const reference.\n", "Remember that at the caller side, src resides in the host memory side, so passing by reference will not incur any host to device memory copy, which means that in the katan kernel, src is also at the host side.\n", "pi/2 and -pi/2) are outside of the valid domain of atan, which makes taking the atan of those values impossible.\n", "You also may have to deal with the fact that atan always returns a reference angle, which may not be the quadrant you want your answer to be in.\n", "These are very well known issues, and most languages have a simple cure, called atan2.\n", "In the case of javascript, please see [the MDN reference for atan2 (hyper-link)].\n", "atan2 doesn't give you higher precision, but it does give you values over the complete range of [0..2pi], without you having to do all the extra work of figuring out which quadrant the answer should be in, as well as supporting pi/2 and -pi/2 within its range.\n", "It should be noted that the most significant change I made to your code was not atan2, however, it was changing around your use of parenthesis.\n", "While I'm an advocate for using atan2 any time you would normally use atan, your actual issue was misuse of parenthesis, making Oriol's answer the right one.\n", "Finally, don't use atan, use atan2 instead.\n", "In a fixed-point environment (S15.16) I successfully used the CORDIC algorithm (see Wikipedia for a general description) to compute atan2(y,x), then derived asin() and acos() from that using well-known functional identities that involve the square root:\n", "It turns out that finding a useful description of the CORDIC iteration for atan2() on the double is harder than I thought.\n", "nVidia has some great resources I've used for my own uses, few examples: [acos (hyper-link)] [asin (hyper-link)] [atan2 (hyper-link)] etc etc...\n", "It is important to realise that mulitple mathematically correct expressions for phase and orientation may in fact not be suitable using MATLAB's acos(), asin() and atan() functions.\n", "See the [reference here (hyper-link)] for atan:\n", "I alway recommend using Atan2(dy,dx) instead of Acos(dx) because it is more stable numerically at angles near 90\u00b0.\n", "atan2 allows you to have dx=0.\n", "Math.atan2() is a friend in problems like this.\n", "What's happening is that when the clicks cross the negative-X axis, the angle returned from atan2() changes from \"something close to \u03c0\" to \"something close to -\u03c0,\" or vice versa.\n", "You have to take into account that the output of atan2 is only ever in the range -pi to +pi.\n", "If the difference between the output of atan2 and your previous angle is greater than pi, then you know that some wraparound occurred, and you have to correct for it by adding/subtracting 2*pi.\n", "How is it that calling atan() isn't allowed, but the mathematical operation 2 * M_PI is allowed?\n", "However, a single runtime call, such as atan(...), will \"poisons\" the whole thing, so the compiler will evaluate as much as it can, but the expression will remain a runtime expression, not a compile-time constant.\n", "atan(1.0) is not a compile-time constant because it requires calling the function atan() at runtime.\n", "The simple solution is don't call atan(), just us the actual numeric values of pi and tau as your initializers:\n", "For the phase you ideally need an atan2 function which takes the real and imaginary components as separate arguments and returns a 4 quadrant result.\n", "atan2(self.y, self.x) == \\beta\n", "atan2(other.y, other.x) == \\alpha\n", "atan2(self.y, self.x) - atan2(other.y, other.x) == \\theta\n", "As pointed out by others, use [atan2() (hyper-link)]\n", "Although using atan2 solves the problem, the actual question hasn't been answered:\n", "So, when you write z = atan(y/x) you expect a number z such that tan(z) = y/x, but there are infinite such numbers, since tan(z + pi) = tan(z).\n", "That's what atan2 and angle do: They check for the sign of each component separately, and then determine if +/- pi should be added to the result of atan.\n", "You also probably want to use the atan2 function because of the type of data you're expecting.\n", "[http://www.mathworks.com/access/helpdesk/help/techdoc/ref/atan.html (hyper-link)] \nexhibits that an atan is asymptotic at +/- pi/2.\n", "Therefore, the max difference between two results of atan is pi or 180 deg, whether you use the +/- notation or positive 0 to pi  notation of a gradient.\n", "When you use atan(slope) you lose (literally) one bit of information, that is there are exactly two angles (theta) and (theta+PI) in the range (0..2*PI), which give the same value for the function tan().\n", "Just use atan2(deltax, deltay) and you get the right angle.\n", "The maximum of atan is pi/2, the left side is between 3*pi/2 and -3*pi/2, it is never equal to 115.\n", "Keep in mind that atan uses radians, not degrees.\n", "First off, note that the syntaxes of the two arctan functions are atan(y/x) and atan2(y, x).\n", "If you know the individual x and y coordinates, the particular solution to the atan function can be found (i.e.\n", "Therefore, atan2() BECOMES OUR CHOICE.\n", "Because asin(y,x) acos(y,x) would each take the same parameters as atan(y,x) and each give the same answer.\n", "The unclarity arises from the name (of atan2).\n", "exp, atan, these are in the math lib, it is called libm.a , you link to it with -lm which you did to, but in the wrong order : gcc -lm density.c -o density is wrong,  gcc  density.c -lm -o density is correct.\n", "This uses the general [atan2 formula (hyper-link)] used to converting cartesian coordinates into polar coordinates, to get the angle:\n", "The advantage of this method is that you don't need to divide the coordinates which avoids rounding errors and problems with dividing by zero, or calculate the atan which is a costly operation.\n", "The problem is that the angle computation phi=atan2(y,x) assumes a \"normal\" Cartesian coordinate system where the y axis points upwards.\n", "Thus you should use phi=atan2(-y,x).\n", "NOTE The behaviour of the functions acos, asin, atan, atan2, cos, exp,\n  log, pow, sin, sqrt, and tan is not  precisely specified here except\n  to require specific results for certain argument values that represent\n  boundary cases of  interest.\n", "The issue was my camera rotation using acos which gave me 0-180 degree freedom rather than using atan\n", "Most programming languages have a two-parameter version of atan, often called atan2 This will usually give a result in the range (-PI, PI].\n", "Since your language's atan function takes two arguments, it probably does the same thing as atan2.\n", "You appear to be using [atan2 (hyper-link)], which returns an angle in (-pi, pi).\n", "If you want to cast your values to float before passing them to atan, you can use the [floatval (hyper-link)] function.\n", "That's what the [std::atan2 (hyper-link)] function is for.\n", "The std::atan2 function will do it for you.\n", "atan and floor are included in lm.\n", "You are probably looking for [atan2(yDiff, xDiff); (hyper-link)] which computes the arc tangent of yDiff/xDiff using the signs of arguments to determine the correct quadrant, instead of [atan (hyper-link)] (which also require only one parameter).\n", "I'd strongly urge you to use the ready made arbitrary precision library (or a similar one) as it avoids any need for you to \"roll your own\" arbitrary precision maths functions (such as pow, exp,sin, atan etc).\n", "M=2*atan(tan(theta/2)c)-esin(2*atan(tan(theta/2)*c))\n", "is in range [PI, 2*PI], because  the result of 2.0*PI + atan(uv.y,uv.x) is in range [PI, 3*PI].\n", "But since the result of [atan (hyper-link)] is always in range [-PI, PI], it is sufficient to do:\n", "The block gnuradio.blocks.complex_to_arg (Complex to Arg in GRC) is an atan2 operation.\n", "This block produces essentially the derivative of atan2, but without any discontinuities at 180\u00b0 or 360\u00b0.\n", "There is no argument function like atan2.\n", "I think the problem might be while trying to include the noise curve with the original .So make sure that you mixes these curves in a proper way.There is nothing wrong with the atan or any other math function you used.\n", "atan(e / d) loses the 4 quadrant nature of a->y, a->z;.\n", "double atan2(double y, double x);\n  The atan2 functions compute the value of the arc tangent of y/x, using the signs of both arguments to determine the quadrant of the return value.\n", "atan\n\nIf the argument is \u00b10, it is returned unmodified.\n", "Considering (atan(x) + 1) / 2, quite likely the only useful values of x are those where the exponent is fairly small.\n", "atan of a fixed point number can be calculated in HW fairly easily; there are cordic methods (see [https://zipcpu.com/dsp/2017/08/30/cordic.html (hyper-link)]) and direct methods; see for example [https://dspguru.com/dsp/tricks/fixed-point-atan2-with-self-normalization/ (hyper-link)]\n", "According to [Wolfram Alpha (hyper-link)], tan(atan(A)+C) can be written as (A+tan(C))/(1-A*tan(C)).\n", "This, combined with the fact that tan(atan(A)) = A, reduces your formula to\n", "atan(A) = atan(x_a/y_a) for some point is the angle between vector (x_a,y_a) and Oy.\n", "Because C is a constant, you can precompute some vector c=(x_c,y_c) with unit length and inclined to Oy with angle C. Then cos(atan(A)+C) can be expressed as inner product of these vectors divided by length of a.\n", "The bearing calculation is incorrect, you need to swap the inputs to atan2.\n", "The Y in atan2 is, by default, the first parameter.\n", "As is, when both coordinates are negative, the quotient, and the result of atan will be positive, a value between 0 and \u03c0/2.\n", "Also, you should use atan2, which gives you the correct angle without adjustment.\n", "At runtime atan() could be anything.\n", "This seems to me to be cleaner, easier to read, and more efficient than atan(1.0)*4.\n", "The center of the rightmost triangle is: x - r * h / w, y - r. The angle that's covered by the arc you need to draw is \u03c0 - \u03b1, where \u03b1 is the corner angle you've calculated with atan.\n", "The atan() code is the same, just the function changes.\n", "Use [Math.atan2 (hyper-link)] instead of atan.\n", "You should look at using the atan2 function, it will probably remove the need for all the if statements and extra computing.\n", "In short, you want to use atan2 to take care of the different quadrants, but don't forget that the angles are defined differently in meteorology!\n", "We measure the wind direction in degrees clockwise from North, whereas atan2-type functions generally work in radians from the X-direction (i.e.\n", "WDIR= 270-atan2(V,U)*180/pi\n", "WDIR= (270-atan2(V,U)*180/pi)%360\n", "This is the same as the original integrand except for pulling out the minus sign (atan(-y) = -atan(y)).\n", "There is a simpler result from Wolfram Alpha although it uses complex numbers even in the case that the integral is real:\n[https://www.wolframalpha.com/input/?i=integrate%28atan%281%2F%281-x**2%29%29%2C+x%29 (hyper-link)]\n", "When the preprocessor runs it will replace every instance of PI with 4.0*atan(1.0f).\n", "If your code says std::cout << PI; then the compiler pretends you typed std::cout << 4.0f*atan(1.0f);.\n", "However, most modern compilers will see std::cout << 4.0f*atan(1.0f); and do that calculation at compile time and will emit assembly for std::cout << 3.14159265f;, so the code is just as fast as if it were precalculated.\n", "Because of that everywhere you have PI it will get replaced with 4.0f*atan(1.0f).\n", "You have to use atan2() instead of atan().\n", "atan2() is the arctangent function with two arguments.\n", "This is not possible for the single-argument arctangent (atan) function.\n", "The angle calculated using atan2 is multiplied by 180/pi in order to convert the answer from radians (atan2's default output) into degrees.\n", "To simplify your code, you could use atan2 instead of atan.\n", "Atan2 does the quadrants for you.\n", "Thanks to @Bemmu it appears that all I really needed to do was to use the atan2(y, x) function and parse in the Opp and Adj lengths of the triangle which were the differences between the y and x values respectively.\n", "atan returns the value in radians, not degrees.\n", "The atan2() function is between than atan() because it considers the signs to the inputs and goes all the way around the circle:\n", "In addition to converting from radians, consider using atan2 instead of atan.\n", "Whereas atan will give the same answer for points on the opposite side of the circle, atan2 will give you the correct angle, taking into account the signs of both dx and dy.\n", "Note that atan2 will return something between -pi and pi, or -180 degrees and 180 degrees, so the % 360 is to shift the result to your desired range.\n", "Your condition (x**2 + y**2)<((a*cos(atan(y/x)))**2 + (b*sin(atan(y/x)))**2) is equivalent to (x**2 + y**2)**2 < (a*x) ** 2 + (b*y) ** 2.\n", "You can use the numpy extensions of the Python Calculator in ParaView, but numpy have called the function arctan2 rather than atan2.\n", "Off the wall, but how about try fitting:\nf(x)+g(x)  = a*exp(x)+b + atan(b*x/a)\n", "You are suffering from the fact that atan(slope) cannot deliver correct values for all directions.\n", "A traditional solution for the situation was always to look closely at the signs of the x and y values and then decide in which quadrant the result of the atan() should be located.\n", "Nowadays this is done in the function with the uninspired name atan2().\n", "If your x2-x1 goes towards 0, your argument to Math.Atan goes towards infinity, and overflows.\n", "Angle = Atan((mousePosY - imageCenterY)/(mousePosX - imageCenterY)\n", "Anyway I would suggest using [Atan2 (hyper-link)] rather than Atan.\n", "This code implementing atan does not know how the floating-point environment is set.\n", "The point is that atan is the inverse of tan and tan does actually generate infinite values at some points, here's a picture:[image]\n", "The code is catching the cases where you would feed an infinite argument into atan and returning the angle that would give infinity (+/- pi/2 gives positive or negative infinity respectively).\n", "The generally accepted way to do this is to just use the atan2 function instead.\n", "[std::atan2 (hyper-link)] expects the arguments in the order y,x, not x,y.\n", "Your second problem is that the values that atan2 correspond to don't match up with the directions you want.\n", "Punching the values into atan2 is instead going to produce values where the right side is 0\u00b0, up is 90\u00b0, left is 180\u00b0, and down is 270\u00b0.\n", "So if you want to transform the normal atan2 rotation into the rotation you want, you'll need to transform it like this:\n", "atan(f*fo/(q*(f**2 - fo**2)))\n", "-atan(w*wo/(q*(wo**2 - w**2))\n", "Nevermind, I was using atan(float x), instead of atan(float x, float y) which essentially is atan2.\n", "Usually, people will use atan2 (documented [here (hyper-link)] and [here (hyper-link)])\n", "I would also use atan2 instead of atan because it finds the proper four-quadrant arc-tangent of the Cartesian coordinates.\n", "Use atan2 instead of atan:\n", "P = atan2(Y,X) returns an array P the same size as X and Y containing the element-by-element, four-quadrant inverse tangent (arctangent) of the real parts of Y and X.\n", "Your problem is probably atan(theta).\n", "You should instead use atan2(y,x):\n", "Read more: [Atan2 (Wikipedia) (hyper-link)]\n", "I switched back to an ATAN2 solution (seen in the BP), but found that my sprite was facing away from the mouse instead of towards it.\n", "You should compute phase with [atan2 (hyper-link)]:\n", "atan2 computes the four-quadrant inverse tangent.\n", "It is more precise than atan because the division looses precision.\n", "I don't know for sure how MATLAB's angle is implemented, but it would be weird if it weren't implemented through atan2.\n", "Partially solving your equation gives atan(-5*x) == -60.\n", "This clearly has no solution since the range of atan is only defined from -pi to pi.\n", "The correct equation is 3*atan(-5*x) == -pi.\n", "The invAtan constant is the [reciprocal(or multiplicative inverse) (hyper-link)] of 2PI and PI:\n", "In more practical terms, assuming that given direction is normalized(hence mapped to the [unit-sphere (hyper-link)]) multiplying by invAtan transformes the values into the [-.5,.5] range, adding .5 results in uv lookup coordinates in the range of [0,1].\n", "Note the use of [atan2 (hyper-link)] to get a valid 4 quadrant result.\n", "We also need to add \u03c0 radians (180 degrees) since atan2 returns values in the range -\u03c0 to \u03c0.\n", "Note also that x and y are transposed compared to the more conventional usage (atan2(y, x)).\n", "keywords that are functions, to be followed by operations in parens\nvar regex_function = \"(abs|acos|cos|atan|tan|asin|sin|ceil|floor|sqrt|log|ln)\\([^)]+)\";\n", "Going back to your question and atan(...), I don't quite understand the need of using this here, except if that's a project for the math class :)\n", "There was an unnecessary pair of brackets after atan, also notice that correctly indenting will make this type of errors easier to spot.\n", "As explained [here (hyper-link)], atan only works in the first and fourth quadrant.\n", "Or just use [atan2 (hyper-link)].\n", "This is probably not going to be any more or less portable (both atan and M_PI are standard in both C and C++).\n", "However it will be more readable than using atan and depending on your compiler's optimization settings, may save you a costly trig function call.\n", "atan\n", "atan() provides a [-\u03c0/2... +\u03c0/2] radians (aka [-90...90] degrees) result.\n", "A whole circle result of [-\u03c0... +\u03c0] radians (aka [-180...180] degrees) is available with atan2(y,x)\n", "As a side note, passing an angle into atan isn't likely to give you anything useful.\n", "atan2 is very similar, but it's often more useful as it does a little more of the work for you.\n", "The problem is atan(1)*4 will only be evaluated with single (or double) precision, since this part of the code has nothing to do with gmp and will use the standard c++ types.\n", "The program will evaluate atan(1)*4 first and then convert the result into an mpf_t.\n", "Use [atan2 (hyper-link)] instead of atan in your code.\n", "Using the atan2f function instead I managed to get the vehicle vector angle and target vector angle.\n", "It's better to use atan2\n", "Let tan(-z)=-tan(z)=tan(2*pi-z)=tan(pi-z)=w, then -z, pi-z, 2*pi-z all equals atan(w), the solution is not unique in z.\n", "If we are interested to find solution 0<theta<pi then the only candidate solution is pi+atan(y/x)=2.338123\n", "But, in case of atan, b/a is always 0, so that the result of atan() is all 0.\n", "The angle function can be expressed as angle(z) = imag(log(z)) = atan2(imag(z),real(z)).\n", "Note that they define it with atan2 instead of atan.\n", "(Actually, for the positive numbers, any even-integer multiple of pi will do, but 0 is the \"natural\" choice and the one that you get from atan2.)\n"]