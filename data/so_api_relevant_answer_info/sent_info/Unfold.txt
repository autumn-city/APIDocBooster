Firstly set foldmethod=syntax and try zfit to fold start tag and zo to unfold tags, It works well on my vim.
Then, to unfold all I would press Ctrl+K then Ctrl+J.
Ctrl + Shift + ] to unfold
The common lisp hyperspec doesn't define an unfold function, but you can certainly write your own.
with its equivalence using unfold:
In general, (unfold p f g seed) is basically
Ctrl+Shift+[ folds a region, while Ctrl+Shift+] unfolds a region as noted in the [Key Bindings Documentation (hyper-link)]:
If you want to fold/unfold recursively, you can use Ctrl + K, Ctrl + [ to fold, and  Ctrl + K, Ctrl + ] to unfold.
This will fold/unfold all regions within a region (i.e.
the getTitle() function, and it's return function will get folded/unfolded respectively).
Yes, you can use the template unfold string % scope as follows:
This gives us the goal forall x : N, (x ?= x)%N <> Lt with unfolded >=.
Whatever lines are enclosed in braces can be folded and unfolded using the '+' and '-' handles on the left, next to line numbers.
Ctrl-clicking a fold point (+/-) will recursively unfold/fold all blocks inside it.
I have discovered that, if your code blocks are folded and you hit Enter and then select Undo, NPP will unfold only the code block where the cursor is.
Hard to say without a reproducible example, but Ssreflect's unfold should work:
Use this in order to trigger the click event manually and see the calendar unfold at the beginning.
Then you can write your unfold as a function that returns current item as head and then just returns itself wrapped in a closure as tail.
This [Hint Unfold <qualid>] adds the tactic unfold qualid to the hint list that will only be used when the head constant of the goal is ident.
@AntonTrunov is correct in his explanation on why [Hint Unfold (hyper-link)] is not used here.
The other would be to reverse it first on a speed of 0 and then reveal at 0deg to unfold.
[tf.image.extract_patches() (hyper-link)] is analogous to torch.nn.Unfold, but you need to rejig the parameters slightly:
Using this yielded the same results exactly and Pytorch's Unfold
Try Ctrl-K Ctrl-]  recursive unfolding when the cursor is on the function to unfold.
If you move it out of the partial_order context, both simp and unfold should act on both occurrences of directed.
So that explains why we fold() because we are checking for existence of "John" in your example and if he's found then he will exist in the List and when that List with "John" hits coalesce() its first check will be to unfold() that List with "John" and return that Vertex - done.
To unfold a fixpoint you need to destruct its decreasing argument.
Notice that in both of your solutions you're excluding the starting element in the sequence, and that in the unfold-based solution the generated sequence is somehow lagging behind one position, that's why you had to pass next-colatz-step twice.
If we start from the given n number, the second argument for unfold is just the identity procedure, which seems more natural.
In the upcoming KDE Frameworks 5.27 release, KTextEditor will additionally have the entry View > Code Folding > Unfold Toplevel Nodes, see [this commit (hyper-link)].
It's because unfoldL can produce infinite lists.
Section 6 has a proof of the fusion law using the universal property of unfold.
The universal property of unfoldL:
Toggle Fold All (inside the Edit menu at the top go to Advanced, this setting is the last of the third group of settings) unfolds all if all is folded (at least it is supposed to, and does so here)
We can use editor.trigger command to fold/unfold.
No, unfold is not implemented in Clojure.
Or disappointed that iterate is not quite unfold in name or behavior?
I can see people preferring unfold if that is more familiar to them.
A quick search on [https://crossclj.info/ (hyper-link)] reveals [https://github.com/amalloy/useful (hyper-link)] contains flatland.useful.seq/unfold, which though I have not used looks to be a great implementation by a Clojure core contributor and comes with some other cool stuff to boot.
I don't know what version of Coq you are using, but on mine, unfold works just fine: if I do unfold lt in h. in
Using Coq 8.5pl3 it unfolds just fine:
If it is an identifier and you cannot unfold it, then either (1) it is a local variable bound in your context, or (2) it is a global definition defined via Qed.
In the former case, I would guess that you should have tried to unfold or simplify expr1 so that Coq can have access to the actual definition of f (this, in turn, might require removing Qeds from other global definitions).
I don't know why unfolding fmap or destructing the ListFunctor yields a generic fmap0.
In IntelliJ IDEA you can use to following shortcuts to fold/unfold code blocks:
To fold and unfold CURRENT selected block of code:


CTRL+- and CTRL++ on Windows;
⌘ CMD+- and ⌘ CMD++ on Mac;
To fold and unfold ALL blocks of code:


CTRL+⇧ SHIFT+- and CTRL+⇧ SHIFT++ on Windows
⌘ CMD+⇧ SHIFT+- and ⌘ CMD+⇧ SHIFT++ on Mac.
And even after that your folding/unfolding hotkeys listed above will work as well.
pytorch unfold will crop out part of the image that doesn't fit into the sliding window used.
Unfolding: I couldn't find a practical difference between patches = img_t.unfold(3, kernel, stride).unfold(2, kernel, stride).permute(0,1,2,3,5,4) and
patches = img_t.unfold(2, kernel, stride).unfold(3, kernel, stride) so explanation on that would be welcome.
I don't know which exact variant of unfold you are given.
Folding/Unfolding are not captured as "real" actions.
This is a huge improvement over the unfold method I was using previously.
Definitions ending with Qed are opaque and cannot be unfolded.
summary(), you can unfold that as follows:
Your After: is basically rev (rev l' ++ [n]) (with rev unfolded) which means that the reduction you want to see happening has already happened.
The following code performs the three possible modal unfoldings of a 3D tensor (notation and example are taken from [this paper (hyper-link)]):
TL;DR: assuming you are using the default (C-)ordering of elements, then tensor.reshape(N, M*P) corresponds to the unfolding of tensor along its first mode according to the definition used in, for instance, TensorLy.
There are more than one definition of the unfolding.
Generally speaking, an n-mode unfolding corresponds to i) moving the n-th mode to the beginning and ii) reshaping the result into a matrix.
The way in which this reshaping is done gives you different definition of unfolding.
The n-mode unfolding of a tensor is obtained by stacking the fibers along the n-th mode of the tensor so as to obtain a matrix.
The various definitions of the unfolding vary by the ordering of these fibers.
Their definition of the unfolding corresponds to a reshape of the tensor with a Fortran ordering of the elements.
You can either use a different definition of the unfolding to match that ordering, or use a slightly more complicated function to unfold:
Finally, to come back to your first question, if you have an tensor of size (N, M, P) represented as a numpy array, with C-ordering of the elements, then reshape(N, M*P) gives you the unfolding along the first mode of that tensor using the "TensorLy" definition of unfolding.
If you want the "Kolda & Bader" version of unfolding, you can use the f_unfold function defined above.
Note that, regardless of the definition you use, if you want to unfold along the n-th mode, you first have to put this mode at the beginning before reshaping (for instance using np.moveaxis(tensor, n, 0)).
I wrote a [blog post (hyper-link)] about the definitions of tensor unfolding if you are interested in the details.
The workaround is to fold to a particular level, then unfold all, then fold to one level below the previous one, unfold all etc., etc.
First, it should be (unfold descending 5).
You can achieve the same effect with unfold lt.
In the same manner <= means le, but you cannot unfold le, because it is a type constructor.
The manual says that you can unfold only a defined transparent constant or local definition.
The upshot here is that you don't unfold notations, you unfold the definitions those notations refer to.
unfold is not a python function ... here is a recursive solution ...
There is no unfold implementation in the standard library.
more_itertools.iterate can be considered as a nonterminating version of unfold, so you need itertools.takewhile to terminate the iterator.
Let's create a function unfold that uses networkx to create a Digraph to map the relationship between out_item and in_item:
I believe you will benefit from using torch.nn.functional.fold and torch.nn.functional.unfold in this case, as these functions are built specifically for images (or any 4D tensors, that is with shape B X C X H X W).
Let's start with unfolding the image:
Here we obtain all the 16x16 image patches with strides of 8 by using the F.unfold function.
We use F.fold where we tell it the original shape of I, the kernel_size we used to unfold and the stride used.
A way to do this efficiently is to take a ones tensor and use unfold followed by fold - to mimic the summation with overlaps.
Unfolding:
Since step_normal_form is just notation for (normal_form step) you could just do unfold normal_form.
I know it's an old question but others can have the same problem and no one have provided a complete solution, so if you want to fold / unfold something with an animation, I developed a script named [TextShower (hyper-link)] that allows you to do that.
That function has type (Unfoldable t, Foldable t) => (a -> Base t (Either t a)) -> a -> t.  Renaming a to b and taking t as [a] we get (b -> Base [a] (Either [a] b)) -> b -> [a].
My (unproven) claim is that unfoldr' f = apo $ e2pe .
Here's some tests, after defining your unfoldr' and my e2pe:
and use this as a skeleton for such functions, with the standard unfoldr still.
Personally, I would approach the issue differently: model the unfolding cone in blender, add animation and then put animation to three.js.
The longer answer is that the commands that fold and unfold text (which are exposed via key bindings, the menu and the fold arrows in the gutter) don't allow for folded sections to overlap.
In your case that means that when you fold the parent class, the information that the methods were also already folded is lost, so they're no longer folded when you unfold the parent.
To get around that, a plugin would have to try and remember the state of folded regions so that it could unfold things partially instead.
If you are looking for cool paper fold/unfolding animations take a look at [this tutorial (hyper-link)] and here is the code on [git (hyper-link)].
Although it might take a little tweaking of the js/css to get it to look how you want since this is for unfolding paper instead of unwrapping a box, but the basic animation is there.
[unfold (hyper-link)] and [fold (hyper-link)] are used to facilitate "sliding window" operation (like convolutions).
unfold imagines a tensor as a longer tensor with repeated columns/rows of values 'folded' on top of each other, which is then "unfolded":
for a 2x5 tensor, unfolding it with step=1, and patch size=2 across dim=1:
Note that unfold() or addV() are called in an [anonymous fashion (hyper-link)].
Step Five:  To unfold the text, simply repeat Step Four.
As Will Ness points out, you may find the right hand side of the Just case more natural to write using a let binding, as in let (xs, y) = unfoldRest' f b in (a : xs, y).
keepFailure adapts f into a State s (Maybe d) Monad, then stateUnfoldr unfolds to a State s [d], then runState turns it back to a function.
The original function uses the function p (for 'predicate') to determine whether we've finished unfolding, h to apply to each element, and t (for 'transformation') to transform an element into the seed for the rest of the list.
unfoldr expects a single function f :: b -> Maybe (a,b), which returns Nothing if we've finished unfolding, or Just (x, y), where x is the element to add to the list and y is the seed for the rest of the list.
So f in unfoldr is responsible for the functionality of all three of p, h and t. The Nothing-or-Just dichotomy plays the part of the Boolean function p, and the second element of the tuple does t's job of supplying the seed for the rest of the list.
Here's the [definition of unfoldr (hyper-link)]:
And here's Hutton's unfold, rewritten slightly to use case instead of guards:
By comparing types, we can see that unfoldr and unfold share the same final argument type and the same result type.
b in the definition of unfoldr and x in the definition of unfold are basically the same variable.
By now it should be clear that unfold p h t x = unfoldr f x where f = ..., and it's not too difficult to carry on the chain of reasoning and fill in the definition of f.
This is how I solved it:
intall.packages("Rcmdr")
It installed R commander gui for me,then I went to R commander gui, installed and loaded RcdmrPlugin.survival and then I ran unfold from there and it worked.
Or just going straight to 'menu Commands->Unfold All Output'
I want to show you an implementation that is as close to the original unfold implementation in FP as possible.
Here is a first version of unfoldr:
Unfolding is a process that is inherently infinite, hence you need lazyness to stop it.
Here is our updated unfoldr:
Please note that we use [] to indicate the base case and thus the end of the unfolding process.
Here is an example of how unfoldr is used by defining the Fibonacci sequence:
You can unfold the valueMap by the number of values:
Now we have everything we need, we can construct our final generic Unfold<T> which composes those two bits:
Now we can use Unfold<T> to convert any A-like type definition to its "unfolded" version:
Here is a simplified example, hover to unfold:
You can unfold, or disassemble, a polygonal Cube not only inside Autodesk Maya (and then export it as fbx or usdz) but you can also do it using 6 square planes in SceneKit or in Unity.
In any event, your unfold() is not unrolling what is returned from the first choose() parameter - it unfolds the same Traverser object handed to the choose() step.
Anyways, hopping you now have a better intuition about this fixpoint business, we can see that there is a generic way of defining an unfold function for these.
This definition specialises to the usual unfold on list or your definition for trees.
I previously claimed that the third solution presented below has the same strictness as the depth-first unfoldForest, which is not correct.
Your intuition that trees can be lazily unfolded breadth first is at least partially correct, even if we don't require a MonadFix instance.
unfoldForestM_BF is fairly simple.
After building all the labels, it takes the seeds for each forest and collects them together into one list of all the seeds to build the next level and unfolds the entire deeper level.
Unfolding a tree is trivial to write in terms of unfolding a forest.
Both unfoldForestM_BF and unfoldTreeM_BF are defined by packaging their argument up into a Free [] b and unpackaging the results assuming they are in the same structure.
A simple counter example is the following generating function unfolded from 0.
The following examples demonstrate that all implementations of unfoldForestM_BF run actions in breadth first order and that runIdentity .
unfoldTreeM_BF (Identity .
f) has the same strictness as unfoldTree for trees with finite branching factor.
For trees with inifinite branching factor, only the solution for "large" branching factors has the same strictness as unfoldTree.
Together with unfoldTree, we will define unfoldTreeDF in terms of unfoldTreeM to check that unfoldTreeM really is lazy like you claimed and unfoldTreeBF in terms of unfoldTreeMFix_BF to check that the new implementation is just as lazy.
The tree generated with unfoldTreeBF for the finite branching factor solution can never be completely drawn past its first branches.
The hybrid solution from the earlier section is not lazy enough to have the same strictness semantics as Data.Tree's unfoldTree.
It is the first in a series of algorithms, each slightly lazier than their predecessor, but none lazy enough to have the same strictness semantics as unfoldTree.
When the entire tree to that depth is non-finite due to infinite branching factor, exploring a portion of the tree fails to terminate when it would terminate when generated by unfoldTree.
You cannot solve that problem (with unfolding) since from the moment you construct such a dictionary, the order is lost.
Now, to again unfold your code block, release ⌘ (command) button and click on 3 dots folding a block.
I assume that markdown plugin sets up a foldexpr or syntax folding, and when you say "unfold" you are talking about Vim's folding feature (:help folding).
Vim only lets you edit unfolded text, and will automatically unfold a fold when you enter insert mode on a line in the fold.
However you can prevent the content from unfolding from any movement command that does not actually change text, using the 'foldopen' option.
Sounds like you're looking for an "unfold" operation.
Details here: [https://nabilhassein.github.io/blog/unfold/ (hyper-link)]
You can control definition unfolding with the Transparent and Opaque commands.
Seems that i had another function defined that called this unfold method with wrong parameters... silly me, thanks anyways :)
Note that most proof terms obtained that way are going to be just unmanageable, specially unfolding will quickly lead to a worse than exponential size blowup.
If you want a way to have it display unfolded as soon as it is opened, you can use set foldlevelstart=99 as a lot of answers explained.
But, if you just want to see them unfolded, you can just press zi and it will unfold everything.
You can open unfolded file when you put set nofoldenable into your .vimrc file.
The first thing to note is that there's no way you could write a function with type [a] -> Tree x using this unfold: where are the values of type x coming from?
If this were an assignment where the types and the implementation of unfoldTree were given to me up-front, I would double-check that I had read them right; if so, I'd give up on solving it at this point, and say "hey, these types you gave me are no good, what am I supposed to do now?".
There are a few possible answers to this complaint: first, surely the signature of createSimpleTree will be fixed; second, either the Tree type will be amended (with a corresponding change to unfoldTree), or you will be given some sort of guarantee that createSimpleTree will never be called with an empty list.
If you're instead doing this on your own, I would say to fix the tree type and the signature of unfoldTree yourself.
The problem with fold_left is that, in the non-empty case, it unfolds to an immediate recursive call, which keeps too much information hidden for dependently typed programming.
unfold def inlines the definition of def, and also performs some basic reductions e.g.
(fold (not False) would reduce not False to False -> False, search for that, and then eventually give the goal not False -> hold (fun A : Prop => A -> False, but, again, it hasn't properly undone the unfold).
So, basically, the sequence unfold def.
and unfold not.
If you have a look at the documentation for both fold ([https://coq.inria.fr/refman/proof-engine/tactics.html#coq:tacn.fold (hyper-link)]) and unfold ([https://coq.inria.fr/refman/proof-engine/tactics.html#coq:tacn.unfold (hyper-link)]) you can see that they do not expect the same kind of argument.
While unfold takes an identifier as argument, fold takes a term.
So if you have def x y in your goal, you can unfold def to access its definition, but then you might have to use fold (def x y) to return to the original goal.
In any case, there is no guarantee that unfold def ; fold (def x y) will result in nothing, since there might other occurrences of the unfolded def x y in the goal.
Here is a concrete example to see fold and unfold in action.
The definitions of unfoldR and unfoldF form a [co-inductive (hyper-link)] function on the types Rose and Forest respectively.
Due to Haskell's lazy evaluation, we can define and create an infinite mutually recursive Rose and Forest data structure by applying a function f :: (β → α) and g :: (β → List β) and an initial "seed value" x :: β to either unfoldR and unfoldF.
Though unfoldR f g x will result in an infinite structure, h will only search a finite subset of the search space and hence result can be evaluated.
The unfolding itself does not remove any whitespace besides the CRLF.
Unfolding is accomplished by simply removing any CRLF
    that is immediately followed by WSP.
Unlike "reformat code", this doesn't change the folding/unfolding.
and then (in the context of unfold) the (0,1) gets understood as type (Int, Int), so when you call unfold you can omit the type declaration and just write ((a, b)) => Some(a, (b, a + b)).
The function f above does not compile even on its own, outside of your unfold.
You can use [unfold (hyper-link)], but in a simpler manner:
This means it cannot be unfolded.
Before trying to unfold Mem.load just say that it is Transparent, after that everything will work:
There are [several commands (hyper-link)] to fold/unfold code, including these:
In ["The Underappreciated Unfold" (hyper-link)], where unfoldr is introduced, it is known as unfold (and foldr is fold, as you [see here (hyper-link)]).
However, by the time it made it into the List library, it had become [unfoldr (hyper-link)], as a dual to foldr.
Coq's setoid_rewrite tactic is similar to rewrite, except that it looks for occurrences modulo δ (unfolding), can rewrite under binders, and a few other minor things.
This tells rewrite to "unfold" one head constant to another, though it apparently isn't quite good enough to handle your case.
Maximum variance unfolding (MVU) can be viewed as a non-linear generalization of principal component analysis.
The goal of maximum variance unfolding is to learn faithful low dimensional representations of high dimensional data.
The algorithm for maximum variance unfolding is based on a simple intuition.
A more generic solution would be do unfold all environment variables into a dedicated R environment and interpolate strings of interest against it using [glue (hyper-link)].
unfold is implemented like this:
You are using unfold wrong.
The 2nd level list cust2.Rogers.patches is unfold whereas cust1.videotron.patches is not.
I'd like both not to be unfold, i.e.
Unfolder loop could be useful when you can parallelize unfolded operations.
In your case unfolded operation is Math.sin(...) which is more that one CPU instruction.
look at how unfold is implemented.
y within unfold should keep growing with each call
You probably just need to import unfold() properly.
and then refer to unfold() as __.unfold() - or just import unfold() as a function explicitly to use it as you were using it.
For the second case, assuming that fold is List.fold_right, simpl can surprisingly simplify without unfolding and you should not need unfold or fold here either.
Just add your definitions with Hint Unfold to the databases.
When you unfold() a Map, it gets converted to Java Map.Entry and returning that seems to be a problem for the serializer which along the way encounters the internal class HashMap$Node.
to build each new number n in the list is has to unfold an expression n times which gives us O(N2) complexity.
The complexity of unfolding the first N numbers this way is indeed O(N2)Apparently I'm wrong here[1].
Select Edit -> Code Folding -> Unfold All, make a small change like adding then deleting a space, then resave the file.
It will open unfolded next time.
You can then use z motions for folding/unfolding.
For some weeks, the map tile service Unfolding uses as default did not respond properly as they moved to WikiMedia Labs.
I believe you got to implement your own mechanism for folding/unfolding, according to this article.
Hi if you look at the documentation steps of unfoldingMaps you will see that it uses processing which requires Java 7 or 8 so install Java 7 and go to intellij file structure and choose JRE1.7
zo unfold a region
Here'a an algorithm to find what index a number will be at after the
  unfolding.
Imagine you have a nth fold paper and then unfold it.
And why it is not a case with unfold?
Using unfold to define constant and ones means that we don’t get sharing as in the recursive definition
  val ones: Stream[Int] = cons(1, ones).
The recursive definition consumes constant memory even if we
  keep a reference to it around while traversing it, while the unfold-based implementation does not.
Imp2 and unfold version from your example generate new Cons on every next call instead, so both methods generate streams that don't share Cons instance.
However, in that context, n is still an arbitrary but fixed nat, in particular it does not hold that n = 0, and that is the reason why after unfolding the definition of m you get n - 1 ≤ 0 as the new subgoal.
With respect to your specific question, the problem is that you cannot prove your result by induction on n (but you can easily prove it using unfolding m_def by simp).
I looked at your second example from [http://rupl.github.io/unfold/ (hyper-link)] and added more sides + 2 buttons to control the single steps:
You don't want the current environment, your unfold function should be using the calling environment in order to create variables in the tst_unlist scope.
Using current_env() would just place those objects in the environment of the executing unfold function.
Ideally there should be some straightforward way to unfold definitions that include 'with'-based pattern matching, but I don't know how to make that work, eg:
I think you already answered your question in a sense - you use unfold()
If you have multiple vertices you need to isolate the unfold() and so:
Unfolding provides a mapChanged event, similar to mouseClicked and other event handler in Processing's simplified event system.
The specific method is called getScreenPosition(UnfoldingMap map) of AbstractMarker.
[http://unfoldingmaps.org/javadoc/de/fhpotsdam/unfolding/marker/AbstractMarker.html#getScreenPosition(de.fhpotsdam.unfolding.UnfoldingMap) (hyper-link)]
It would also help the code look more organized and clean if you make a CountryMarker class extends SimplePointMarker class, which is available in the unfolding maps library.
You can also fold and
  unfold from the keyboard with the Alt+Ctrl+[ and Alt+Ctrl+] keybindings.
I wouldn't say it does automatic "unfolding" - rather, Theano has a notion of what variables are connected, and can pass updates along that chain.
If this is what you mean by unfolding, then maybe we are talking about the same thing.
There is also set of slides online with a [simple drawing (hyper-link)] that shows the diagram from a 1 layer "unfolding" of an RNN, which you discuss in your post.
If you had multiple W layers (or indexes into one big W, as I believe gwtaylor is doing), then that would create multiple layers of "unfolding".
About your problem with destruct, destruct does not unfold the definitions.
Program gives you terms that are difficult to work with, so you should prove a lemma that factor is equal to its body, and then rewrite with that, instead of unfolding.
When you unfold and rewrite with Fix_eq you get such a horrible goal term to look at that it's best to fold it quickly!
When I unfolded factor_func I saw it contained Wf.Fix_sub, so I searched for lemmas with Search (Wf.Fix_sub).
As an alternative to unfold, you can consider writing the computation explicitly:
The version using unfold is probably more succinct; this one may be easier to read, so it depends on your personal style preferences.
(I'm using defined so that it really unfolds to eq_refl and goes away if need be.)
You can put your term in a hypothesis and autounfold in that.
Use tensorly for unfolding.
Make a function that unfolds the input array.
To unfold a tensor, simply use the unfold function from TensorLy:
Now create a function that takes input array and returns unfolded
array
In this way you could still use Unfolding Maps in your project.
(Unfolding developer, here)
Unfolding does not support Processing.js, due to the reasons described by @user2468700
Specifically the output includes "The reduction tactics unfold foo when applied to 1 argument", "...always unfold foo", and "never unfold foo".
That way, when you resize the top panel (your foldable one) to be shorter (fold) or taller (unfold), the layout manager should expand or contract the bottom panel to fit.
I suppose, there are two distinct parts in your question, first one is why you need to permute, and second how two unfolds combined produce square image slices.
First moment is rather technical - unfold places produced slices in the new dimension of tensor, being 'inserted at the end of the shape'.
So your unfold would simply be
So the values at the memory block would the same unless changed explicitly/manually but cannot be unfolded/roll backed to previous instances while unfolding recursion.
Notice that your unfolding is ill-kinded.
But the original was well-kinded, so the unfolding (which should preserve kinds) must have gone wrong.
Use [Policy Objects (hyper-link)] to enable unfolding in the Python email package.
I tried your script with Python 3.9.5, actually all policies except compat32 (which is used when the parameter policy is absent) enabled unfolding.
This should work since now D can be unfolded.
Let's manually unfold the definition of sumSpecR and see where we get stuck.
There are 2 check-boxes available on kdiff3 Version 0.9.98 under Settings -> Configure KDiff -> Directory: "Unfold all subdirectories on load" and "Skip directory report status".
The compiler has to unfold the template otherwise it wouldn't know what the type of type is.
