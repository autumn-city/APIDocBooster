 The implementation of onPause is very fast because the next activity is not resumed until this method returns.  And is either followed by onResume, if the activity returns back to the front, or onStop, if the activity is becoming invisible to the user.  This is how we implement this onPause callback method. 
 Firstly, knowing the OS can terminate your app's process without warning at any time you can't rely on having an onExit() handler that will be called when your app is closed.  Instead, your Activities should listen for onPause handlers that indicate your app is no longer active.  At this point is may be terminated at any time, so it should save any user data to prevent potential data loss. 
For example, it is not uncommon to implement one with an Activity whose theme is set to that of a dialog.  In this case, displaying the dialog-as-an-Activity will cause the new Activity to be on the top of the stack, pausing what previously was there.
 Start by freeing resources, stopping services, disabling sensor listeners and turning off location requests, and otherwise disabling anything that consumes resources.  all within the onPause handler of your Activities.  Take this a step further by avoiding singletons and custom Application objects within your application whenever possible. 
 If you forget this, the Android system reports a leaked broadcast receiver error.  For instance, if you registered a receive in onResume method of an activity, you should unregister it inside onPause method. 
