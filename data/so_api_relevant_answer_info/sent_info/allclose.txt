If the following equation is element-wise True, then allclose returns True.
The above equation is not symmetric in a and b, so that allclose(a, b) might be different from allclose(b, a) in some rare cases.
If the following equation is element-wise True, then allclose returns True.
According to the [np.allclose docs (hyper-link)]:
And the functions np.allclose or np.isclose just do element-wise comparison no matter if the second argument is a scalar array, an array with the same shape or an array that correctly broadcasts to the first array:
np.allclose is designed to be used with arrays of floating point numbers.
There is no function called allclose that ships with Julia:
I don't know whether an existing Julia function provides the functionality you want but, based on the [numpy.allclose (hyper-link)] documentation, you can implement one yourself (complete with [keyword arguments (hyper-link)]):
But note that unlike NumPy's allclose (and the previous solution of this answer below), array-isapprox calculates a norm of the difference first, and then decides for the resulting value.
If all the elements are (arrays of) integers then you don't need allclose, which is meant for comparing floating point variables within a tolerance threshold.
This is the reason numpy provides the allclose method.
The function allclose is equivalent to the combination of [all (hyper-link)] and [isclose (hyper-link)].
(Crucially, all takes axis parameter while allclose does not).
The prints a 2D array showing which of the slices satisfy allclose condition:
However, this in itself won't suffice: If $v$ is a length 1 eigenvector with a given eigenvalue, then $-v$ is as well, so you can not simply use np.allclose to determine if the results are coherent; you need to take into account the potential reversal.
allclose equivelent:
Nevertheless, I'm still surprised by you need for a loop: you claim that 'The coordinates do not match within python's regular floating point precision': have you tried to adjust the rtol and atol parameters of np.allclose, as described in its [doc (hyper-link)]?
Use [np.allclose (hyper-link)] to test the (almost) equality of float arrays, because of the way float numbers are represented in a computer.
Unfortunately, there are no ops that do exactly the same thing for allclose or isclose, but you can have workarounds.
allclose: based on isclose, use tf.reduce_all in addition
So... just use allclose on the error timeseries and a zero vector (it broadcasts under the hood):
The csr_matrix c will contain the difference of the two matrices being compared, and if any of the absolute differences are greater than your threshold levels, csr_allclose will return False.
This implementation doesn't include the NaN features offered by the numpy.allclose method, however.
Remove the toarray() step from the timings, in effect allclose on equivalent size dense arrays:
I looked through the code (allclose in numeric.py).
