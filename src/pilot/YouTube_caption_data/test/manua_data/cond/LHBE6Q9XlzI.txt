I'm going to talk about the focus of our course
mastering Python for beginners in data science.
So let me explain what kind of areas in this
particular course we are focusing the most.
In fact, because this is a course, for beginners,
that's a beginner level course, we are not
assuming the the course taker to have any
experience whatsoever about any computer programming
language before, not even not even the problem,
problem solving paradigm that lies in computer
science. So, we will, we will focus on problem
solving for a bit. And we will actually start
from the very beginning what problem solving
is, particularly in computer science. The
second focus of this particular course, is
mainly telling you why we are choosing Python,
why Python is so important, particularly for
data science problems. The third focus and
the main core focus is to learn Python, obviously,
once we know what is what what are the techniques
to solve a problem. And once we know that
Python might be a very good language to go
with, then what is Python, how to learn it?
Well, the Python is the main core and main
focus of this course, obviously, we will start
from the very beginning, very, very beginning,
which means we will start from how to install
Python for example, we will start from there,
and then we will see what are variables, I
mean, very, very beginning, and then progressively
we will be moving on and on and on to data
structures to complex structures, but that
transition from 02 onwards, that transition
will be very, very smooth. I mean, whatever
you know, so far, in the course, that will
be helping you to gain more complex structures
very, very easily getting the understanding
of a lot of structures very, very easily.
So in this Python, we will include all concepts
of Python in general. And, and one more thing,
after I mean learning, despite on the way
we the way we organize this course of learning
this Python, you will be having an understanding
of other languages as well. I mean, the contents
here are explained in so general way all over
the Python syntax, but the general but but
but the concepts are expressed in so general
way, the problems that we picked to solve
for practice are so generic that you will
after this particular Python course, you will
be having understanding of programming languages
in general. So data science is one other focus
of this course, actually, the whole course
is organized in a way that it teaches you
about Python, it teaches you problem solving,
it teaches you something about overall programming
languages and how computer can be used to
achieve the solution of different problems.
And and using Python, of course, and then
we will be introducing the data science packages
that are available in Python, because they
are really, really fast, really fundamental,
very easy to use, and very, very powerful
to handle large amount of data very quickly
for data understanding for visualization,
for cleaning, processing, and a lot of stuff,
what we are not focusing at because that's
important. Knowing that what kind of things
are are are the things that we are not covering,
for example, we are not covering object oriented
programming, we are not covering exception
handling, we are not doing web development,
or any general kind of tasks that are doable
in Python, we are not focusing on those things.
Everybody solves different problems every
day. Some problems are easy to solve, and
some are difficult. And yet some are impossible
to solve. They are called unsolvable problems.
But think about different instances of the
same problem one needs to solve again and
again. For example, sorting the sale records.
And let's say we are sorting the sale records
with respect to the sale value. And we have
to do it after every eight hours. If the number
of instances if that number is huge, the optimal
choice is to automate the solution if the
automation is possible, but how how to come
up with the automated solution to come up
with a general solution that works for every
instance of some problem. That is one thing.
But to get that solution running on a computer
is yet another thing
Problem Solving deals with formalizing a general
solution for that works for every instance.
And programming languages, like Python deals
with the running of that solution on a computer.
Python, as, as we will see, makes the transition
from problem solving to the running solution
much easier and quicker. And that's one big
plus of Python. A lot of words, I know a lot
of words. Let me take an example to clarify
what I said, Hold on till the end of this
video. And I will make everything what I said
so far, crystal clear. So let's take an example.
Let's dive into an example to see what I just
said. Let's say your a, and your friend is
B. And your friend B is always willing to
help you. Let's say you found such a friend.
And then a just said, I want off just for
some days. But be said, but what ghobadi enjoy.
He said, someone have to do my job in my absence.
And then be said, That's it? Is that your
problem? I'm available? As always go buddy,
enjoy. Man. He said, great. You're a true
friend. Okay, I'm leaving, wow. And be just
said, Hey, wait, what do I have to do? What's
your job? At the end of the day, I'm going
to do your job. What's your job? What do you
do? And then he said, after every eight hours,
pick the email of the customer when the maximum
sales. So that's what you have to do. He said,
Okay. But from there, I mean, I have to pick
that email of the customer from where, where
are the records? He said, Well, there are
sales records. I mean, at the job place, there
are sales records. And you have to pick the
email of the customer with maximum sales.
We said, Oh, okay. But wait, what, what should
I do with the email that I just picked? Then
he said, oh, there is an other record called
priority records, just write that email after
eight hours, just write that email in purity
records. And then be said, that's it. That's
all your job. And he said, after so relaxed,
he said, Yes, that's my job. That's all. No,
think he leaves and later that day receives
a call from B. And B said, I don't really
know what to do. Can you tell me step by step?
What to do? Focus on again, I'm reading this
particular sentence again. Can you tell me
step by step what to do? I have sales records
with me having all the records for the last
eight hours, what to do, I just messed everything
up. I don't know what to do. And then at the
call, he just described a procedure to be
for his job. That procedure or a general solution,
let's see the solution. He said number one,
start from the first record, there may be
several columns of the record, the customer
name, the customer phone number, the customer
email, the customer products that he buys
and the total sales. And in the point one
said, he said, start from the first record,
and focus just on the sales column. Okay,
then, then after that, go to each next record
one by one, and find the record with a maximum
sales. Obviously, once you have focused on
the sales column, you're just comparing sales
of different records with each other and will
eventually come up with a record that have
maximum sales. Number three.
If there are more than one records with maximum
sales, it is possible that the maximum sales
value let's say is 100, whatever the units
are, and there may be two or three or maybe
five records with the maximum sales 100. Then
which one to pick, as described here in Step
three, that if there are more than one records
with maximum sales, then pick the first one
from top to bottom and ignore the rest I mean,
whichever is the sole. So let's say you have
five records with maximum sale value, which
record appears first from top to down, just
pick that one and ignore the rest. That might
be a policy that might might be a tie breaking
policy, but just do that. And then the fourth
step is focus on the email column of the record
you found in step three. In Step three, you
found a column with maximum sales. Step five,
see the email address and write that address
in the priority records. So that's for the
eight hours, then repeat this process, see
the step six, then repeat this procedure,
after every eight hours, I'm gonna repeat
this procedure, I mean, you'll see the the
solution a is communicating to be in in this
in these kind of steps. It it gives me It
gives a precise idea of what to do. Still,
there may be some, there may be some questions
to be is maybe asking, for example, B may
ask how to find out a maximum, B might be
that person who don't know how to find out
the maximum. And third, for example, another
question we might may ask is that when when
I'm going to write the email address in the
priority rock records, where should I write
at the very top or at the end or somewhere
or, but at the end of the day, a solution
a step by step solution is required for communication,
this kind of if you see the solution, although
it has some it may be explained in there may
be more steps that should be added, but if
you see the solution, the step by step solution,
this is a general solution. This is a general
solution, much more general solution for every
instance, but every instance I mean, after
every eight hours, you will be having some
records, and you have to do this procedure
on the records for that eight hours. And then
after that, that after that eight hours, you
will be having more records to work on. So
after every eight hours, you have the same,
the problem is the same, but the instance
is different, because the records after eight
hours are different. But but the but the solution
says whatever the instance you are right,
right now, whatever the instance is that you're
in, just perform these, these steps, a step
by step solution, coming up with a step by
step solution is is one module of the one
module of the problem solving. And there's
step by step solution is called algorithm.
algorithm. Obviously, the step by step solution
is not always required to be communicated
in plain English or in natural language, you
may come up with shorthands or shortcuts to
explain these step by step solution. So, the
the more shortcuts the more precise and unique
meaning keywords you use in your step by step
solution, the more better communication of
your solution takes place. And going from
this step by step solution, which is just
in plain English, going from this to a more
concise and unique kind of procedure, that
that can that kind of work that one step that
will take us from there to there, that we
will see in the next video will be called
a pseudocode. And from that pseudocode there
will be few steps that will take us to the
second major problem that the problem problem
languages will solve the get the solution
running on a computer. So I'm just just in
this video i i wanted to explain you that
solving a problem may not be that hard, I
mean, coming up with a coming with coming
up with a solution of a problem may not be
that hard, but communicating that solution
or, or writing that solution in a form of
procedure that can solve every instance of
that problem that that requires a step by
step treatment of the procedure. And those
those steps they should be linked in a sequence
and they should be unambiguous. And if a particular
step requires more elaboration, that step
might be broken down to further steps. But
that step by step solution at the end of the
day is called algorithm. Now that algorithm
might be in English, but we will see in the
later video that there are better ways of
expressing algorithms better than English
or better than natural languages. So, so,
if you have another problem come up with a
step by step solution of that, though, every
instance of that problem should be solved
by that step by step solution, which is called
algorithm. And in the next video, we will
see how to actually how to actually eliminate
the need of having English with us and how
to incorporate the uniqueness of understanding
of these steps or algorithm using using the
concepts of pseudocode. And after the pseudocode,
we will see it will be very quick to jump
to any programming language and we will see
that the Python is very close to what humans
generally think, I mean, it's very easy, the
transition will be very, very easy. So, hope
to see you in the next video and I'll be explaining
algorithms in in, in a in a more kind of keyword
way. And, and in the same video we'll be focusing
on pseudo codes which are basically pre step
off of the actual core of any programming
language. So, hope to see you in the next
video. Okay, in in the last video, we were
talking about the algorithm what an algorithm
is and how to express that any any algorithm
and we saw that algorithm is just a step by
step procedure. But, but how to express an
algorithm may vary, I mean, you need not always
to have plain English to or any natural language
to express algorithm. The reason is that the
natural languages are normally so expressive,
and each and every sentence they may have
multiple meaning. So, it is it is a good idea
to come up with a structured way to express
an algorithm such that each and every statement
is completely unambiguous. And one such way
is is to express algorithms using flowcharts
flowcharts are our graphical ways of expressing
algorithms. Here we are taking. The problem
here we are discussing is is computing PE
of different employees of some company. And
the procedure of I mean, if there are several
employees, let's employ one employee to employ
three and so on. Let's say there are several
employees in a company and having each employee
has name, phone number, email and all the
credentials. And then let's say the pay is
computed on hourly basis, and each employee
has worked certain hours for example, eight
hours and each employee has an hourly rate
might be let's say 100 units, whatever the
units are
employed to might have worked for example,
seven hours, but the hourly rate of this employee
might be 200 different employees, they might
have worked for different number of hours,
and each employee can have a different hourly
rate depending upon the capacity of the employee
or the or the job nature the employee is doing
and so on. So, so, so, if we want to compute
pay of all employees, one by one, the procedure
of computing pay is stays the same, the instances
they differ for employee one, the value of
our is eight the value of Raiders 100 for
employee to the procedure will stay the same
the values of our end rate they will differ
so what should be the procedure, the procedure
might be that you take the take the input
of let's say employ one or whatever employee
you are going to compute salary for take the
hours hours value in a in a placeholder call
that place or call that placeholder as ours
placeholder or a variable y this is called
a variable because for different employers
this value will different will be different,
ours will take value eight for each one employee
one this this variable, this placeholder will
take value seven for employee two and so on.
Similarly, once whatever employ whatever employ
for which you are going to compute the pay,
if you have taken the hours from some records
from some working records, then take the rate
for the same employer as well. So input this
that step one in Purdue that is step two,
the steps the sequence of these two steps
may change for example, you take the you take
the rate value first and ours value later
than that, but either way, that's one way
of that's one way of expressing this this
procedure. And then you compute the pay by
this formula. So hours multiplied by rate.
So maybe this is confusing writing a star.
Maybe maybe We should write this cross symbol
because that is more common in mathematics.
Or maybe this whole line can be replaced by,
by this particular line, maybe. So pay is
equal to multiply hours. And rate. Maybe this
is more expressive, but it completely depends,
I mean, when you start writing pseudocode,
or whatever pseudo codes you're writing, what
kind of keywords begin is a keyword and is
a key word, what kind of keywords you're using,
and stay with those keywords for example,
if the keyword input is to use to take to
get the values to to process on then the input
should stay everywhere wherever we want to
do such kind of operation. If you if you're
using for example, the value get rather than
input then use get always but come up with
some set of keywords that are expressive,
as well as concise and then take the sequence
of those statements, each and every statement
should be should have a unique meaning, it
should not be ambiguous, and the sequence
should be in the sequence describe the flow
of what is happening, what is going on. So,
first we take hours, then we take rate these
two values for for for any kind of employee,
and then we will just multiply them and after
multiplication, whatever the scene we want
to make, based on this pay, we will do that,
we may we may record this value, display value
at at some other records register, we may
we may print that value on a print slip, we
may have emailed this value to some other
department or whatever to see and we want
to make, but the procedure really is still
here, then based on pay whatever action we
are going to do that that may differ. Similarly
if we go this is this is I mean, some kind
of structured example of, of the, of the expressiveness
of an algorithm which is called pseudocode.
And what kind of keywords you're going to
use, there are no general keywords, I mean,
some people may use get some people may use
different kinds of keywords for it, but it
is good to come up with a set of keywords
to to describe the describe the solution of
the solution of the problem in flowchart for
example, everything every every statement
here, that is here in in pseudocode every
statement is described as a shape different
shapes for different kinds of statements.
If you want to take input, then you have to
describe that action using a parallelogram.
If you're going to do some computation, you
have to express that using a rectangle the
start symbol and end symbol the start and
end of any procedure in flowcharts they are
described by the ovals For example, this oval
in that oval normally the flowchart sequences
from top to down, but it is always good to
just print the arrows to describe the flow,
because in complicated flowcharts there are
there are loops there are if conditions there
are so many things. So it is good always to
describe the flow using using arrows. So,
now the question is flowchart or pseudocode
because flowchart also looks like a very cool
way of writing. expressing an algorithm and
pseudocode is also a way of expressing an
algorithm. Well, converting flowchart to actual
programming code is somewhat tedious, writing
a pseudocode beforehand, which is readable,
which is precise, concise, as well as unambiguous
then converting that pseudocode to code of
any programming language, that is not that
hard, that is simple in writing flowcharts
for very complicated problems is somewhat
tedious, because then it It also requires
another transition from flowchart to reactive
programming code. That's why writing pseudocode
is more feasible, if the goal eventually is
to convert that pseudocode to some core of
programming language. So, you can go with
flowcharts you can go with pseudocode either
one is fine, but more feasible way of expressing
algorithms is a pseudocode. That was just
a very simple example. I mean computing, computing
salary of an employee writing a procedure
for that. I mean, this is so simple, nobody
make your writing that kind of writing solution.
have this kind of problem as a as an algorithm
or as a pseudocode as a flowchart. But the
basic idea is, is is is the same, even if
you have a complicated problem if even if
you have a problem with maybe many more steps,
the idea is still the same. In the in the
next video, we will we will see a procedure
how to how to make tea for example, that might
that may look look to you funny, I mean, do
we really want do we really want to know the
procedure to make tea? Well, the idea is not
to learn how to make tea, the idea is to learn
how to express the solution of this problem
making tea that's a problem, the solution
of this for how to how to express solution
of that problem as as a pseudocode. And we
will see one more example of flowchart as
well. So hope to see you in the next video.
Okay. In the last video, we saw flowcharts
and pseudocode, we just took an example of
we took a very simple example computing salary
or pay of employee of a company given hours
and rate. And I also described weatherflow,
the the comparison between flowchart and pseudocode.
And I said that pseudocode is closer to the
core of some programming language, which eventually
we need, because eventually we need automation
of of a solution of a problem. And for that,
we need a code of the digit the code for the
solution, the general solution in some programming
language, so flowchart and pseudocode, and
then the core of some programming language
like Python,
it is somehow in sometimes handy to to break
the problem or to devise a general solution
of any problem for in first step in a flowchart
because that is more expressive, and more
generic, more general, maybe in a graphical
way. And then once the proof of concept is
clear, once it is clear that this is indeed
a general solution, it has no bugs inside
it has no errors, it will work always, then
we can take another step to convert that flowchart
to pseudocode. And then pseudocode can be
converted to the the code of any the code
in some programming language. But writing
pseudocode right away, I mean, from the very
beginning without flowcharts is also a common
practice. Either way, whichever way suits
you. In this particular video, I'm going to
talk about problem the problem is making tea.
You might be thinking, what are the different
instances of this problem I'm in making tea
is making tea. What what kind of different
instances are there? Well, one person may
be liking tea with, for example, 1.5 units
of sugar, whatever the units are, and another
person may want a tea with, let's say, two
units of sugar, one person maybe, maybe needing
a D with, for example, point five units of
milk, and another one, maybe a different units
of milk, and so on. So the procedure of making
tea should stay same. And the instances which
means the different people want tea in a different
kind of combination that may vary. So let's
let's like let's see a procedure first and
flowchart. And then in pseudocode, for for
making a tea, for making tea. So let's start
that that might look like that might look
you look to you a kind of funny kind of problem.
But that's a genuine problem. For example,
if you want to make tea, what is algorithm
for this? So first we start and then the first
step we do is we put teabag in a cup, that
might be a first step. You can argue should
this be a first step should that be the second
step and so on the sequence of By the way,
solving one problem, you can have multiple
algorithms for that. And do different algorithms
may just vary because of the sequence of statements
even if you have the same statements. So I'm
not talking about that the algorithm or the
general solution is unique. You can have multiple
different general solutions or procedures.
So for example, putting a teabag in a cup
that might be first step, or the first step
might be the boil, boil the water and pour
the water and pour the water in the cup and
then put the tea back. Both are fine, I mean
this way or that way. So let's start with
putting a tea bag in a cup. So that's an that's
an input. We take the tea bag from somewhere.
That's our input last time, I do You that
input is taken as parallelograms put a teabag
in a cup and then forget about that cup and
boil the water somewhere there is a water
I mean take the water from somewhere and boil
it and see if after let's say five or six
or seven time units whatever the time units
are, see if the water is boiled or not assume
that there is a test that tells you that the
water is boiled or not. So, there is a test
available to you. So, you apply that test
and check that the water is boiled or not
if it is not oil then keep on boiling. So
boil it again. And assume there is a procedure
of boiling of water in in in normal case,
boiling water is just happened by I mean keeping
the temperature high or putting that thing
putting the pot of water on fire or something
like so, but that that itself is a procedure.
So,
while the water again and boil the water again
check if the water is boiled if no then boil
it again. If not boil again then check if
no then boil it again this is called a loop
this is called a loop or repetition you are
doing the same kind of stuff again and again.
Until there is a particular condition that
is that is met. So in this case, the condition
is when while the water is not boil, keep
on doing the same procedure again and again.
This is called repetition or loop. So you
boil the water again, check the condition
if the condition is true, for example, the
water boil Yes, then come out. Then you're
then you can exit this loop and come out.
Then pour the water pour the water in in the
cup. Here we should hear we should describe
that is that the same cup or a different cup?
Well, this see you pick up here is acting
as as a placeholder where this tea bag and
the water is going in. So we have a cup, we
put teabag in it, then we put the boil water
in it, but before pouring the boiled water
in it. We just boiled the water. Okay, and
then after we have water in a cup and a tea
bag in a cup, what should we do next? We actually
we actually first test one sugar or need more
sugar? If yes, then then add sugar. So let's
apply some arrows. If yes, add them add sugar.
And then again ask do you need do you need
more sugar? Or one sugar now? Yes, add sugar.
One sugar. Yes, add sugar that is again a
loop that is again a loop while while the
while you want sugar. I mean you test that
the sugar is okay or not. Here you test that
the sugar is okay or not or whatever sugar
you need. If Is that okay or not? Until that
condition is not met, you keep on adding the
sugar, add a teaspoon again, then test out
a teaspoon that is again a loop or repetition.
Once the condition is met once you know then
exit this loop and ask what milk because some
people just take tea without milk. Maybe somebody
wants a milk maybe somebody don't. So want
milk? Yes. So add milk. So that's that's a
mistake this this loop should go there. There
right there. And this line shouldn't be there.
That's that's wrong. Add milk and then ask
what milk? Yes, admin, that's again a loop.
Once you exit the loop, then you ask need
to steer. Yes, steer, then ask again. This
line again shouldn't be there. So that that's
another loop. Once you exit this loop, then
the T is ready, you serve that D finish you're
done with the procedure. Now let's see the
same procedure in pseudocode program is the
keyword and that's what program name is program
make D what is a keyword put teabag in a cup
while water not while while is a key word,
while this is not while this condition is
not satisfied, keep on doing this. Whatever
written in while and while is is the body
of this repetition are called loop. So while
water is not boil, boil water. Then again
check water boiler not know what again. I'm
in keep on boiling. So this is repetition.
Once the water is boiled, which means this
condition is becomes false what not oil becomes
false so water boil, then you exit this loop,
you pour that water in cup, that's again a
key word, you in a cup, and then you ask,
okay, need sugar? Yes, add sugar, need sugar,
yes, add sugar. So you keep on doing this
until you don't need sugar anymore. So, that's
again a loop. So, so, you might be thinking
that why we are writing this add sugar and
this boil water to writer to this this why
we are really indenting this that style of
pseudocode to just display that this is inside
this this is this particular statement or
set of statements are called the body of the
loop and this end Oil should be here in this
alignment here in this line and so, there
is a there is a bug in this slide this should
be
here okay once this condition is false sugar
needed no then you can exit this loop and
you go here while milk needed yes add milk,
check again milk needed yes add milk milk
needed yes add milk. Once this condition becomes
false milk needed no then you can exit this
loop, you can just go to here. While latest
here need to steer steer D need to steer yes
sturdy he was there yesterday, once this condition
is false get out and your tea is ready Do
whatever you want to do. This example was
so simple, but it expresses a very powerful
tool in in the pseudocode as well as in flowcharts.
And that tool is sometimes called loop which
is there to repeat a particular procedure
whatever procedure you want to repeat again
and again to until there is a particular condition
that is met that is loop loop is there. So,
the The purpose of this slide is was just
to just to make you make you convinced and
make you comfortable with the pseudocode and
flowchart we will not be talking about flowcharts
any further from here on we will we will be
just talking about pseudocode in just one
or two more videos. And then we will be directly
going towards from we will be we will be comfortable
enough with pseudocode for solving certain
kinds of problems that we will then eventually
be moving from pseudocode to actual Python
code. And and I bet you I'm going to tell
you that the pseudocode in the next video
I'm going to explain that will be very, very
easily will be converted to the actual exact
Python code. So in the next video, we are
going to actually solve a problem of finding
out minimum value from a list of values, sometimes
called the searching problem, we're going
to solve it by first using pseudocode. And
then in a later video, we will see how to
write the actual Python code for that problem.
So hope to see you in the next video. Okay,
let's dive into real problem. Let's say you're
given, you're given a list of numbers, let's
say, let's say l is some list. with numbers,
let's say we define list by these, these square
brackets, let's say the list contains 23.
Let's say that's a value minus four, that
value is zero, that's a value 73. That's a
value, and maybe maybe minus 10. That's a
value, maybe 13. That's a value. So let's
just take an example that we have 123456 values
in a list. So and that list is basically we
took the list here as L and we just describe
that let's say the list is declared by or
expressed by the square brackets, and the
elements of the list, they are separated by
comma. That is just our convention for this
kind of problem for this problem just for
this code. And And I'm not talking about any
particular programming language yet. This
is just a list of numbers. And let's say we
want a procedure that finds out the minimum
value of any list. Well, first of all, why
this problem has multiple instances. Well,
we need to come up with a solution that works
for any list for example, if the list is if
the list has these six values, then the procedure
should find out the minimum In this list,
the minimum value in this list out of all
the values is minus 10.
Because minus 10 is smaller than every other
value. 23 is bigger minus four is smaller
than 23. Zero is bigger than minus four, because
the, the value with negative sign, it is smaller
with the value of a positive sign. But if
you have two values with negative signs, the
value with a bigger number, in terms of magnitude
is actually smaller in negative sense. So
if you compare minus four and minus 10 minus
10 is smaller. In minus in minus domain, in
positive domain, the result is different.
So I was talking about why this problem has
multiple instances, why you need a general
solution for that, that's less just go and
find out the minimum that is minus 10. Go
home happy? Well, we need a solution that
works for another list. Another list with
different numbers. And maybe different number
of numbers. Maybe in this list, we have six
numbers, another list may have 74 numbers,
another list may have 1 trillion numbers,
we want to come up with a procedure that always
finds out the minimum value in that list.
Obviously, the minimum value may repeat, I
mean, the minimum value may occur more than
once in a list. So what is a minimum value
rather than knowing how many times that occur,
what is the minimum value, that's a problem
finding out a minimum value, and we want to
find out, we want to come up with a procedure
that finds out the minimum value, regardless
of the list, whatever the list is, this procedure
should actually return or end up finding out
the minimum value. So, in this particular
case, again, for this particular example,
the minimum value is minus 10. And we will
take example of this list, and we will see
how to code a procedure for that. So but but
before starting this procedure, what kind
of things we really need to to, to write a
pseudocode. For this kind of problem, we may
start by writing that program, like in the
previous video, program name as search. And
then we take input or input list, then we
take input, the number of values in the list
the total number of values, and then we move
on as as we want to move on. But writing out
a procedure in terms of pseudocode, it is
always good to to avoid these input statements
inside the pseudocode. And always supply whatever
whatever needed, always supply the instance,
from outside and assume that the instance
is supplied and then just work on that instance.
Rather than reading the instance. Rather than
taking the values of instance, a particular
instance from inside the code, it is always
a good practice to, to, to supply the instance
from outside, so supply the list from somewhere,
and this n is really the size of the list.
In this particular case, let's say if this
is the list, then that list will be there,
supplied from somewhere, but we'll see how
to supply that. And this n value here, in
this particular case, the N value is six the
total number of values in the list 12345,
and six, these are six values. So it is a
good practice to rather than writing program
and then this, just write the name of the
problem you're going to solve in this particular
case the name is search minimum from list.
And then this particular we are talking about
this list l with total number of elements
as n whatever the values inside the L is we
do not know and and this n may take different
values, l can be different, this n can be
different for different instances. But it
is not a good practice to take input from
inside here. Then, one more convention is
that, let's say list of two represents the
second element in the list. In this particular
case, L of two is basically L of two is basically
the second element in the list, which is minus
four, L of let's say three is the third element
in this list, which is a zero, and so on.
So let's let's take a convention, that whenever
we want to access the elements of the lists,
whatever whenever you want to read the elements
from the list, we will read the element number
by giving the element number here let's say
whatever the if we write L of AI, that means
it means the ayat element of the list.
So, first we take a variable, we are assuming
here that the list is supplied to us the total
number of elements in the list is supplied
to us. So we first take the minimum value,
we, which we really want to compute the minimum
value we want to compute, but any list can
be supplied in this procedure. So what's the
procedure, the minimum value that we want
to compute, we just consider the very first
value of the list in this case, the very first
value is 23, we consider that is the minimum
value. Obviously, that is wrong, this is not
minimum value, minimum value may be somewhere
else, or maybe this one may be somewhere else,
but we are not sure that the first value in
the list is the minimum value. But let, let's
just hold on for a moment and move on. Let's
say the minimum value is this here, this is
called the assignment assignment. This min
value is a placeholder or a variable, and
I have assigned this value l one to it. Now,
from here onwards, the min value will be will
be will be having a value which is 23. In
this particular case, okay, so min value is
this, which is 23. Now, let's declare, let's
declare another variable, which is called
counter, we may need this counter. And let's
declare this with two, why we are declaring
this with two it will become clear later on.
So now we so min Valley right now, for this
particular list, the min value takes the value
23. So and counter takes the value two, these
are two things for these two variables. Now,
we apply a loop while counter is smaller than
n smaller equal to n. Remember the value of
n for this particular example is six, and
counter here is two. So because counter has
value two, while two is less than or equal
to six, first check whether this condition
is true or false, because if this condition
is true, then you will go to the body of the
loop, then this whole box will execute. If
this condition becomes false, then you will
exit the loop and we'll go out. So now counter
is to the so two is smaller or equal to six.
true false. That is true. So the condition
is to two is indeed smaller than or equal
to six, that is true. So we will go inside
to the box and see what happens. Then what
we will do, we will pick and pick a value
from at the index counter. Right now the counter
has value to L off counter means pick the
value, because the counter has value to pick
the second value, which is minus four and
pick that value minus four from the list,
pick that value and copy that value or assign
that value to a variable v. That's a new variable
we maybe needed somewhere okay. Previously
the min value which is a variable, it was
containing the very first value which is 23.
Now we have picked the second value the counter
value is two. So we have picked the second
value from the list, which is minus four.
Now we compare if the value now which is minus
four is that value smaller than our minimum
value. So far, the minimum value so far is
is 23. So minus four is smaller than 23. Yes,
the condition is true, if the condition is
true, we will go into this block, otherwise
we will go into this block. So right now the
condition is true. So we will go in this block
and minimum value will just be replaced by
the new value. And the new value right now
is minus four. So because a minus four is
smaller than 23, so we are here in this body,
the if condition becomes true, you're in this
body, and the minimum value becomes whatever
the value is in V and right for this example,
the value in V is minus four. Okay? So if
if if you go into the if condition, then you're
not going into the else part, either you're
going to F part or in the else part one of
them. Okay, so then we move back Oh, there's
a bug here we need to add the counter. We
need to increment the counter here after after
this. Before this. There is another statement
increment the counter. increment counter.
That's another statement increment counter.
So Now increment the counter after this if
part increment the counter, and the counter
will become three. Now, we will repeat the
procedure and check three is smaller than
six, yes, we will go inside, and we will pick
now the counter value is three, we will go
and pick the third entry. And now the third
entry will be in V, the V will now contain
zero. Previously it contained minus four now
it will contain zero min value is containing
minus four now, so zero is smaller than minus
four, no, if zero is smaller than minus four,
then do this. But zero is not smaller than
minus four, then go to the else part. And
as far as just saying just go on do nothing,
I mean don't do anything. So when you're here
don't do anything except if condition increment
the counter again. Now, you increment the
counter the counter value will become four
and the value add for is 73. First of all
check for is smaller equal to six Yes, we
will contain the value at index four which
is 7373 is smaller than minus four no do nothing
and given the counter check the if condition
check the while condition now counter will
be five five is smaller or equal to six Yes,
pick the fifth entry because country's fifth
the fifth entry is minus 10
minus 10 is smaller than minus four yes okay.
Replace min value with the new value. Now
the min value will contain minus 10 okay because
if has executed else will not execute, you
exit the if condition and then you increment
the counter the counter will become six. Now
six is smaller equal to six Yes, because six
is equal to six hence the condition is true.
Now, you go and pick the sixth entry which
is 13. Check 13 is smaller than minus 10 because
min value is containing minus 10. So far,
no that is false go to else condition, the
two else part just go on to nothing, increment
the counter, now the counter will become seven
and you go back and check the condition seven
is smaller equal to six false exit the loop.
Okay, exit the loop, go to this condition,
go to this statement. Now Now you're out of
the loop and return the min value. And see
the min value here is containing the actual
min value which is minus 10. So that's how
we search the minimum, this return is also
a keyword. So which means if we if we just
if we just if we just use that function, if
we if we just use that pseudocode with if
we just use that pseudocode for this different
kind of lists with with its sizes, whatever
the list, this is this was just one example
if we chain the list, the procedure will work
one one bug in in the code was the increment
counter statement was not there, it should
be there after the end F and before this end
while here. So this that was the pseudocode
of searching a minimum. In the next video
we are going to use this pseudocode and we
will we will see how to rearrange the values
of a list or sorting the values of lists such
that all the values that are smaller they
become earlier than the bigger values. And
the problem is called sorting. So in the in
the next video we are going to talk about
one more problem, very famous problem called
the sorting problem. And after that problem,
we will be going towards Python. Because after
that problem, you will be having a fairly
good idea how to solve a problem how to write
a pseudocode for a problem. And the way we
are writing the pseudocode is very close to
the actual Python code which will become so
clear to you. So hope to see you in the next
video. Okay, in the last video we talked about
we talked about this how to find out minimum
value from a list of values. And we came up
with an algorithm with name search men from
list. Here we have just made a little modification
that rather than just returning the minimum
value, we are also returning the position
of the minimum value in the list. So for example,
if the list is 17024, let's say in nine letter
that's our list. There are seven numbers in
the list, the minimum value is zero. so the
value the minimum value itself is zero, but
that appears in position three. So when when
this procedure will end, the min value will
contain zero and the ID x which is the position
at which the value the minimum value was achieved
that will contain three So, not only we are
not only we are finding out the minimum value,
but also we are finding out the position of
the minimum value.
This procedure, our pseudocode actually describes
a very simple, very simple concept, you consider
the very first value as a minimum value and
the very first position as a position of the
minimum value, and then traverse the list
element by element and, and see if you find
any value that is smaller than the minimum
value so far, if that is found, then replace
your minimum value with the new minimum value
and update your position number. And then
keep on moving till the end of the list. So,
so that's what, that's the concept behind
the behind this algorithm searching minimum
from the list. And to traverse the list we
use this loop while loop. So next we solve
a problem called sorting problem very, very
famous problem in computer science. So the
problem really is let's say we have a list,
let's say 14035. And seven, let's say and
the sorted order the ascending sorted order
is the order in which the list is presented
so that the minimum value occurs first, then
the second minimum, then the third minimum,
and so on. So the sorted order for this particular
list will be this, so this is the result,
this should be the result of this sorting
procedure. So let's see how can we solve this
problem, we named this algorithm as sorted
list and sorted list contains this L. In this
particular case, the L is simply this. And
this n is the size of the list. In this particular
case, the size of the list is six, so six,
and right now l two is empty. So although
we have to populate l two, but right now it
is empty. And counter again, we initialize
the counter with one. And as as long as the
Conqueror is smaller than six, we keep on
we keep on moving inside this, this block,
that's the that's the body of the loop. So
what we do is we pass the list and the size
of the list. And we use the previous algorithm
to find out the minimum from the list. So
the minimum from the list will be found as
zero and its position will be found as three.
So min value will contain zero, and Id x will
contain three, then what we do, we pick this
minimum value and insert in L two l two was
initially empty. So we insert in L two, we
insert the minimum value, which is zero so
far. And then just in the original list l
we delete the value at the position index.
So for example, the index position is three,
so we delete this particular value. So what
we really do is we delete this value, we delete
this particular value. And the list now becomes
with size 1234 and five, so what we do is
we decrement the size with with one and then
we move on now the country is one again, the
N value rather than six. Now the N value is
five, so one is smaller than five, but the
list has no zero now in it because it was
deleted, we searched the minimum again, and
we insert the minimum in the list. Now the
minimum will be one in the new list. And we
delete that value from the list. And we decrement
the size we keep on moving, eventually the
list l two will be populated like so. And
once. And once this value of n becomes negative,
which is minus one with we will exit the loop
and we will return the sorted list. But see
how this sorting procedure actually uses the
algorithm that we that we defined in in RPB
previous video.
I'm not talking about that this kind of sorting
algorithm is the most famous sorting algorithm.
There are efficient algorithms very great
kind of algorithms for sorting. But the idea
here is not to actually teach sorting the
idea here to actually come up with the pseudocode
for this sorting problem. And also to show
you how you can use the pseudocode how you
can use existing pseudo cores as as instructions
in in other pseudo codes. So that's all about
problem solving. If you really understand
the selection sort and all that procedure
really well, you're actually very good in
problem solving, at least the problem solving
is that we encounter in the logic that we
need to solve different kinds of problems
in computer science. In the next video, I'm
going to actually convert these pseudo codes
to Python codes. What do you need? Doo doo
doo, right this sortlist procedure in actual
python programming language, and how will
you change the search minimum from list in
actual python programming language, we will
see the Python details bit by bit in detail,
starting from right zero and ending at the
very high details of Python. So, in the next
video, I will just be showing you how to convert
this code. But when we will start learning
Python, we will start from zero and we will
see each and everything of, of Python in in
detail. So don't worry. In the next video,
if you see, I mean, things like lengthy chords
in a very beginning, these are just because
we have arrived at a pseudo code. It is very,
I'm just want to show you how the pseudo codes
which are very across expressible, how they
can be easily converted to Python programming,
just to show you the power of and simplicity
of Python programming language. So in the
next video, I'll be converting these pseudo
codes to Python code actual programming code.
So hope to see you in the in the next video.
Okay, in the previous video, we just get a
flavor of problem solving by using this selection
sort called the sorting procedure. The idea
was just to use this procedure to solve this
kind of problem. And we saw in detail, not
in that detail, we just just brushed up but
we saw how to write a pseudocode for solving
a problem of sorting, which requires actually
a list to be sorting in ascending order. For
example, in this video, I'm going to convert
first this code search minimum from list,
you see that code, you know that code completely,
we're first going to convert that code in
Python code, and then we will convert this
code in Python code. So see step by step,
what changes are there. First of all, in Python
that we will see in detail. When you define
procedures, different kinds of procedures,
they are called functions in Python. And rather
than writing this, we have to write a def
statement before it and then whatever name
we want to write out, the rest of the thing
stays the same, except at the very end, we
have to write a colon. That's the syntax of
Python. So the changes from here to here is
a def statement, which defines that is used
for defining def for define. And then at the
end, we write a colon. Next thing that we
will see in detail, don't worry if you
if you're if you just see that why we're messing
up with lips. So early, we will see that things
in detail. But just to compare the in pseudocode.
Normally the lists are indexed the indexes
of the list start from one. But in Python
programming language, the first index of the
list usually starts from zero. So they are
the minimum value was the first value of the
list here, the first value is actually the
index and Python is zero, rest of the things
are same, you declare the variable as in pseudocode.
The same goes exactly in Python. They're the
because the index was one. And so the counter
was one more than whatever the index was.
Here, the counter is simply one, we need to
right here ID x ID x equals to zero that we
just missed. In the previous the ID x is one,
so here the ID x is zero, that's okay. Okay,
then next, we write while counter is less
or equal to n. Same thing while counter is
less or equal to n here. So here we just write
the, the colon at the end, we might have written
this equal sign here, this equal sign, we
just missed the equal sign the equal sign
is there. So now, but see that see the difference
here, the violet goes that way, here we have
a colon at the end, rest of the things are
exactly the same. Now, v is equal to L counter
v is equal to L counter the same thing if
v is less than the minimum value, same thing
if v is less than the minimum value in the
pseudocode. Python is exactly the same. Just
see the colon at the end, we have colon at
the end of the while statement, we have colon
at the end of the definition, we have colon
at the end of the if statement. The other
statement in pseudocode. In Python exactly
the same. Now, in pseudocode, we have l statement.
In Python, we have l statement. If we want
to write an else statement, we have write
a colon at the end of that. Then in Python
in pseudocode, we have a past statement Python
in our past statement, same things in pseudocode.
We have n def, just to describe that this
f ends. In Python, everything is described
by the indentation style. So if this indentation
goes on, if we have If you're here, then this
is goes if this if goes out, so we need not
write ends every day. Similarly, the vile
body has this indentation style, this is all
the while body, whatever that is, that is
earlier than this is not in the wild body.
So, rather than writing the tokens and while
and if the Python handles everything using
indentation, so no need of end if no need
of end while Oh, we haven't, right, we haven't
written a counter here. So we have to write
a counter plus plus here, so counter. So the
same statement, we missed this statement in
the Python code. So the same statement, exactly
the same statement goes here. That's it. The
rest of the story is same, we do not need
an end search here. The goal here is to show
that the pseudocode is, I mean, the way you
write the pseudo codes, they are they're highly,
they highly resemble with the actual code
in Python, Python is that expressive Python
is very, very high level language. I mean,
the way the you the way you think the problem
in the pseudocode, the actual Python code
is much similar to it. So learning the Python
is very, very simple. The simplicity of Python
is really a great property of Python. And
that's one big reason of popularity of, of
Python. Now the return statement is same and
everything is same, then we move toward the
sorting. Again, we have sortlist, we have
to write the Define def define, and then we
have this colon out there, we have to write
the colon there, then let's do is defined
like empty, it's empty in Python as well.
Counter starts from zero, because they are
the list starts from index one. In Python,
the list starts from zero, so we are at zero,
while same as this one. Here we have this
colon, maybe, maybe an equal sign, maybe an
equal sign should appear here. I guess we
are missing an equal sign. But either way,
the code is more or less the same rest this
statement exactly same as this statement,
we have insert in L two, here, we write a
band append function, I'm in Python, here
with ID lead this in Python, we have a Dell
statement, rest of the story is exactly same.
So you see converting pseudocode to Python
code is, is way more easier. This is this
is not a this is not a formal introduction
to Python. I mean, the the goal here in this
video in these kind of session videos is just
to introduce you with problem solving. But
I I found this, I mean, I found this beneficial
to show you that the pseudocode actually resembles
to the actual Python code a lot, although
we will be dealing with variables lists, while
loops, if conditions, all these kind of stuff
in them in a in a big and huge detail. When
we in the upcoming videos, when we will introduce
the Python syntax and variables and all that
kind of stuff. Actually, you will be mastering
each and everything in Python. And, and further,
you may not write these lengthy chords to
do stuff in Python, I mean, the whole dad
thing is just you write l dot sort and you're
done. I mean, you need not write a lot of
lines of codes in Python. Here, I just here
I just showed you that if you have a procedure,
you can, if you have a pseudocode it looks
like much like the same as Python, which,
which actually tells you the expressive power
of Python and simplicity of Python, and how
it is closer to what you think. But the actual
problem solving
in Python does not require so many lines of
codes, I mean, there are so many functions,
so many powerful procedures. For those you
just write one line and a huge amount of work
is done for you. And there are very good one
liners for Python I mean in for for for for
programming in Python, you did not write a
lot of lines of code to do some stuff. I mean
a few lines of code even a single line of
code does a lot for you. And for that you
need to know the features of Python the feature
of the features and the different kinds of
syntax and features and libraries and the
packages and what what is available with Python.
I tell you almost each and everything is available
just you need to know what is available. Once
you know the what what what what are the things
that are available. You need not to write
lengthy codes you need now to build a lot
of logic on yourself. Things are prepared,
they're waiting for you, you just have to
figure them out what are these things to do
what what kind of features are there in Python,
if you know that you are done. So you need
not to be writing these kinds of codes and
lengthy kind of codes. Although knowing that
all knowing that is a is a is a huge advantage,
but doing a bigger and bigger and bigger stuff.
Python will give you a lot of features a lot
of functionality that you need not to go into,
and you need not write a lot of code for it.
And that's the second power of Python. One
is simplicity. Second, it gives you a lot
of features a lot of functionality, a lot
of built in stuff ready for you, you want
to do something, it will be probably there
in Python, you need to know where it is. And
for that we have whole future series on Python
to know Python each and every step in Python,
and to know important packages in Python.
Because knowing important packages and knowing
how to code in Python will save a lot of time
for you. So spending some time on learning
Python will be saving a lot of your time.
To solve the actual pure problem. Whatever
problems you're doing, you're going to solve.
And Python is a real programming language
granting programming language, knowing this
language is almost enough. So hope to see
you in in the next videos where we will start
Python from exactly zero. And we will see
each and everything of Python in detail. Hope
to see you in the next video. If you're new
to data science, you may stuck in choosing
the best language for data science. And in
this video, I'm going to I'm going to talk
about Python, which is the greatest language
so far for data science. To explain the features
of Python, let me first go back to a little
bit history of Python from where it started.
It basically starts in 1980s. It was introduced
first in 1980s. But with constant improvements
and a lot of bug fixes. It was officially
launched in 1989. Nine years later. It was
created by Guido van Rossum and it is open
source which means it is accessible to everyone.
Even though it's open source. It can be used
for commercial purpose. The main goal of Python
was to keep the code easier to use and understand.
Its huge library enables data scientists to
work faster with the ready to use tools it
is dynamically typed. So the variables that
you are defined that you are defining that
they are defined automatically, you need not
to set the type whatever the contents in bring
in, the type will be defined automatically.
It is more readable and uses lesser code to
perform the same task as compared to other
programming languages. It is flexible, portable,
and can run on any platform easily. It is
scalable, and can be integrated with other
third party software easy. Python programming
is easy to use, and has a simple and fast
learning curve. new data scientist can easily
understand Python, but it's easy to use syntax
and better readability. So so that's what
this point is basically it's it's really a
beginner friendly if you if you're new to
programming. Well, Python offers you a very
easy environment to go on. It also provides
plenty of data processing tools that help
in better handling the data. Python is important
for data scientists, because it provides a
vast variety of applications used in data
science, it also provides more flexibility
in the field of machine learning and deep
learning.
It has, it has a lot of packages like TensorFlow,
Kara's tiano. That is helping data scientists
to develop specifically the trending deep
learning algorithms very, very quickly. So
basically, the sport, the sport of machine
learning and deep learning is huge in Python.
That's huge. As, as is the case with many
other programming languages? It's available
libraries that lead to Python success around
around 72,000 available packages. In Python
package index, sometimes called by pi, Python.
Why? Python package index by by around 72,000
packages are available and they are good Constantly.
So huge number of packages mature packages
are available. It is free open source and
consequently, any Can anyone can write a library
package to extend its functionality. Data
Science has become an early beneficiary of
these particularly ponders The Big Daddy of
all of them. The other great thing about Python
is there are millions of users who are happy
to offer advice or suggestions. When you get
stuck in something, chances are someone else
has been stuck there first. So a lot of community
is there, a lot of packages are there, it's
open source it it's easy to use, it's easy
to learn. It's simple, it's readable, more
close to human language, it's high level language,
you code less you do more, I mean, you write
a very few lines of codes, and you achieve
a lot of work. So, I mean, I've spoken a lot
of verbs here, too, too. I mean, explain that
Python really is best suited language for
data science. But let me let me introduce
you some statistics about Python, the popularity
of Python with respect to big with respect
to its use, and with respect to the job opportunities
that are there in Python. So for example,
if you see this chart, in the ranking of top
10, languages, Python stays at the top. So
that's the latest statistic, collected in
2019, February 2019. And out of the out of
the total share of the languages, I mean,
around 26%, just goes for Python, and the
trend is moving up, which means the people
are more interested in Python, I mean, the
trend of using Python is getting larger and
larger, as compared to several other languages
like Java, JavaScript, C, sharp, bhB, C, our
objective c, swift and MATLAB. I mean, many
of them are used for data science, but Python
stays at the top. I mean, this is that popular
language. And further, if you see, for example,
the job opportunities in Python so so that
says, I'm in a different companies like Facebook,
Julia, and I'm in Google and several different
companies. This actually graph shows from
2014 onwards, that the job opportunities and
job postings are in different languages are
at what amount, and you can see the graph
of Python, although starting a bit low, but
then stays up and stays up, which means the
80 if you see the numbers 85% of the total
jobs, there are just for Python. And not only,
I mean, Python is not just for data science,
it's a general purpose programming language,
it's open source, it can be it can be used
to perform any kind of task for embedded programming
for, uh, for for posting, I mean, codes or
embedding code on Raspberry Pi for web development
and whatnot. You can you can, you can do the
desktop development on it, you can use the
web developer knowledge you can use the data
science, I mean, I mean, this is general purpose
programming language. In other disciplines
do it is performing very well. But data science
for data science, it is almost the default
language today.
So, I mean, if you're going to learn data
science, really, we need Python. I mean, Python
really is the choice, the default choice,
and we need it. And in this particular course,
we are going to, we are going to introduce
Python to you with all aspects, I mean, we
will start from the very beginning level.
And we will gradually move towards the very
advanced programming in Python, including
the introduction to the data science packages,
like pandas and matplotlib, for visualizations,
and NumPy, for handling numeric data and stuff
like so. So, in this particular course, we
are really going to teach you Python, and
we are not assuming you have any programming
experience before. So and this is one plus
of Python. I mean, whether you're an engineer,
you're coming from health sciences, you're
coming from biology, you're coming from arts,
humanities, or from wherever. Python is something
that is very easy to get hands on. So if you're
not assuming that you have any programming
background, you have any data science background
nothing. So we will start from the zero and
And we will gradually move to 200. So, and
including the introduction to the data science
packages. So Python is the best, it is a default.
If you're going to work in data science, Python
is the default. And we are going to, we're
going to introduce you Python from the very
beginning to the very professional. So hope
to see you in this course. Okay, before actually
discussing the best ID for Python, and particularly
for data science, let's first discuss what
an ID he is, as you start your coding journey,
many of you prefer coding in a text editor
maybe like notepad plus plus, where you write
the code and then open a terminal window to
execute your code. When there is an error
detected in your code, you switch back to
the text editor, correct your errors, typos
and run the code again in the terminal, everything
is fine. Typically, for large scale problems,
however, you not only have to code but you
also need to make sure your code works in
all scenarios, which means you also need a
testing module. Many times you have multiple
coding and testing files, and switching between
editor and terminal often becomes both confusing
and efficient. So, an environment is needed,
where you can write you can run and play with
your code all at one place. So the one that
provides you with the capability of not just
coding, not just writing the code, but but
also testing your code, running your code
highlighting your syntax, bracket matching,
auto completion, debugging your code, code
suggestions, and and many more features. That
is called an ID II or integrated development
environment. Now, there are several ID is
for different languages for for Python, there
are several ideas for example, Jupyter Notebook
is an ID IE by charm is an ID IE spider is
an IP ID and thought cannot be whim atom and
there are a lot more there are several of
them. Now the question is for data science,
in particular, what Id E is is the best or
are what people suggest to be the best. So
before actually showing you the statistics
that which one is the best before actually
showing you the actual numbers, the statistical
numbers that shows which one is better, what
are the other let me just go through a few
of them few of it ease and their features
and stuff. And then we will move to move to
statistics and some numbers that will show
that which one is better over the other. So
let me start with with this Jupyter Notebook.
For the past couple of years Jupyter Notebook
has been gaining a lot of popularity in terms
of coding and debugging. notebooks have been
redefining the concepts of an ID E and are
adding more and more features on to it. Jupiter
was introduced in 2014 after its predecessor
ipython and from that date, it is really considered
to be a bless in the coding community.
Jupiter stands for I'm in some people say
Jupiter stand for Giulia Python r but that
I come in that acronym does not mean just
this. I mean Jupyter Notebook today is supporting
more than Giulia, Python and R and by the
way, this Giulia Python, R and R all these
are open source languages for and they are
best suited for data science. This Jupyter
Notebook, it has markdown editor. It allows
you to write HTML code, it allows you to write
latex in it. I'm in a lot more. Further this
Jupyter Notebook. It's a web application based
server client structure, which is easy to
use and allows you to create, analyze, and
manipulate documents. And all these documents
are in the form of notebooks. Since it's a
web web interface, it can integrate with many
of the existing web libraries. For example,
for data visualization. Jupiter has so many
functionalities you can write formula using
labtech run a Python code and visualization.
For example, a raw audio signal using matplotlib
plotting library, all in the same notebook.
Jupyter Notebook is not just an idea he but
it's widely used and an educational tool for
presentation and even for writing blogs. You
can export your notebook from iPython Notebook
formats to PDF or to HTML or even to.py, which
is the Python file. The user interface of
Jupiter makes it a favorite tool, especially
amongst the data science community. And one
plus of this Jupiter is, it's it's very quick
to start, I mean, very easy and very quick
to start, I mean, not much rocket science
to write your first goal, you want to write
your HelloWorld it's very, very quick. And
you're better to go and do that. By charm,
if I discuss pi charm, however, if I discuss
some of its properties, and let me just discuss,
first that the pipe the PI charm is by the
company JetBrains. And if you have never used
japin JetBrains other IDs like Java ID, then
running your first code successfully can eat
up a little bit of your time, actually, a
large amount of your time maybe such as I
mean, setting an interpreter by charm. By
charm, however, is, is much better for, for
working with multiple scripts, handling multiple
files and linking them together and huge large
scale coding products. The good thing about
Python is it supports Anaconda. And as a result,
all the packages that fall under Anaconda
are supported by char pi charm as well. And
those packages in including NumPy, Sai, pi
matplotlib, and so on. Just like other IDE
ease pi charm has a powerful debugger. With
a graphical interface. It offers jet integration,
it has skills, shell terminal and worryin
control system. Python, it is customizable,
which allows you to choose between different
themes, color schemes, and key binding and
whatnot. Additionally, Python lets you add
plugins for non pythonic files. And these
plugins take care of indentation highlighting
the errors and keywords just on the fly. So
Python is also providing I mean, a huge support
for coding Python. But, I mean, the one bad
thing about Python, which is not that bad,
but one bad thing is it is memory intensive.
It eats up a lot of memory. It's a heavy thing.
And secondly, I mean getting getting getting
started with PI charm is not that quick. I
mean, it takes a lot of time to just go with
that. Spider however, is a lightweight, open
source ID Oh by the way, this by but this
by charm is is is not I mean it has Professional
Edition and and Community Edition and it does
not open source completely. Spider however,
is a lightweight open source, ie that comes
pre installed with Anaconda. And it was built
mainly for data science practitioners and
engineers. Its look and feel is much like
MATLAB. So if you're a MATLAB programmer,
if you've used MATLAB before, you switch to
Spyder and you get a mean much look and feel
the same cannot be by the way the unthought
cannot be also has roughly the same look and
feel as MATLAB
So, but spider was built for data science
community, it is integrated with essential
data centric libraries like NumPy, Sai, pi,
matplotlib, pandas, ipython, and whatnot.
The built in capabilities can be extended
further by plugins and API's Spyder contains
features like text editor with syntax highlighting
code completion, static code analysis, debugging
variable exploring, it also has profiler that
recursively determines the runtime and number
of calls for every function and methods call
in a file. And I mean, there's no thought
cannot be there is a vendor's atom there are
a whole lot of it is just for Python language.
But But the question really is being a data
scientist, which one is which one should you
choose being a beginner? which one should
you choose? Even even for professionals, if
you want to stay in data science, which ID
he will you prefer over the other? I mean,
there are so many of them. I have just described
three or four of them. So let's see some stats
based on popularity of different IDs for data
science, and then decide which one is better
over the other. So for example, this data
this this analysis, that the chart I'm showing
here, this analysis by was was done by Katie
nuggets and The link for that and it shows
that the most popular Python editors till
December 2018 and you can see that the Jupiter
is at the top, the second is pi charm, then
spider then Visual Studio code and sublime
tags, then add on atom women there are so
many others, but Jupiter is at the top and
this is for I mean, these all are listed with
respect to the data science community. So
in the data science community which Python
ID he is best over the other and, and Jupiter
Jupiter is at the top I mean it is it is way
out. And one reason to this is its simplicity.
It's it's supporting to so many different
formats. It's it makes an interactive document
it makes it makes a web page that is interactive,
you can just change the code you can make
another web page and so on. You can you can
run it on a local system you can run it an
online survey system and whatnot I mean it
has so much flexibility and very quick start
and easy to use. If you for example see the
popularity of Python IDs with respect to the
employment then then you can see overall the
the Jupiter has been a winner as compared
to pi charm spider also your code and sublime
if you see company or self employed still
the Jupiter is V out it has been if you see
for in a student perspective, Jupiter is the
choice. If you go to academia or university,
Jupiter is the choice if you are working with
government or nonprofit Jupiter is the choice
I'm in Jupiter is I mean Jupiter is kind of
outlier it is it is staying at the top everywhere.
Further if you if you analyze the popularity
of Python, it is with respect regions for
example, again, overall, Jupiter is a winner.
If you see US or Canada Jupiter's most popular
mostly used Europe, Jupiter is the winner
Asia, Jupiter is the winner, America use Jupiter
sevinor effect Africa and Middle East Jupiter,
Australia, New Zealand Jupiter. I mean, these
numbers are suggesting that Jupiter is is
at the top, not just at the top. It's easy,
I mean, and maybe that's one reason why Jupiter
stands on the top for the data science. So
these numbers and these all statistics suggest
that we should use Jupyter Notebook for Python.
And we will be doing that. In fact, for this
particular course we'll be working on Jupiter
for all kinds of coding. And in the in the
next video, I will be just showing you how
to install
Jupiter environment how to install basically
Python and how to run Jupiter for the first
time from it. So I hope to see you in the
next video. Okay, in this video, I will show
you how to install Python. There are multiple
ways of installing Python you can go to python.org
and install Python from there I would recommend
to use Anaconda distribution it has Python
it has a lot of packages pre installed it
has Jupyter Notebook as well. So installing
through Anaconda is easier as well. So if
for example if you are working on a Windows
system you should download the executable
for Windows we will be working with Python
three rather than Python two. So you should
be installing you should be downloading Python
three point whatever the latest version is.
Further if your system is 64 bit you should
be installing 64 bit version otherwise you
will be installing 32 bit version. So let's
say you have downloaded the executable file
for Windows then after the download you just
from that xe file and follow the steps and
you'll be able to install Anaconda once the
Anaconda is installed then in the search bar
you just type Anaconda prompt and the Anaconda
prompt kind of symbol that my mouse is pointing
at this will appear in front of you, you just
run it you will see a command prompt like
so. Then in that just type Jupyter Notebook
and press enter and you will be having Jupiter
running in front of you. Let me let me show
you that on my on my system. How to do that.
Let's see. For example, this is my search
bar. Let me type and conda prompt so this
is the Anaconda prompt. So if I click it,
it runs then I just typed for example, Jupiter
note book Then I just press enter. For the
first time it will take some seconds to run.
So let's wait for it. So yes, it runs and
it will show you kind of browser in front
of you. And that's what the Jupiter into interface
is. We will see then how from this Jupiter
how to write the code how to make the code
files and stuff but that's how from Anaconda
installing after installing Anaconda that's
how you will launch the Jupiter. So this is
that easy, no problem. Then, for example,
you can install you can install Python if
you're working on Linux and just download
the version for Linux. And then rather than
For example, let's say your your your file
is downloaded in the Downloads folder then
run this command bash and this.sh that's the
file name. The installer prompts in order
to continue installation process this I'm
in these kinds of commands will will appear
Press Enter to Continue then press Yes, and
the installer will finish with the thanks
message. After that, you just go to downloads
folder and type Jupyter Notebook and the Jupyter
Notebook. interface the browser based interface
will appear in front of you. You can have
if you're if you're working on Mac, you can
you can in you can download the Anaconda distribution
for Mac, then you'll find an anaconda Anaconda
navigator, the launchpad you can launch that
and then just click there's a Jupiter icon
in front of you just press the Launch button
and you'll be having your Jupiter running
in front of you. So in this video, we just
talked about how to install Python. If you
install Python using Anaconda you will be
having Jupyter Notebook as well. In the next
video, we will see how to actually use that
Jupyter Notebook interface for example, I
work on Windows, so I'll be having this kind
of interface although the interface looks
like same because it's a browser based web
based interface. In the next video, I will
show you how to get comfortable with Jupiter
and we will be also writing our first HelloWorld
program in Python. So hope to see you in the
next video. Okay, so in this video, I will
show you
how to write the first program in Python basically
the HelloWorld program. Before that, in the
previous video, I show you I showed you how
to launch Jupyter Notebook. So once you launch
Jupyter Notebook, whether you are working
on Windows, whether you're working on Linux
or Mac, whatever, when you will launch the
Jupyter Notebook, you will see this web based
interface. And here you are in the right corner
you can see the button new, you just click
it, you will select Python three, and you
will see a beautiful interface in front of
you that will allow you to go here, there
are a lot of file edit view there are a lot
of parents kernel and a lot of controls here
we will see them as we move on. But this is
how you this is this is what the coding environment
is this is kind of editor as well as I mean
this is complete, ie interface in front of
you. So let's see this interface a little
bit. Step by step at least the controls that
that we need. First of all, you are seeing
where my cursor is moving. That's the file
name or the notebook name. You can change
the notebook name or you can just write for
example. Whatever the name of the notebook
you want, for example, mastering by Thorne
for
beginners. Okay, so let's say that you're
mastering Python, let's say let's say zero
to hero, maybe. So let's say this is your
filing, you just create that file and you'll
see this mastering Python zero to hero that
file is created with this file is renamed.
Second. This is a cell in which you are going
to type your code. The code, I mean, the two
modes of writing is one is you can write the
Python code. Another way is you can write
the markdown. The markdown is important in
in a way that if you want to describe your
code, if you want to write other stuff other
than Python code, you can use these markdown
cells and they We will be helping you. For
example, if I select this markdown, and I
just select this markdown, and I type here,
for example,
this is by THON directorial. And then I press
Shift Enter, it will appear as a heading.
And a new cell will be graded down. This is
also a cell. But this is a markdown cell.
As you can see, now in this cell, that's a
code cell, you can switch a cell from code
to markdown by just pressing an escape key,
when you press an escape key, you will see
the color will change here, you can press
Escape key, then if you press M, it will change
to markdown. And if you press Y, it will change
to a code cell. There are several I mean shortcuts
that are available keyboard shortcuts, if
you if you just see, if you go to help and
see this keyboard shortcuts, there are several
shortcuts that will be available in front
of us. For example, if you press escape, and
then press F, you can do the Find and Replace
operation. And if you press enter, then that
will go into Edit Edit Mode, if that's important,
if you press Shift, enter, the cell will run
and the new the cursor will go into the new
cell. And there are a lot of controls you
should be seeing most of them, I mean, getting
a good grip on these controls will help you
moving in this Jupyter Notebook very quickly.
So for example, this is a Python tutorial
that's a markdown cell, you can also create
this, this cell also as a markdown cell. And
then you can type here for example. This is
our first program in Python. It there it is
just started here, for example, and it just
appears like like a description. And again,
a new cell is created down and there you can
write your code. So let's write the first
Python code HelloWorld. So first of all, you
will write Brent Brent command will allow
you to print anything on the screen. brantas
says double codes, starts ends. And in the
double code, you write whatever you want to
be printed on the screen, for example. Hello,
world.
And once you have written that code, just
press Shift and enter, and this code will
execute in front of you. So that's HelloWorld
printed in front of you. And that's our first
program, I mean, writing the very first program
in Jupyter Notebook. is is that easy. Not
only that, this Jupyter Notebook will be created,
you can you can just I mean describe anything,
you can write the headings, you can write
HTML in it, you can write math, using lattic.
And for example, let me let me write lattic,
or mat in front of you just just let's say
you're making a notebook that requires some
mathematics in it. And it allows you to write
mathematics as well. For example, A equals
B plus C, Shift Enter, and that appears like
a mathematical equation, not just this, you
can write very complicated equations. I mean,
and and, and this whole notebook will contain
your descriptions in terms of HTML or latech,
or descriptions, and code and all that mixed
up, whatever. And at the end, you will, you
can, you can just download this. You can just
download this, this notebook, as if you want
a PDF file PDF file. If you want a notebook
file, it's an output file if you want to latech
if you want just a Python file if you want
slides, for example. I mean, you can download
the same thing as slides. It will make slides
for you. So there are a lot of ways of using
this notebook. And that's a ready made document.
I mean, you end coding, the document is ready
for you. So this notebook is really, really
powerful Jupyter Notebook and coding in it
is not just the coding. I mean, it is Preparing
a document. If you want to prepare a document,
you want to describe anything you want to
add images, and at the end of the day, it
will be an HTML document for you. It can be
shared on web. I mean, it's ready. Nothing
we we want to further finish it. So that was
our HelloWorld program in Python. We will
continue to build this byte mastering Python
zero to hero notebook, we will continue coding
in that we will describe the headings we will
write the markdown cells and all that stuff.
And we will at the end of this course, you
will be having one notebook with all kinds
of descriptions and code in it. You can use
that notebook afterwards, we will be building
well one notebook, one complete notebook for
Python. So that's about it. That's the hello
world. In the next video, we will see how
to what are what are the constructs in in
Python, what are variables and other stuff.
But before that, I also wanted to show that
this notebook is an enhanced worryin are the
upgraded version of ipython shell. And I also
want to show you ipython shell as well. So
in the next video, we will just see the ipython
shell and we will see how can we how can we
view Python as just as a calculator by using
ipython shell. So hope to see you in the next
video. Okay, so in this particular video,
I'm going to show you the ipython shell just
open up the Anaconda prompt as as before,
like you want to open a Jupyter Notebook,
then you just type here Jupyter Notebook.
And you will be you will be in the in the
notebook word Jupyter Notebook word. But if
you just type in ipython and press enter,
then a prompt is open for you in a colored
way. And this is perfectly fine to write any
kind of Python code in here. Actually, the
Jupyter Notebook is more enhanced and more
featured the use of ipython. Basically everything
that I bought, that is there in ipython is
there in Jupyter Notebook as well. But it
has more features more documentation and stuff.
So for example, if I just write a Python code
here,
hello world, let's say it will work in ipython
shell as well. But remember, previously in
in Jupyter Notebook, we type Shift Enter to
run a particular command here, we just press
enter and everything will work. If you want
to clear the screen here, whatever the whatever
we typed here, if you want to clear that,
just press Ctrl l if you're on Windows Ctrl
l will work on Windows. Now ipython is just
like, you can use the Python in this particular
shell just like a calculator, for example,
you want to plus three, press enter, that's
five, let's say it's nine multiplied by seven,
the answer is 63. You can write a complicated
statement as well, for example, 45 minus eight
is static, or multiplication, static is achieved
by multiplication is achieved by a static
symbol seven. And then you can have this minus
then divided by two and just press Enter.
And that's the answer 16.0. If for example,
by the way, I have just press the up arrow
key and last command just appears. I have
pressed up arrow key again. And the second
last command appears. I press the up arrow
key again and the third last command appears
and now I'm pressing the down arrow keys.
So for example this and you may have whatever
the result is, you may have that multiplied
by 10 and minus or or maybe plus plus 15.
So the result is minus 145, and so on. So
this Python ipython shell, you can write very
complicated are almost I mean, the complete
Python coding can be written in ipython shell.
And you can use this shell just for a calculator.
Now let let's see, for example, you you compute
this result, let's say 45 minus 45 minus nine
and let's say you compute this result, whatever
the result is, and you save that result in
a symbol, let me call that symbol as a variable.
In here the variable is So let's say you save
that in a, and then you have another variable,
let's say B, and three static 45, or maybe
three steric 2.6, that is saved in B. Now,
you have you have done this particular calculation,
you know that 45 minus nine is in a, the result
is in a, and then you have this particular
result that is in B. And now, you just want
to add the two results together, and you want
to print the
what what normal calculators does not have
the support of saving the results and reusing
them. But here in Python, even if you just
want to use the Python, just as a calculator,
you can declare as many variables as you can
and you can save the previous results, you
can retrieve the previous results. And you
can use the previous results, save new results
and so on. These kind of symbols that are
used to save the results, and then they can
be just used afterwards, these are called
variables. And our next video will be on variables,
what are these variables, what are the types,
what kind of variables the Python supports
one way or the other, if you want to go beyond
calculators, you need certain results to be
saved and retrieved retrieved afterwards.
And the variables are are the constructs the
variables are the features that actually do
that. So the calculator is fine, you can use
this ipython shell just as a calculator. But
if you want to do interesting programming,
complicated programs, I mean, you want to
achieve a task that involves much more calculations
one way or the other, you have to save certain
results in somewhere. And then you have to
combine the results together because the longer
problems in normally are broken up into smaller
piece of problems. And each smaller problem
has a result that should be saved somewhere
and afterwards the several results they should
be combined to achieve the result that we
are after. So these variables are required
if you are going to do some interesting or
complicated calculations or computations.
So you, by the way before, before having these
Jupyter Notebooks spit out just the enhanced
version of this ipython shell, the iPod ipython
shell just people used to write a lot of Python
programming just in ipython shell. And even
even today is several people are writing their
code complete code in ipython shell. But the
the Jupyter Notebook is more enhanced for
the enmore documented more, I mean, it has
better interfaces and several features that
are better than just using ipython shell.
So you have seen this ipython shell, it's
very powerful, great, everything is fine with
it. But we will be using Jupyter notebooks,
which are just the enhanced variants of this
ipython for our upcoming coding. So the purpose
of this video was just to was just to introduce
you with ipython shell and just to tell you
that you can use Python just as a calculator
and even more than that, and in the next video,
we will be introducing variables in Jupyter
Notebook and we will see the Python or Python
is really really much more powerful than just
a calculator. So hope to see you in the next
video. Okay, in this video, we will talk about
variables and operators the operations that
you can perform on on variables. A variable
in a very layman term is basically a symbol
that stores some data that can be used later
on. So for example, this x is a symbol corrector
or a symbol y is a symbol x y is a symbol
normally, and these are called names of the
variables. For example, this is a variable
name x, y is a variable name y, x y is a variable
name itself. Now, these variables, they can
store different kinds of data, I mean, whenever
you want a particular data to be used again
and again, it is better to save that data
or label that data by a symbol by a descriptive
name so that you can retrieve that team retrieve
that data by using that label or symbol. So
one way or the other. This this variable actually
is a description of the data that you want
to use our store and you want to use later
on in your program. Different types of data
are there, for example, the integer type data.
For example, if the data you want to store
is integer type, it's a number And the number
is just the integer number it does not have
a decimal point expansion that is a type of
data and that can be stored in a variable
in that in that case, the variable type itself
will be integer, you need not to specify the
type of variable when you are storing the
data to it the storing data to a variable
is sometimes called assigning data to a variable
or assignment. For example, if your variable
is x, and you are assigning a value let's
say two, then two is integer value its integer
it does not have a decimal expansion and when
to is assigned to x, based on the content
to that to basically is an integer type value,
automatically this the type of x is set to
be integer. And that is sometimes called the
dynamically typed Python is dynamically typed
language or dynamic typing, you need not to
specify the type of the variable the contents
that you are assigning to a variable, they
will define the type of the variable on the
fly. And the assignment for example, in here
I'm storing two insight x and next time if
I want to print for example, what is there
in x the the print value will be two. Now,
this kind of symbol is hot right there is
no keyboard symbol that looks like so, so
rather than writing this symbol for assignment,
normally an equal sign symbol is used for
assignment for example, x is equal to two
that means two is assigned in x five is equal
five is equal to five means five is assigned
in y 7.2 equal x y equals 7.2x y is completely
a new variable, it has nothing to do with
x or y. And it is handy sometimes to to to
suggest the name of the variables that are
too descriptive that are very, very descriptive
to increase the readability and management
of the code, because later on you will you
will be seeing when you will be working in
data science and other stuff. The programs
that you will be writing might not be very
short programs, they might be lengthy programs.
So readability of a program and management
of a program becomes an issue if you if you
if you do not assign the names of the variables
carefully. However, if you write the names
very in a very descriptive way, by just writing
the name of the variable by just creating
the variable symbol or or or the name, it
tells a better look and feel of what kind
of data inside and what should I do with that.
So, I was talking about this equal sign this
equal sign is used for assignment. Here for
examples when 7.2 is assigned to a variable
x y, automatically the type of x y variable
is set to be a floating point integer floating
point number a float is a data type in in
Python that describes that the particular
data is a real valued it may have a decimal
expansion as well not just integer and floats
are the only data types in Python, there are
several others for example, you can define
complex numbers if you if you want to you
can for example, defining a complex number
might be for example, you write the name of
C and you write two plus four j if you write
the symbol j here, it automatically becomes
complex. And now you can you can use this
see the way the complex numbers should be
created. Similarly, there are other data types
like fractions decimals, there are there are
further data types, the objects called strings.
For example, if you if you if you assign let's
say s equals double quotes Hello
then that S is also a variable and the type
of this variable a string string is just a
sequence of a lot of collectors, where he
is a collector is a collector L is a collector
L is a collector always a collector W is a
vector. And when we will define anything,
any sequence of characters inside the double
quotes and then ended the double quotes here,
or the single quotes, single quotes and double
course either way, then the type of this is
become strings. And these characters should
be created as it is. Like for example, if
we have another variable s two and we just
say one, two, in double quotes. Now this s
two is no longer 12 as an integer. It is a
sequence of characters where first character
is one and other graduates two, we will talk
about strings in detail in the upcoming videos
but just to give you a look and feel that
Python actually supports a lot of data types,
a lot of interesting data types including
the most important data type is integer float
and string as well that we will see in detail.
Further you can assign you can assign more
than one values to more than one variables
in in a single line there is sometimes called
multiple assignment. For example, if you write
a comma b equals four comma 5.00, then four
will be assigned to a and 5.0 will be assigned
to B. notice one thing although 5.0 looks
like an integer, but when you when you write
a decimal expansion, it automatically becomes
float. So, if you Now type the type, if you
now check the type of a it will be integer
and if you check the type of B it will be
float. Once you have declared a lot of variables,
they stay in the memory they occupy a particular
space inside the memory. For example, x is
just a label to a memory inside the memory
that is to located somewhere. Similarly, y
is also located somewhere in memory. And similarly
x y is also located somewhere in memory. And
this is the data inside that memory. These
will stay in the memory and the occupy the
memory. If you if you decide to no longer
use a particular variable and future in the
in the program, then you can call this function
d l space, whatever the variable name, and
it will delete the it will delete the variable
from the memory like it was never there. And
once the variable is no longer in memory,
it is it is not accessible. If you now access
the variable again, you will get an error.
Let's see all these concepts. Let let's see
most of these concepts in Jupyter Notebook
and let's let's actually, let's let's actually
define certain variables, use them, print
them, do some multiple assignment and see
a lot of stuff in in Jupyter Notebook. So
let's go to Jupyter Notebook. So that was
our notebook that we were doing, that we were
actually working on the last time. So let's
say I define a variable X, let's say x is
two. Why not? Why not? I should describe this.
as what we are doing here is let's say variables.
So just to give a heading that we are now
in variables, so variables, notice that now
I'm in a code cell. Previously I was in a
markdown cell, notice this change in this
particular cell, this is markdown in this
particular cell, this is code cell, C that
goes, Okay, x is equal to let's say, three,
let's into this. Now x is assigned a value
three. If you want to know how many variables
right now are there in the memory, we can
write this command whose This is a percentage
symbol, if you write percent a symbol and
then just type a command, w h o s, it will
tell you all the variables that are on right
now that are there in the memory. And right
now the memory has a variable with name x,
its type is integer, and the data inside the
variable is three, that's the memory view
that you're now seeing. Okay, if you want
to explicitly check the type of x, you can
print type x. So for example, this function
type will will actually find out the type
of whatever variable you give inside and then
this print function will help you printing
that on on the notebook. So if you see the
type of x, the type is basically its integer
type. Now,
if you for example, change the value of x
as three to let's say, 5.7. So you have same
variable, but you just change the value from
three to 5.7. So let's see what happens now.
So if we call us again, we have now the variable
name is still x, but its type automatically
it's type automatically change to floating
point number, because of because we assign
a floating point number to it. And this is
the data if we want to explicitly check the
type of this x, that would be class float
now, further. Let's say we have another variable
ABCD. That's a variable name, let's say and
we assign a value 55 six Point, three, two,
that's that's the value. If we now called
whose function whose command, we will be having
two particular values, one variable as ABCD,
its type is float. another variable is x,
its type is float, and that is there. If we,
for example, do a multiple assignment, for
example, a comma, when you write comma, first
variable finishes, second variable starts
A, B, C, D, F, let's say these are five variables.
And if you assign five values to five variables,
again in a comma separated list, 356, point
07, point two, and let's say minus three.
So if you enter that, and you now check the
status of the memory, because now all these
values are assigned to the respective variables,
if you now check the memory view, a is an
integer type variable with value three ABCD,
the old variable that we assigned earlier,
it's already float B is also integer, it has
value five sees float, sees float all those
6.0 looks looks much like integer. But when
you when you write a point explicitly, it
becomes it becomes a floating point number.
So D is again, float with 7.2, f is integer,
it's minus five. And x is the old old variable
that we know already. Now, if we, for example,
delete a particular variable, if we for example,
we we no longer want to use ABCD variable
ABCD. That's one variable that we don't want
to use in future. And now if we see again,
the view of the memory, we don't have this
and if we now want to access this, for example,
if we want to print this ABCD, we will get
an error, we will get an error and we should
we should get an error because this particular
variable does not exist in the memory, it
points to no data, it has gone, it has gone
like it was never, it was never there. So
that's about the variables. We just talked
about integer and float, there are several
other variable types as well. For example,
let me just give you an example of an example
of a complex number, if you are really interested
in that's a complex number if you print its
type so that the type is complex. Similarly,
you can have a string variable, let's say
hello, how are you? That's a string variable,
if you bring the type of this you will get
a string we will we have a whole set of videos
just on string data type, because this is
very important data type we will we will see
that in detail. But the purpose here is just
to tell you that there are a lot of data types
that Python supports and Python is dynamically
typed whatever content you are assigning to
a variable the that content decides the type
of the screen you need not to specify.
So I end this video here. In the next video,
we will be talking about operators basically
what kind of so once we have decided once
we have declared once we have defined a lot
of variables, what we can do with these variables,
can we add two variables together and get
the result stored in another variable can
we multiply two variables together, can we
have an operation like addition or mixed types
for example, one variable is a floating by
number and other variable is integer number
integer type, can we mix up those can we add
two different types of variables together
and get a result then what will be the type
of the result and so on. So a lot of these
discussions on operators the very basic arithmetic
operators on these variables, particularly
the integer and float variables, we will see
that in the next video, so hope to see you
in the next video. So in the last video, we
saw variables and we particularly saw integer
type variable and floating point, variable
type. We also saw very briefly on Jupyter
notebooks are complex, and string as well.
So in this video, we are going to talk about
operators, basically the arithmetic operators.
Obviously, if you are defining variables,
you're not defining the them the variables
just to just to view them later on. Most probably
you will be storing data to the variables
and then you are you're applying some computation
on a set of variables together. Comparing
new results saving that and doing some stuff,
most probably you will be adding to variables
some one way or the other in inside a program,
you may have to add two variables, you may
have to subtract a variable from the other,
you may have to divide a variable you may
have to compute for example, these are arithmetic
operators, let me let me just this this plus
symbol is used to add to variables. This minus
symbol or subtraction is used to subtract
a variable value from the other variable value.
Obviously, these all are operated on values,
not the names. Division, it like like the
name suggests, it's if you want to divide
this this person to a symbol when it is applied
to two different variables, if x is on left
and y is on right, what it does it, it actually
divides x by y, and checks what the remainder
is, for example, if x is 27, and y is five,
then what's the remainder? What do you think?
If we divide 27 by five, what's the remainder
the remainder will be? Two Yes, so the result
will be two here. So this computes the remainder.
This multiplication this star symbol is used
as multiplication like in mathematics, we
normally write this cross symbol. But in in
Python, and in most of programming languages,
Star symbol is used to achieve multiplication.
This double slash is like the division, but
it is division with the result flow to the
quotient. What I'm saying is the following.
For example, if you divide, let's say 10.
by three, the result will be a floating point
number, and the result will be 3.33. Something
like so. But if you want just the quotient,
not the remainder, if you want the integer,
that's the quotient value, then you write
the double slash three, and it will return
just the value that is that is there before
the decimal expansion. So this value will
be returned. So this is kind of the integer
division or floor division, this double star
is used to compute the power. For example,
if you want to compute to the right doublestar,
four, that means two raised to the power four
in mathematics, we write this as following.
And the result will be 16, you can save that
result in another variable, or you can just
print it or you can write that in a file of
whatever. So these are most important. operators.
One thing that I want to tell you that these
operator are not just for integers and floating
point numbers, the applications of these operators
is much broader than these later, we will
see the objects or the data types that are
collections. And very, I mean, the data types
that are beyond these integers and floats,
and still there, this plus minus division,
and all some of these are all of these, they
have their meanings there. Even even even
this plus is used for strengths. Now think
for example, if you have a string, let's say
hello.
And you have another string, for example,
let's say this is string s one, and you have
another string, let's say s two, which is
why then Python allows you even to add these
kind of data types, although some doesn't
make any sense with these kinds of string
variables, but we will see four different
kinds of data types. The the definition of
these operators, they actually changed or
adapted accordingly. For example, in mathematics,
we are much more fluent a four with plus with
Debian with subtraction, and it makes sense
to add two integers to subtract a floating
point number from another floating point number
and stuff, but with data type that is unfamiliar
to you right now, these operators may not
make that sense to you. But there are definitions
there, there are ways to use these variables.
For the data types that are even there or
even beyond an integer and floating point
numbers, we will see all these details as
we move on, as we move on to as we move on
to the videos. And I mean, as in later on,
we will see all these things in detail, but
just to tell you that these operators are
not just limited to integers and floating
point numbers or complex numbers, they can
be applied to several different data types.
So a lot of words, I guess you were born Now,
let's go to Jupyter Notebook and have fun
with these kinds of concepts that we are dealing
with. So yeah, here. So let's first press
escape, then m just to change it to markdown
and then good scape one for heading begetting.
And here I write, let's say operators, and
shift enter its runs and automatically then
go to code. Okay, now let's say I have a variable.
So let's say what kind of variables I already
have. In the previous video, we use that.
So we already have these kinds of variables
with us. Now, what is let me define a new
variable, let's say sum of sum of A, B, that's
a new variable sum underscore AB, that's a
variable name, you can have a better way you
will name maybe some of A and B, that might
be a variable name. It is good to have the
variable names that are descriptive that describe
what data is inside. Because in in programs,
the programs become manageable, readable,
and a lot of benefits are there. So Sum of
a and b, let's say that's a variable name.
And you add a, b, you just write a plus b.
Let me make the zoom level a little high so
that you can see it clearly. So a plus b,
let's say that's there. If you press Shift,
enter, and now your brand. Some of By the
way, if you have written some of you need
not write everything, just press tab, and
it will automatically complete the remaining
part of the variable and press Shift Enter
and you have eight. If you check the type
of this variable, some of tab automatically
completes tab complete that is called tab
completion, while it's integer, the type of
this particular variable is integer, that's
a new variable and why and the type is integer
because a was integer, B was integer. And
integer plus an integer is an integer. What
if we add an integer with a floating point
number? What do you think? What should be
the result? If I just type type? A, that's
an integer plus d with some floating point
number. So a plus d, the result will be here,
and type of that result. What will be the
type of that result? What do you think? Let
me pause here for a few minutes, and oh, no,
no, no, not for a few minutes. For a few,
maybe seconds, maybe two or three seconds,
what will be the result? What will be the
type of an integer and a float combined?
Well, the types are up costed, which means
the floating point number, the result will
be a floating point number. And the reason
is, every integer by default is a floating
point number, a floating point number is a
is an upper class, or you can say a superset.
So in Python, in Python, by default, the types
are up costed to super super sets. So here
integer plus a float, the result will be a
floating point number. And that's a result,
you might be thinking why we have why we haven't
stored the result in another variable. Well,
if we want to store the result in another
variable, we can, or if we just compute the
result and apply some operation on that, we
can do that. For example. We could do the
following, for example, a plus d. That's whatever
the result is raised to the power three, whatever
the result is, whatever the result is, divided
by maybe four. And we just save that in a
new variable. Let's say. Let's say the new
variable is V. Let's say we save that value,
and V. And now we print we, and we have the
result for me. Wow. So we can do a lot of
stuff with these kinds of variables. Let me
show you a fancy stuff that we will see later
on. Don't worry if you don't get it just as
one, for example, as one is Hello. Hello,
and let's say s two is world. And we have
another variable, let's say s, which is s
one plus s two. What it will do is it will
just concatenate them together. We will see
strings a lot later on. But just to tell you
this plus is not just for not just for numbers,
it is for other data types, very fancy data
types that are there. One more thing, let's
say we define 10 and we divide it by Three,
and we want a quotient, the quotient is three.
However, if we have 10 divided by three, Shift
Enter, the result actually is 3.33, and so
on, you might be wondering we have not saved
that result in a particular variable. So where
the result is saved, actually, if you do not,
if you do not save the result, if you do not
assign the result, for example, in this way,
the result will be assigned to a variable
or, but if you do not assign if you do not
store the result in a particular variable
explicitly, by default, there is a variable
in Python, which is underscore underscore
contains the last result that you did not
store in a particular variable explicitly.
So, that underscore is basically one default
variable for for the result, if you want,
don't try to update this underscore, just
just read it Do not assign anything to underscore.
For example, if you assign something to underscore
assignment will be done, but then the properties
of underscore will no longer be there as they
are in in Python built in properties. Okay,
so, that's about it, I guess. So that was
the operators, we will see the operators more
and more later on. But before ending this
video, I leave you with a question. So the
question is, we saw the variable names like,
Sum of a and b X, Y variable name can be can
be lengthy can be descriptive can be short
anyways. So the question really is, can a
variable name start with a digit? For example?
Is it possible that the variable name really
is is starts from the variable name starts
from for example, a digit? is a 3x? valid
variable name? Or, for example, at the rate
of at the rate of Why is that a variable name?
Or, for example, this symbol times two times
x, is that a variable name? What are the conventions
to for variable names? can we can we write
anything? In the left hand side? The right
let's say 3x? Is equal to four? That means
3x is now a variable name. Is that true in
Python? Or are there conventions to define
the variable names? So?
Yeah, think about it. See you in the next
video with the answer to this. So I hope you
will, you will be having answer for this question.
Hope to see you in the next video. Okay, so
in the last video, I asked you a question
about the naming convention of the odd variable
names. In particular, I asked you whether
3x is a proper variable name or not in Python?
So what's your answer? Yeah. What do you think?
How many of say, how many of you say no? How
many of you say yes? Well, by the way, you
might have tried that, declaring that variable
name and Jupyter Notebook, and then you might
have got this answer one of these? Well,
let me tell you, the answer is no. A variable
cannot start with a digit. Not with, not with,
at the rate of not with hash symbol, not with
I mean, there are several
other special characters are not there except
a few factors. One of those is underscore.
Let's go to let's go to Jupyter Notebook and
and check this. So, for example, 3x equals
five error, invalid syntax, let's say activate
of y equals four. Invalid star d equals four
error. Well, an exception is underscore underscore
E equals six, that's allowed. Starting a variable
name with underscore is allowed, it is different
than the underscore that is built in underscore
this underscore E is different than simply
underscore. So it is good to not declare the
variable names that start from these because
you will be getting errors further. variable
names should be descriptive. They should give
you a look and feel of the data what they
are containing and you're free to define variable
names, as as descriptive as you want. So it
is a good practice to, to start writing the
variable names in a better way. One, one better
notation, one better notation of defining
these variable names, even the function names,
we will see the functions later on. One way
to defining those is to use camel notation.
camel notation camel notation is you start
with the variable name with for example, lowercase
letters, let's say your variable is starting
time of the course. Let's say that's your
variable name. So you write starting, that's
one word finishes, then the next word should
start from capital T, starting time of the
course, let's say. So this kind of notation
is called camel notation. And very famous,
particularly the Java developers, they normally
follow this and several other developers.
But you should come up with a notation that
is one notation, there are other ways of keeping
consistently keeping the consistent strategy
of defining variables. There are several other
ways this is one way. So starting time of
the course is let's say 2.0. That's it. So
that's a variable name, if you if you now
check, that's a variable name. But now, if
you see this variable, just just the name
suggests the data inside is doing what? So
the names should be descriptive, I mean, and
make that as a habit. So, yeah, I guess we
have now answered our question very concretely,
that variable name cannot start with a digit
not with any special character other than
underscore, okay. In the next video, I will
be introducing comparisons with with variables.
For example, what if you want to compare whether
one variable is smaller than the other or
not? What if you want to compare whether the
two variables they are containing values they
are same or not? What if you want to do comparisons
of the of the data that is stored inside the
variables, and based on the result of the
comparison, you want to do something else.
So in the next video, we will see a bool data
type that is very, very famous, and it is
used in a lot in decision making. And we will
see the comparison operator sometimes called
the relational operators in the next video,
so hope to see you in the next video. Okay,
in this video, we are going to talk about
a data type which is called bool. That's very,
very famous data type. Actually, it's the
most famous data type because it is used in
decision making all the control flow most
of the controls, so depends on this data type.
Although it is very, very famous, very much
applicable data type, it is very simple. It
is a data type with just two states with just
two values. By the way, there are capacities
of different data types. For example, in T
integer, the
different kinds of values that you can store
are huge, you can store any negative number
in it, you can store zero, you can store any
positive number, the capacity of floating
point number or the number of values that
it can save is is even higher than even higher
than integer and the complex number is even
higher than that and so on. But the bool data
type, it has just two states one state is
true. It has just two values. True is a value.
And false is a value just these two straights
true or false. In some programming languages,
the true is denoted by one, and the false
is denoted by zero. But in Python, the true
is just t ru e true that thing and false is
false. That's it. If you For example, define
a variable let's say any variable name, whatever
the name is, let's say B and you assign true
then it's its default data type will become
bool. And if you have another variable, let's
see which is false. Then C is also bool. One
thing that is important, there are other operations
other than arithmetic operators that we saw,
adding subtraction division and stuff, there
are other operators that we can apply on bool
datatype. For example, a true and and is a
keyword combining true and true. If if there
is a variable, let's say a with a There is
a boolean variable a with data true. If there
is a boolean variable b with data true, then
a and b is also true. So let's say I've used
this variable D, in storing this A and B,
the D will also be true. So true and true
is always true. Further true and false, this
is always false. And this is committed if
for example, true and true is true, true and
false is false, false and true is false, false
and false is false. So, if you apply an operator
and keyword to combine the two Boolean variables
together, if both are true, then and will
result a true otherwise and will result of
false other than this and there are there
is there is another, there is another operator,
keyword or so, this results false. If both
are false, false, false, false or false is
false. If any one of these is true, then the
result is true. Remember the difference between
n and R and will result false if any one of
the two operands at least one of the two operands
is false,
then the result is false. If both are or are
anvisa true, if both of the operands are true,
otherwise it is false
or will result false if both of the options
is false or false. Otherwise it is true. So,
you now know and you now know are there is
another operator called not. This is not so
not for example, returns not true. Results
false and not false. returns true. Great.
So knot is a unary operator. unary means it
just takes it just takes one variable and
operate on that, and is a binary operator
like plus is a binary operator. It takes two
variables to operate on, or is a binary operator
it operate, it takes two operators, it takes
two variables to operate on and so on. So
remember, remember these things, one, and
we'll return true if both of the variables
are true, otherwise the result is false, or
will result false. If both are false. Otherwise,
it will return true and not is not just flips
the the state. So not true means false, not
false means true. So these are basic, that's
how you can combine the Boolean variables
together. In the next video, we will be seeing
how to apply these comparison operators and
the result will be Boolean types. And how
can we combine the Boolean types together
to to build a better decision making. So in
this particular video, I just, I just introduced
the boolean data type for you with you. In
the next video, we will see where the boolean
data type actually appears, and how it impacts
our, our our programming style or thinking
style or coding style. So hope to see you
in the next video with comparison operators
that actually produces the Boolean variables.
Hope to see you in the next video. Okay, in
the last video, I discussed boolean data type
and I discussed that a boolean variable takes
either a true or a false and we can combine
these Boolean variables together with and
our operators. And then we can apply a knot
operator on a particular variable. And we
we saw that a true and true returns true and
and otherwise it also returns false. Similarly
false or false is false. Otherwise, or always
returns of a true before before actually discussing
these comparison operators. Let's do let's
just go to Jupiter and just just play with
a boolean data type. Just Just for just for
a moment. Let us just convert this to markdown
cell and just cried. Both that's a word Boolean
variable. So let's say A is true and B is
true and C is false. False. And okay, so these
are variables. Let's press those to see what
are the states of. So, a is a boolean variable
with value true B is a boolean variable with
value true C is a boolean variable with value
false. So, now it is true B is true, C is
false. So that means, let me print print a
and b, what do you think? What is what will
be the result? Let me print a and see what
will be the result. And let me Brent? C and
A. So because a and b both are true, the first
result will be true, because C is false, false,
true and true is true. The the other two statements
they will result false. So first value will
be true, then false false. So yes, true, false
false. Let's, let's check the or print. And
by the way, let's store that are in another
variable, let's say A is true, or C is false.
So what do you think what will be the result
here, because or gives false when both are
false, here is true. So the value of d will
be true
for the not a, because A is true, not a will
be false. Similarly, not B, B is true. So
not B will be false. Not C, C is true, C is
false, and not c will be true. Similarly,
not D, we can save the result in another variable,
let's say D. and we can just check the type
of D if we want, that's a Boolean, we can
also check the value inside D and that is
false. So, yes, not only that, I mean, we
can we can we can we can combine at a higher
level for example, A and A and B, whatever
the result is, or C or D, whatever the result
is, and whatever the result is not of that.
I mean, we can we can combine them in a very
complicated way. If we want a and b the result
will be some Boolean, that Boolean and that
Boolean there
are the
result eventually will be a Boolean, and then
not have that. So let's check what if that
is the result is false, well, why the result
is false. figured out why the result is false,
let me go to comparison operators. So, the
comparison operators, let me just go through
comparison operators. This equal equal to
it compares whether two variables whether
whatever the variables are whether they are
integer floating point, whatever, whether
two variables are are, they have same data
or not, for example, x equals equals two y.
That will be true if x and y, they both have
same data. So for example, if X has value
four, and y has value four, then we are just
checking x equals equal to buy or not, the
result will be Boolean. Because an X may not
be a boolean variable y may not be a boolean
variable. If we want to compare the values
of x and y, then we write w equal without
a space inside. Remember, if we write single
equal that will be an assignment operator.
If we write w equal that means we are checking
whether the two values are same or not. Similarly,
if we write this particular symbol that checks
whether two values are not equal or not, for
example, x is not equal to y, the result will
be true if x and why they both have different
values, otherwise the result will be false.
Remember, the result of comparison is always
a Boolean, it is either true or false. Okay,
next we check whether less than So for example,
if x is less than y, the result will be true.
If x indeed has a value that is smaller than
y, let's say x is two and y is 10. In that
case, the result will be a true otherwise
the result will be false. Similarly, we can
compare the two variables using greater than
we can compare the two variables by less or
whether whether the whether one variable less
or equal to the other. For example, if X is
less or equal to y, the result will be true
of this comparison the result will be true
if X has a value that is not larger than why
as long as x and y are equal or x is smaller
than y In any case, the result will be true
otherwise false. Similarly, greater than or
equal to. Okay, so I end this video here in
the next video, we will be, we will be moving
to Jupiter and playing with these operators,
and seeing the return types of Booleans. And
then combining them together with ands and
ORS and doing doing interesting stuff with
that. In this particular video, I just talk
about the comparison operators, the boolean
data type and combining them by and or not.
In the next video, we'll be first moving to
Jupiter, we will see the comparison operators,
we will write all these statements in Jupiter
and just get a good hands on grip on that.
And then we'll be moving on verse. So hope
to see you in the next video. So in the last
video, I talked about comparisons, w equal
to not equal to less than, greater than, less
than or equal to, greater than or equal to.
So let's go to Jupyter Notebook and see how
they actually work. So let me just first enter
a markdown cell and type comparisons. Shift
Enter comparisons. So we can we can compare
different values by first assigning them to
variables. And then comparing those variables
or we can we can compare the values directly
or for example, rent. Two is less than three.
What do you think two is lesson three, the
result will be what Remember, the result of
a comparison operator is always Boolean, it
is either true or false. So in this case two
is smaller than three. So the result will
because this statement is true. So the result
will be true and true will be counted. Further,
we can store that result in in another variable
for example to is smaller than three, whatever
the result is, the result will be true, the
result will be saved in a variable, see, if
we check the type of see
reject the type of seeing as long as let's
print the value of C. So you can see the type
of C is Boolean, and C in this particular
case is true. Moreover, for example, let's
have three equals to four. Is that true or
false? What do you think three equals to four,
three, w equals to four, that is false, three
is not equal to four. And let's save this
result in D, remember three double equals
to four, that's an operation the result is
false. This equal is an assignment operator
that the false value will be assigned to the
variable D. and here we can see Brent D. Burn
it is false. Similarly, what do you think?
Three double equal to 3.0? What will be the
result? Remember, three is integer. 3.0 is
a floating point number. And I'm comparing
three double equals to 3.01 is integer, and
other is a floating point number. So what
will be the result? Let's say the result is
true, because they are comparing the values
by discarding the decimal position. Further,
let's see. Three is smaller or equal to so
let's say x is equal to four, y is equal to
nine. And z is equal to let's say 8.3. And
r is equal to minus three, let's say and these
are our variables. Let's see. So what do you
think what will be the result here x is smaller
than y. What will be the result of that x
is smaller than y, the result will be true
and z is smaller than z is smaller than y.
The result is again true because the smaller
than y or r r is r is equal to for example,
x. So what do you think what will be the result
at the end after this, so, let's see first
first this will be true, this will be again
true, and that is false. Okay. So, this true
and true will return true and true or anything,
the result final result is true. So, this
will return or it's returning true. But, if
I just do if I just switch the order, for
example, if I just write this statement, which
is false, this particular statement here and
then I do this, what will be the result now,
Now see, x is smaller than y it is true, r
is equal to x that is false. So, this result
will be false eventually, and z is smaller
than y, that result is z is smaller than y,
let me just say z is larger than one, let
me just check z is larger than y, z is larger
than I just just do just to tell you. So,
this is true, this is false. Both of these
are let me let me switch the let me switch
the listing r equals to x, I just want to
show you the precedents of r and x is smaller
than y. So now, if you see this is false,
this is true, false and true is true, true
or false and true is false, this is also false.
And the result overall is false. It should
happen, but what if, what if this goes first,
if this goes first, I mean, I want to show
you whether and an AR, which one of them will
operate first. So, in this particular case,
the result is false, but it can happen let
me let me tell you this in more and two, or
false and true or false. And
true,
what do you think what will be the result
here, true or false and true, if true or false
operate operate First, if true or false operate
First, the result will be true, true and true,
the result is true. If however, let me let
me just write a false here. If all operates
First, if all operates first, then false or
false is false and false and true is the result
eventually is false. And if and operates first,
then false and true is false, false or false
the result in both cases here is is false.
So, a better way of representing these kind
of sometimes sometimes they can make confusions,
sometimes they can make confusions, for example,
if we have a true here, if you have a false
here for example, false and true
How can I so, false, false and false or true.
So, in this case, if in this case, if false
or true that operate First, the result will
be true and false and false, false and true
the result will eventually be false. However,
if n operates First, the result will be false
here, false or true the result will be true.
So, here if and applies if you apply if n
is applied first, then the result overall
result will be true. But if all is applied
first, then the overall result will be false.
So it is it is good to know whether and will
be applied first or off will be applied first
in this particular case and will be applied
first even if you even if you change this
even if you change this order for example,
if you even if you pick this thing and apply
here still the result is and will be applied
first and or will be applied after, it is
always good rather than to one way is to remember
the precedents and will be applied first then
or, I mean it is good to think about the precedents.
Another good thing is to specify the order
using parentheses. For example, now, we specify
this first our will be applied and then four
and will be applied. So, it is good for readability
to always apply these parentheses and and
check the order in which ands and ORS and
the combination will be applied. So, the in
any way the result of these comparisons will
be bullions. Question, what will be the result
here? So, not to not equal to three and true
or false and true. See this slide for a while.
Even if you want to pause the video, pause
the video, see it? and answer the Brent will
return true or false. okay with this question,
I end this video. In this particular video,
we just saw the comparisons on Jupyter Notebook.
Just see how the comparisons return true or
true or false. We combine the different tools
and different Boolean values using ands and
ORS. And here is a question for you. Okay,
I will see you in the next video with answer
of this question. So I left you with a question
in the last video. So that was the question
if you remember. So the question really was,
what's the what's the result here? So what's
your answer? True or false? The result, either
will be true or false, because these are all
comparisons and combination of Boolean values.
So let's see step by step. First of all, let's
see this two is not equal to three The result
is two is not equal to three Yes, it is true,
two is not equal to three That's true. So
not true not true is false. So, this is false.
So, this whole thing is false. Now false and
true false and true that is false. So, this
whole thing here till here is false. Now we
have or or and then we have false and true
false and true is false. So, this whole thing
is false this whole thing is false and or
between false or false it is false. So the
result of this. So the So the answer to this
question is is false. Let me let me just convince
you by typing the statement in in Jupyter
Notebook. So, if you remember we have Brent.
Brent, not two is not equal to three and then
we were having I guess and false and yeah,
that was a different one. And true, sorry,
that was and true. So this was and true, then
we were having our
and then we were having these false and true.
So the front ends here and the result is Oh,
I have some I have some parenthesis mismatch.
So not true and this okay, I should have this
one I guess this goes to there and this goes
to there and I guess Yes. So the result is
false. The result is false. The purpose of
this question was not just to the purpose
of this question is to appreciate actually
the fact how we can combine different Boolean
values to to to achieve the final boolean
value and these kind of combinations will
become very, very helpful further in in control
flow and we will see the if conditions and
decision making and stuff so The answer to
this question is false. Yeah, and I end this
video here. In the next video, we are going
to see some useful functions of Python. And
after seeing the some some kind of useful,
there are a lot of functions, we will see
just a few of them very useful of them. And
after seeing those functions, then we will
directly jump to control flow basically the
if conditions and stuff where you will see
these comparisons, these Boolean values in
a much more applicable sense, then then earlier.
So hope to see you in the next video. Okay,
so let's have a very quick tour over some
some useful functions in Python. Obviously,
there are a lot of functions in Python, but
I will be covering just a few of them. That
I think with the passage of time, we will
be covering more and more but let's start
a function are sometimes, particularly a built
in function is is basically a feature from
the language that is supplied for the users
to achieve particular task. For example, around
function. If you give round for example, around,
let's say 4.6. This 4.6 is a floating point
number, and rounding means make it as integer.
And what round does is it finds the nearest
integer to 4.6. And the nearest integer in
this case is five, because five is more closer
to 4.6, then four. However, if you call round,
for example, on four point, let's say three,
then the result will be four, because four
is more closer to 4.3, than five. So that's
one use of round eight rounds, basically rounds
a floating point number to the nearest integer.
Another use of round is if you give another
argument that that is called an argument to
the function. For example, when you write
Brent. Brent, let's say a, this a is called
argument to a function Brent. Similarly, round
is a function 4.6 is an argument round is
function 4.3 is an argument, we will see functions
in details, and we will be writing our own
functions as well. But for now, just just
bear that just bear with me that functions
are these kinds of features that are available.
However, we we will be writing our own functions
later on. So this particular function accepts
two arguments surround has two different kind
of implementation. One is when it accepts
only one input argument, it returns the nearest
integer to that, if it accepts a floating
point number as well as another argument like
here we have three, that means after after
point, after decimal, go to three places only,
and then round up, then round, for example,
this 4.55 and then eight will be rounded based
on its next value. If the next value is larger
than five, then eight will go to nine and
stop. If the next value is smaller than five,
then it will stay as eight and the result
will be three decimal places after this. So
let's practice this round function just on
a Jupyter Notebook very quickly. Let's see.
So here we are. So let's see rent around,
let's say 4.556. And in this case, the result
will be 4.5. And the reason is 4.5. And it's
rounded up, it stays to five and the reason
is this 4.556, it is more closer to five then
than four. However, if you if you just print
round, four point, let's say 345. Let's see,
and the result will be for the reason is 4.345
is more closer to four. However, if you call
this round function with more than one argument,
for example 4.556789 let's say or with argument,
let's do that means the result should be only
two decimal places after the after the decimal
point. So in this case, the result is 4.56.
And the reason is, this five is rounded based
on the next digit and the next digit is larger
than five. Hence it is rounded up. So 4.56
If however, I call this function for three
Then what do you think what will be the result
it will be 4.55. And the six will be rounded
up based on the seven, and it will become
4.557. Yes. However, if, for example, there
will be a value at at the place of seven,
if there is a value, let's say three, then
you call this function, then 4.556. And then
based on the next value three, the six will
stay as six rather than going to nine, and
the result will be 4.556. Yeah, so that's,
that's the, that's the round function. Basically,
another function is diff mode, diff mode function
basically divides and returns quotient, and,
and remainder. So in the next video, we will
be seeing this diff mode in detail how it
actually works and how, how it is useful.
So in this particular video we saw around
function in the next video, we will see diff
mode, and there are a couple of more functions
that we will see in the upcoming videos. So
hope to see you in the next video. So in the
last video, we saw round function that sometimes
accepts one argument and sometimes accept
two arguments and behave accordingly. In this
particular video, we are going to see another
function dev mode. And it accepts two arguments,
two different arguments, but maybe same or
different arguments. And it it returns two
outputs, two numbers, two terms basically
quotient and remainder. For example, in this
particular case, the quotient is five, and
the remainder is two, because if five is divided
by if 27 is divided by five, the result is
five, but then the remainder is two. And the
result is returned in a kind of an ordered
pair. And these kind of collection in which
we have two or more elements, we call these
collection as tupple that we will see in detail
when we will see the data structures module
of this course. But right now just bear with
me that it returns two numbers, two elements,
and the two elements are ordered in an ordered
pair, which is called a tupple. A tupple is
not just an ordered pair, it can have three
more three, four, or five or seven, or maybe
several elements. But right now we will a
tupple is just an ordered list, which we will
see in detail. So let's see the working of
the stiff mode function in in Jupyter. notebook.
Let's see. So let's say we have dev mode.
Let's say for example, we have 34. And then
we have lots of them. Or maybe let's say nine,
so what do you think what will be the quotient
and what will be the remainder. So 918 27
So three, three is the quotient. And the remainder
is remainder is seven. So three is quotient
and salmon is the remainder. So and if you
save the result, for example, if you save
the result in a variable, let's say G. So
if you see the G the type of G if you if you
just type the type of if you just find the
type of ci it's a tupple, which we'll see
in details, and if you see the contents of
G if you see the contents of G the contents
of gr three and salmon, and if you want to
access each element independently, then you
can access the element first element, because
the if there are multiple elements in in a
variable normally that that kind of variables
are called collections that we will see in
detail later on. And these are the indexing
the positioning is start by zero rather than
one. So g zero means the first element of
G which is three in this case, and the second
element of G is one
at one, which is seven. So, this is basically
this is called the index or position of of
elements or data in this particular collection,
we will see these indexing and all these kinds
of collections in detail in in the in the
data structure scores, and we will see arrays
and strains and different kinds of structures.
But and default sometimes is, is basically
sometimes it is helpful. By the way you can
achieve dev mode by by another by another
thing. For example, if you want to achieve
a more 34 nine, you can do the same thing
by let's say 34 divided by double divided
by nine that will give you a quotient. And
the question is three and further if you write
34, remainder nine and that will give you
the remainder that you need. So you can call
that function Dave mode. Or you can use these
two there are multiple ways of doing the same
stuff. Okay? So, yes, so, I mean, sometimes
it's useful when you're going and knowing
this kind of function that returns quotient
and remainder. Okay, next function that is
more useful is is in stance, and we will see
this function in the in the next video. So
hope to see you in the next video okay, this
function is in stance, it actually returns
either true or false. And it just checks that
particular given data value belongs to this
type or not. For example, if you want to check
whether one has type integer, so, you can
check that using this function by the way,
you know that one is of type integer then
you may think that why on earth one should
be interested in checking the type of one
if somebody no it is in teacher, sometimes,
we have certain variables and certain data
is stored in it, and we want to check the
data inside it belongs to which kind of type
and in several cases the value to this variable
is not assigned by us It may be read from
some file or maybe through input a user give
some number or something like so. So, sometimes
it becomes important to check the type of
a particular way if we are if we are expecting
a particular type of the input and the input
is different than this function might be helpful.
somewhere. Either way, this is a function
available in Python and it checks whether
the given value has a particular type of not.
So is instance one int returns true is instance
1.0 integer that returns false maybe, because
this is a floating point number, and you can
check a particular value belongs to one of
the several types or not, you can give several
types in a in a tupple. And you can check
whether it belongs to this, this or not. So,
let's go to Jupyter Notebook and see, actually
how it works. So, by the way, this is the
same notebook that we have, that we are populating.
So, hold on with me, at the end of the day,
we'll be having one notebook complete. So,
is in stance is instance, let's say three
is that instance of integer The result is
true in this particular case, if for example,
we check whether is in stance 3.4 is that
nmt? Is that an end user? The answer is no
it does not end in Deezer. If for example,
we check if this is not in nature, then maybe
it is a float? The answer is yes. Or maybe
we check that. For example, if that value
is either float or integer, if it is one of
these, then I mean check that particular value
in this particular case 3.4 whether it belongs
to one of these types, we can increase these
types, for example. So, let's say we we gave
a complex number here and check is in stance
let's say two plus three j that's a complex
number. And let's say we asked whether it
is an integer or float or not, the result
is obviously false. And the reason is, it
is neither integer nor float or even if we
give string there str, so, it will still say
no it is not
not any of these, but maybe there is a complex
data type if you see that, that says yes,
because it is complex. So sometimes this is
instance becomes really useful. Next function
is power. So power you can you can compute
power by the way using using for example,
if you want to compute x raise to the power
y, you can use double star and that computes
exactly x raised to the power y or equivalently
you can call the function POW x comma y and
that will give you the same result as this
one. But power sometimes take three arguments
as well. And in that case, it it a it performs
the power function in a different behavior.
So for example, if you supply three arguments
what it does it it raise y to equate x raise
to the power BI whatever the result is, then
it takes the remainder by z and gives the
result. So let's see the functioning of this
power function in Jupyter Notebook. So let's
say Baba, I want to compute to raise to the
power for the result is 16. No problem. To
raise to the power four, I can compute the
result 16 this way as well. But here is another
way, how can we use this to raise to the power
for whatever the result is, then I want to
take the remainder, by let's say, I want to
take the remainder by seven, or two, so we've
got four is 16, then if we take the remainder
by seven, the result will be two. And that's
the result two. So that's how you can use
this power function. I'm just introducing
you some built in functions that are available,
there are so many functions that are available,
I'm just getting you comfortable with these
kinds of functions so that in future if you
see another function that he had not seen
here, you'll be able to use it and apply it.
So in this particular video, we saw this is
in stance function and this power function.
In the next video, we will see one more function
that will allow you to take input from the
user. So far, we are supplying values or assigning
values to variables directly, what if on the
fly, we want to give the values and those
values should be assigned to the variables.
So in the next video, we will see the function,
we will see a function that will allow you
to give input from the keyboard, hope to see
you in the next video. So in this video, we
are going to see a very important function
called input. This function is I mean, this
is beneficial for taking input from the keyboard
from the user. And the way to call this function
is you type input. And then you type a message
that actually describes the expected entry
that for example, into something if you want
somebody to or tell somebody to just incur
let's say, a number, you can write into a
number, or any specification to help the user
to enter whatever input the user want to interest
properly. One thing is that no matter what
the user will enter, the variable a will be
having type string, str. So even if you enter
a number, let's say 12, or 34, or whatever,
that will be received as a string. And then
there are ways to convert string to number
if that really was a number. So whatever you
receive using input function will be a string.
And then there are ways to deal with that
string, if that was a number, how to convert
that string to a number, and, and so on. So
for example, let's see, let's see on the Jupyter
Notebook, how it works. So let's see, for
example, x is equal to input, enter a number.
Let's see. And then then if I press Shift
Enter, a prompt will appear in front of you,
that will require you to enter a number for
example, if I enter, let's say 56, and then
I press enter, not Shift Enter, Enter, then
x will receive 56. Now, you might be thinking
this 56 is an integer, so the type of x should
be an integer. But this is not the case the
type of x will be a string. And the reason
is, whatever you enter is received as characters
five and six, even if you have entered something
else that would have been received as a sequence
of characters. So this is no longer a five
as a digit five, six as a digit six. These
are some characters sequence of characters.
Now, if you want to,
I mean, there are ways to convert this x,
for example, maybe you want, let's say, y
or x as int x. So this means you have now
converted this string to integer and then
whatever the result is, you have stored that
result in x again, if you now see the type
of x type of x, the result is integer. And
you can for example, print x minus 34. And
the result is 22. Because X was X was 56.
So this input function is I mean, it is an
one way by the way, if you if you're expecting
an integer or a float value, for example,
let's say you're expecting a float value,
then it is good to write input, let's say
enter a real number, maybe or any message,
any message and then at this particular time
at the time of import, then it is okay to
convert that thing to float and it will become
a float. Yeah, that's it. So, now, for example,
you enter 12.5 if you see the type of a now,
type of a will be float okay. But there are
problems for example, if you are if you are
expecting float and somebody enters into something
that is not float for example, a or let's
say B equals load, input enter are real number,
let's say and then you press Shift Enter and
somebody just interest let's say ABC. So,
now, this is not a float ABC cannot be converted
to a real number no matter what. So, you will
catch an error there are ways to avoid these
kinds of errors and programming program breaks
using exception handling and there are other
ways, but be careful I mean the user is not
I mean the one who is going to enter the the
enter the input if that that user is not restricted
enough, then you can get errors. So, I mean,
this is not the case that whatever you will
enter it will be converted to a float if it
really, if whatever you have entered is really
to convert it is really convertible to a float
then it can be convertible to a float, not
otherwise. And at the input time, there is
no restriction you cannot restrict the keyboard
to enter water or whatnot, although there
are ways although there are ways to do that.
So that's about the input function. So, we
have seen some of the functions, let me just
let me just go through quickly we have seen
input we have seen is in stands, we have seen
diff mode, we haven't we have seen power function,
we have seen the round function and there
are several others. Yes, so from now on, we
will be actually moving towards basically
decision making based sometimes we will use
these kind of functions, mostly you will be
using input function, but sometimes we'll
be using maybe other functions like these
functions. And sometimes we will be doing
decision making based on the ease and and
stuff like so, one thing that I want to tell
you is if for example, you know the function
name, some function, let's say like power,
you know, that POW power is a function, but
you do not know how to use that function.
One way is to just type question mark in front
of it, and then just press Shift Enter,
and in front of you, the documentation of
the power will open up so it will tell that
this is power, that's how it should be called
and then some description will be in front
of you that equivalent to x raised to the
power y with no arguments, the two arguments
are equivalent to x raised to the power y
remainder with z with three arguments and
so on, if you want to see implementation of
this function as well. We will see the functions
later on but if you want to see more about
the help, you can type the double Sam equal
a double question mark and more things should
be open up in front of you. So, in this particular
case, the small function does not have an
implementation in Python. So, the single question
mark and double question mark are the same
at one more way is to use the help function
help out and you will get a lot of information
about the power how for example, help on built
and function power in module built in. So
this is power this is equivalent to this some
key types and stuff like so, or for example,
you want to know how can I use the input function
for example, so you can write help on input
and this is how this can be used. So sometimes
it is okay if you know the if you know the
name of some function, and you know how to
use it, you can just open up the documentation
right here in Jupyter Notebook by either using
a help function or you can use just a question
mark in front of the name and so on. So, that's
about the functions. In the next video, we
will be seeing the power of comparisons and
the decision making or sometimes called the
control flow. So the real fun will begin from
the next video because we will be actually
deciding which part of the code should run
and which part should Not run based on based
on certain conditions. So hope to see you
in the next video. Okay, we are in control
flow, the most interesting part of any programming
language will assume that you have two numbers,
you have taken two numbers from the user a,
you've taken that number from the user using
input, I have not supplied the input message
here, the message is optional. It's a description
if you supply that that's okay, if you don't
supply even that, that's okay. So A is some
number the user will supply when the code
will run B is some number the user will supply
when the code will run. Now, once you have
a and b in front of you, obviously the user
will supply that on the fly, you don't know
what the value of a and b are. Because when
the program will run, only at that time, the
A will be populated and B will be populated.
Your task is whatever the value of a is that
is that you don't know whatever the value
of b is that you don't know, the user will
supply that value those values, your task
is to print the value that is bigger than
both. So for example, if a is bigger than
B, then print a if b is bigger than a, then
print B. So whatever the bigger value is,
print that value. Let's say that's your task.
How can you do that? So the question is how
does Python allows us does Python allow us
to do that, for example, if a is bigger than
we should print a, if b is bigger than we
should print B, remember again, and again
we are we are talking in terms of if A is
bigger, if so this is this is this is what
if a is larger than B, then this condition
will be true. This is like the comparison.
So this is true, but then we must have an
F condition as well. If A is bigger than to
what, so if a is bigger than B, then do certain
things. Otherwise, don't do that. Those kinds
of things. So this if condition is really,
really powerful, and is available in all programming
languages. In here, for example, let's see
if a is an input B is an input, writing an
if condition, that's if is a keyword. That's
a comparison that we have done earlier as
well. And then the syntax required a colon
in front of that. So if this condition is
true, if this result, if this comparison results
to remember the comparisons, they return Boolean
values, if this comparison, if this, whatever
the result of this operation is if that is
true, then you go into this block. And whatever
the statement inside is do that, for example,
print b is greater than a.
Now my question is, is that is that done?
Are we done with the task, the task was to
print the bigger number. If b is greater than
a, then B will be printed then or they might
have printed, for example, we might have printed
rather than writing this we might have might
have printed, let's say just print B because
b is bigger. If b is not bigger than a, what
will? What we will do them. So yeah. If b
is bigger than a then B will be printed? Yes.
Because then you will be inside here. If b
is not bigger than if this condition is false.
We will do what then? So that's a question.
So right now I'm just coding this in Jupyter.
notebook. And then we will see how can we
deal with that if b is not bigger than a kind
of condition? So let's first see the blessings
of if condition and Jupyter Notebook. Yeah,
so let's say a is an integer. Let's say you're
expecting an integer input. input, let's say
and then you write if, let's say B is again,
an integer input maybe. And let's say if a
is greater than b, then print a. That's it.
That's your program. Remember, this indentation,
I have not written this print here. This is
the indentation that defines the block of
a let's say if I want to print a, then I want
to print, let's say, I am still inside. If
condition, condition, and so whatever that
starts from this, whatever that starts Form
whatever that starts from this alignment,
if I write something here, let's say x is
equal to five, all that block all that block
is called the body of the if condition, if
it starts from this alignment, If however,
I I typed a statement, but I typed that statement
in that kind of alignment, the alignment like
this, this is no longer inside the if condition.
So, for example, here I type I am outside
the if condition. So, the purpose of writing
these multiple lines is just the if condition
does not require to contain only one line
of code, it can contain a whole block of code
multiple lines of codes. So, this is no longer
inside the if condition. So, now we will take
input a input B, whatever the numbers will
be, if the value in a will be larger than
B, then this will be printed and this will
be printed. Once these two are printed, then
this has to be printed regardless of the values
of a and b, because this does not this last
sprint statement, it does not depend upon.
This does not depend upon the values of a
and b, it has the if condition has no impact
on that, that is just a sequence of statements.
the if condition, the statement inside the
if are just these two. For example, if a is
not bigger than B, then neither this will
execute, nor this will execute. But this will
still execute because this is this has nothing
to do with the condition. So let's run this
code and see how it works. So let's set the
value of a see the power of descriptions.
If we could have written a description, then
the description could have been could have
appeared here. But let's say this is the value
of a let's say 12. The value of b let's say,
let's say 10. In this particular case, because
the value of b is 10, the value of a is 1212
is bigger than B if this condition is true,
this statement becomes true. Whenever this
condition becomes true, you're inside the
prints you are inside the if condition. Now
this print executes and you're you get well
this print executes and you get I am still
inside the if condition, and this has to execute
no matter what the values of NBR so now let
me read on this and give other values of a
and b let's say the value of a is 10. And
the value of b is let's say 45. Now, this
can this condition becomes false because 10
is greater than 45 this is not true, this
is false. So whenever this condition is false,
you never land inside the if condition
and you go out from the if condition. So these
are the statements that are inside the if
condition
they cannot execute because because you never
visit them, they can only be executed if condition
becomes true. So then once you're out the
if condition that's the statement there is
going to be executed anyways. So yeah, so
that's the flavor of if condition on the see
and making and this is the comparison operator
that returns a Boolean value. You may have
different kinds of comparisons here or combination
of comparisons here No, no problem depending
upon your logic. But the question is, are
we done we are going to print only the bigger
number we have, we have printed the one that
is if a is bigger, we have printed that what
if if b is bigger, we have not solved the
task yet. This is the task we have not solved
the task yet. So how to do it. Okay. So yeah,
it looks like complicated. How to print only
that number that is bigger. So if b is bigger
than a, then we will print B. Maybe Maybe
we should make maybe we should apply another
if condition. If b is bigger than a then print
B. If A is bigger than B, then print eight,
maybe. Yeah, why not? So
um,
so for example, let's go to Jupyter Notebook
and, and write the following. Let me let me
write a whole new program here. A equals and
import. Okay, let's do not have a message
and input and then if A is bigger than B,
then print a. Okay. However, if B is bigger
than a then print B, I guess we are done.
If this condition becomes true, then we are
here and we know if this condition becomes
true, then this condition cannot become true,
because it cannot happen there is because
then B as well as B is bigger than a This
cannot happen. So, whatever the bigger number
will be that will be executed further you
can see I have this if condition and this
if condition they are aligned in a way that
this if condition is not this the second if
condition is not inside the body of the first
if condition, we will see such cases such
cases when this is required. But right now,
I guess we are done. If A is bigger than B,
then print a, if b is bigger than a then print
B and only one of these if conditions will
become true, because A is bigger than B B
is bigger than a, these two statements cannot
be true at the same time. So, let's see. So
A is 10, b is 45. So the answer is 45. Well,
because 45 is bigger. So let's run it again.
So A is let's say 22. b is let's say four
and the result is 22. Because 32 is bigger,
I guess we are done with the task, we have
used this if condition twice to achieve the
task to print the number that is bigger and
both the numbers we we took both the numbers
from the keyboard Yeah, I end this video here.
And in the next video, I will tell you more
features of this if condition particularly
the L statement, whatever what we have done
recently with another if could could be achieved
through an L statement that is more powerful
and more readable. So in the next video, I
will talk about ELS statement which is a part
of F so hope to see you in the next video.
Okay, in the last video, we saw if condition
and we actually had an example in which we
wanted to know we wanted to just print the
greater number. So we input a number a we
input a number B and if b is greater than
a we printed the is greater than eight, then
we applied another if condition to check if
a is greater than b, then paint a the else
clause or the else part of f is as as the
name suggests, if this condition is true.
So, if this condition is true, this particular
condition is true, then go there. If this
is not true, which means else if this is true,
then go there, else go there. So if this is
true, then you learned here, if this is false,
then you learn else part for sure. And this
else is I mean, if b is greater than a if
this condition is true, then you print this
thing. Otherwise, a might be greater than
B or A might be equal to b either way you
learn in else part. So this if and else they
both have this alignment, but then the block
of ELLs started from this particular alignment,
maybe you have more statements here, the alignment
of this if block structure from here, and
you may have more statements here. So let's
go to the Jupyter Notebook and see the else
running. So let's say a equals and input and
B is 
B is int input and we say okay, if a is greater
than b, then brand a
else else rent else brand be elsewhere outspent
B. Now B will be printed, even if it is equal
to A or if it is greater than a either way,
B will be printed. So let's just see. Let's
just run this and see what happens. So Shift
Enter. So input a number. So A is let's say
10, and B is let's say, 12. So what do you
think when I will press enter what will be
printed, B or A, B, B is printed, that's what
B is printed. Now, if I run this again, and
a is done, and B is done, still the 10 will
be printed. So let's modify it, let's, let's
just say, print. If part. So that means we
landed in if part. Otherwise, we landed in
Ellsberg. So just to be more elaborated, let's
say so 10 and 10. And we landed in L sport.
And the reason is if a is greater than b,
so 10 is greater than b 10 is greater than
10. False. So you got two L's, and the LS
block, the whole block just executed. So that's
what else is, it's really very nice to have
an L state or whatever this whenever the,
if this is false, whatever that condition
is, if that is false, then you learn in else.
So yeah, that's the health part simply now,
okay. So, we have this f l structure, we can
have one more power with this F, what if we
want, if a if b is greater than a, then you
print B. Else, if A is equal to b, then you
print they're equal. And if this is false,
and this condition is false, if both these
conditions are false, then you go to else
part. So basically, if else if else if else,
if else, so, you can have really deep structure
for example, in this particular example, if
b is larger than a, then you land in this
part else, if this L is just short form of
else, else means B is not greater than a else,
you can have another check elsif A is equal
to b, then do what?
l
l, if we can have one more check, we can have
one more check, we can have several checks,
and then else else will only execute if all
if conditions or elsif parts on top. Their
conditions, they are false, and only then
else will be execute. So let's see these l
diff running on Jupyter. notebook. Okay, so
let's say a is and so rather than taking inputs,
let's say is one, B is let's say five. Let's
say we have taken these inputs is one B is
five, if A is if a is equal to b, then the
word rent equal l l F, which means else if
now, because this is if you should you have
to write a condition here, which will be either
true or false. If A is larger than B, then
do what? then print, let's say, a. And else,
let's say your brain be okay. So that's it.
And this statement, rent is not in if condition
Not, not in if this is outside complete, this
is complete if condition with all its L's
and LDAP parts, and this is no longer inside.
So let's run this. What do you think what
will be the result if A is one B is five,
then else bar is going to be run because A
is not equal to B, A is equal to b that's
false is larger than B that is also false.
So you will learn in export and B will be
printed and then a statement will be printed
which is not an F. So yeah, so B is printed
and not an F. If b is 10, then what will happen?
A equals to B that is false, so you will not
land here. Else if A is larger than B true.
You will land here because you land here else
will not execute. So He will be printed and
then not enough. If A is 10 and b is also
banned, let's say, then you have equal. Yeah,
so that's elsif. Okay, so that's about if
else if else if or short form is lf l structure.
In the next video, we will be talking more
about this if else if else structure in a
bit more detail. And we will also be giving
you a short form of this this guide of ELLs
if elsif elberfeld of structure. So hope to
see you in the next video. Okay, one way of
writing this, if elsif else kind of structure
there is a short form as well, which is written
down here in a in this green color, for example.
This is kind of a same code that we saw in
the last video, but that's the short form,
let's say a equals nine and B equals 10, then
print a if A is larger than B, else print
this particular thing, if A is equal to b,
l sprint that this is exactly the same kind
of structure, for example, print a, if A is
larger than B, so you just read that if a
is larger than B, then print a else if A is
equal to b, then print equal, else print that.
So that is kind of a short form of writing
this if Elif else kind of structure. But I
will, I will recommend to to to use, I'm in
the structure in this particular horizontal
form. Rather than writing that in this particular
way. Because this kind of structure, that
horizontal kind of structure is much more
readable, much more manageable. And this might
be this structure might be confusing some
time for for some kind of readers or, and
also if this structure goes on and on and
on, which we'll see in a in an example today.
Writing that writing very deep and lengthy
structures in short form is not very feasible.
So although but but this feature is there
if you like to write if elsif else kind of
structure in this way, this is available in
Python. Okay, let's let's get a good grip
on this f LS f l structure on Jupyter. notebook.
Let's move on to Jupyter Notebook. To see
an example, just an example. So let's say
the example is user will input a number, let's
say int input, let's say and enter marks,
let's say enter marks for a particular subject,
let's say user with enter some some marks.
And our goal is if the marks are larger than
85, then we will print a grade. If the marks
are larger than larger than 80, but smaller
than smaller, so if the marks are larger equal
to 85, then we will print a grade. Else if
marks are larger equal to 80, but smaller
than 85, then we will print a minus grade.
And if else if if marks are larger than larger
equal to 75, but smaller than 80, we will
paint we will print for example, b grade for
example, b grade, and so on, let's print this
whole nested structure that let's let's make
this else. if else if elsif kind of structure
a little empty, let's let's get comfortable
with it. So if a is larger than or equal to
85 to enhance readability, it is good to include
a space is a space after the variable and
space but don't actually write the space inside
there because larger and equal to the combined
without space is an operator. So if a is larger
than 85, then print let's say a grade rate
l if A is a is larger or equal to a D and
E is smaller than 85. So let me let me write
this in a more readable form. Else if A is
smaller than 85 and is larger or equal to
80 then we should do what it is sometimes
good to include these kind of parentheses
sometimes it is good just to make these things
more readable that this is one block. This
is one this is one Boolean, this is one Boolean,
this is one to see and this font is E and
although not writing the parenthesis is also
okay. But writing the parenthesis make code
a little more readable. So, for example, if
a is smaller than 85 and a is larger than
80, if that is true, So, remember and is true
only when the left side is true and right
side both are true, then this whole condition
becomes true. And I promised you that I will
show you the power of comparisons and actually
combining the Boolean variables using ands
and ORS and stuff like so. So here you're
seeing the one. In that case, let's say brand.
Let's say a binary sprayed and Elif if he
is if he is smaller than if he is smaller
than 80. And a is bigger or equal to 75. If
that's the case, then what should we do? Let
me omit the parentheses just to show that
whether writing parenthesis or not writing
parentheses is perfectly okay. I just recommend
right parenthesis, so the code becomes much
more readable than otherwise. Okay, then we
have Brent, let's say, b grade. And let's
say one more lF lF. If A is smaller than 75.
And a is larger or equal to let's say
70. samedi, then Brent b minus grade, let's
say. And let's just finish this let's else
print. below. Average, for example, let's
say that's it, that's our, that's our record.
So, we will we will enter numbers, if the
number is greater than 85, then a grade if,
when this condition becomes true, then this
print will execute. And we will out of the
structure right there. If this condition is
false, then this condition will be checked.
If this condition becomes true, then this
print will execute. And we will be out of
this structure. If this is false, and this
is false, then this will be checked. If this
is true, then we print degrade and we are
out. But if this is false, then this will
be checked. And if this is true, then we'll
print b minus grade. And we will be out. If
this is also false, then we will dive into
L sport and we will say okay, below average.
So let's see, for example, let's say the marks
are at two. So a minus grade. That, that that
that makes sense, a minus grade because the
marks are smaller than 85 and larger than
larger or equal to 80. So a minus grade. Let's,
let's run this again. And we have let's say
marks let's say 64 below average. Okay, great.
So you see this if Elif, Elif Elif else this
can go as long as you want, depending upon
your logic. So great. And further, you can
combine several comparisons several billions,
together with ands and ORS, and nots, whatever
you whatever you like to like to do. Let me
give you one more or one more beautiful thing.
let's let's let's create an L without writing
an else or let's let's just let's just write
lF and implement ELS completely so we are
not going to write ELS explicitly, but we
are going to write a program that actually
simulates ELS So let's see, if a equals let's
say, three. If A is larger than 10, then Brent
let's say larger than that. Now, we are not
going to write else, but we are going to achieve
the aerosport.
Tell If
not,
a is bigger than 10. To see, then print you
see that I mean, that's beautiful. If this
condition is true, then go there. If this
condition is false, then not have false is
true, then you learn here. And you need not
to write an expert if you want just I've implemented
I have implemented l spark using l f. So see
that. So l sparks so we are right now Spark.
If A is let's say 13, then we will think okay,
rather than just for fun, just for fun, okay.
Okay, great. So, we saw if condition it's
shorthand and LDAP structure in in a bit more,
lengthy way. So in the next video, we will
see if condition inside or in the body of
another if condition, which is called a nested
F. So hope to see you in the in the next video.
In the last video we saw if lF structure,
in this particular video, we will see nested
F, or are simply called if inside the body
of another F. So let's take an example to
understand what nested if condition is simply
we can understand if condition inside another
if condition, that's all rest of the story
is same. The way it works, it works even if
it is inside the body of another if or or
anywhere, actually. So let's say we have input
a number, and then we check if x is larger
than 10, then you move inside the if condition.
If that is true. If that is false, then you
are here, whatever you write here, it will
work from here. But let's say x is greater
than 10, then you print your number is greater
than 10, your number is above 10. Let's say
let's see Brent that now after this, after
this statement, you move to the statement,
and you just make another check if x is larger
than 20. Now you see this if condition. This
particular statement is inside this particular
if condition, if this, this condition becomes
true only then you dive in, otherwise you're
not. So here you're checking if x is larger
than 10, then you move inside and inside you're
making more checks. So for example, if x is
larger than 10, then you print or do some
stuff here, then you apply Further more, more
checks more graduality more, whatever your
logic is. So let's say here you're checking
if x is larger than 20. Now, if this condition
is true, then you move here else now this
else is of this if if x is not larger than
20, then you move to this else l squat and
you're here. So and we can have another if
inside this particular F or an F inside this
L sport and so on. So if inside an F is called
nested if and we can have I mean deep structures,
for example, if then something then if then
something then if so maybe we can have a very
lengthy structure if nested if structure depending
upon the logic. So let's get ourselves comfortable.
As always, by writing the code on Jupyter
Notebook because that makes much more sense.
When we see things running on, on on the notebook.
So let's say a is let's say again, and let's
say we take some number and if a is larger
than 10, then we say okay, Brent, larger than
10 and do more stuff, Brent. That's inside.
If condition, okay, then then maybe we have
another check if A is larger than 20 then
say rent greater than
20 Yeah, greater than 20. And you can rent
now rent inside the nested if, okay. Else
rent l sprint, smaller or equal to 20, smaller
equal to 20. And then brand, for example,
inside the L spark of nested if that's it,
and you can print here, brand outside all
it's fine. So that's it that's that that's
the structure. So let's see, let's give an
input which is larger than, by the way, if
input is not larger than 10, this if condition
is false, then you directly dive to this print
statement and all this structure is not going
to be executed, this is this complete thing
is called the body of this if condition, and
the body will only execute if the condition
becomes true, whether that condition is just
a single condition, or you have a combination
of a lot of comparisons and a lot of Booleans
whatever, if this condition becomes true,
whatever that condition takes form of, then
Then and only then you dive into this part.
And when you are in this part, then that's
a whole new universe, then you're on its own
in the new part, in the new part, for example,
if this condition becomes true, then you are
in this part, that's the body of this particular
if condition, and that's the body of the else
part, see the the body of the top if condition
has this kind of alignment, all the statements
that are in the body of if condition, they
start the same alignment, and all the conditions
all the statements that are in the body of
this particular if condition, they have their
own alignment, and this indentation is necessity
just to define, for example, which statement
is in what kind of block for example, if I
just press a tab, then another tab, then this
print statement is in this L sport and this
is the indentation that is defining the placement
of this print, if for example, I press I align
this with this, this particular structure
here, then this print statement is inside
this if condition, this is the indentation
that is defining the placement of different
statements. And if the print starts from here,
then it is completely outside of all if conditions
it is like this way. So let's run this board
and see what happens. Let's say we brand let's
say we just cried a equals let's say 12. So,
what do you think what should be printed,
if A is 12 then first of all this condition
is true. So greater than 10 will be printed
inside the top if that will be printed, then
this check will be executed and this condition
will become false because 12 is not larger
than 20 then you will go to the else part
and less or equal to 20 this number this string
will be printed and then inside the else part
of nested if that will be printed and then
you will be out of all if condition then outside
of all F's that will be printed. So let's
see whether whatever we have said is correct
or not. So yes, greater than 10 inside the
top if less than or equal to 20 inside the
else part of the nested f outside all F's
Yeah. So that's what the nested F is. And
by the way, you can have you can have for
example, more if conditions inside the nested
ifs for example, you can have one more condition
here, if A is larger than 30 for example,
then do what then print it is larger than
30 as well. And for the brand, maybe not necessarily
that you always write print statements you
can do any interesting stuff
inside inside the nested if of nested if find
and then you can write the else part of this
particular if condition here if you want to
or or whatever I mean you can have as hilarious
structure as you want, but that completely
depends upon the logic or you may have an
if condition inside that l spot here for example,
You can write an if condition here, if whatever
that is also, that is also perfectly fine.
So, if a is larger than 20, then you print
this if A is larger than 30, then this, for
example, and literally write the else part
here else, print less than or equal to 30.
And we can print inside the nested inside
the else for all of nested if of nested if,
okay, so, while you see that program, let
me let me just scale it down so that you can
see that completely see that program. I mean,
yeah, it makes perfectly sense to me, for
example, you take an input, if that is larger
than 10, then you're here. If it is larger
than 20, then you are here. If it is not larger
than 20, then you're here. Okay. So let's
say it is larger than 20. If it is larger
than 20, then you are here further, if it
is larger than 30, then you are here. Otherwise,
you are here. And once and by the way, if
A is not larger than 10, then you are directly
here. Wow. So let's run this code. Let me
just scale it down so that you can see it
more. You can see more text. Let's see. So
let's run this. No errors. Great. So let's
say the number is let's say 25. So, what do
you expect the result. So the number is 25
is greater than 10 inside the top if it is
greater than 20 inside the nested if it is
smaller than or equal to 30. So inside the
else part of nested if off nested if and then
outside all the hips conditions. Great. Yeah.
You enjoyed that. I enjoyed that. rate. Okay,
so that's about the nested if one more thing
that I have already told you, but just let
me tell you the power of indentation. You
are here for example, in this particular if
condition, that's the if condition and that's
the nested if, and that's the else part of
this if if you move this L sport in in the
indentation or the alignment with this if
then this is else part of this if and this
is not the else part of this If so, remember
the power of indentation the this is the indentation
that defines which part belongs to what what
kind of block or structure in Python. In other
languages. Sometimes, for example, in c++,
they they normally use to write these curly
brackets to define a block and their indentation
doesn't really matter. But in Python, this
is the indentation that actually defines each
and everything. So, for example, this is a
crucial example if this else just moves backwards
and aligned with this f you get this else
with this if these two if an L structures,
this is still nested if without an L sport.
And if this else move somewhere in between
I mean this is not aligned with this if this
not aligned with this if you get a syntax
error because that is not a proper indentation.
So focus on indentation that is really really
important. Yeah, so although i have i've told
you that the indentation has already told
you but I just I just found to make a slide
over this elsewhere because that's important.
Sometimes you may get confused whether this
else belongs to this F or that F Well, the
indentation defines this LS belong to what?
Okay, I end this
control flow indentation here. So from next
video we are jumping toward loops. But before
loops, I just want to I just want to write
a lengthy program in F LS f there are combinations.
I just want to write a Jupiter program for
you to to get comfortable with F nested f
the conditions that are ands and ORS and nots
are stuff like so. So So in the next video
we will be practicing more on Jupiter for
if conditions and then from the next to next
video. We'll be jumping toward loops, the
very very powerful structure. Okay. Hope to
see you in the next video. Okay, so let's
just practice this if condition a little bit
more in this particular video and we are going
to achieve particular tasks. So let's design
some task here. By the way, this has comment,
comment, comment is, it starts from a hash
symbol. And that's a statement that will never
be executed. This just describes your code,
for example. So like it, like, it is not there.
But it is there as a text, but not as a code
file. Like hash sometimes represents. Comment
or description with a single line. If your
comment goes on multiple lines, it is good
to write a multi line comment. So that's single
line comment, for example, single line comment,
the multi line comments, they start with three
quotes, and then end with three chords. So
whatever you write inside, in these, in this
particular block, that's a multi line comment.
So let's describe our problem in this modal
line comments, because that's the problem
in form of text. And then we will be solving
that problem using using the code. So that's
just description of the problem, let's say
user will enter of loading point number. Number,
let's say 230 8.915. Let's see. Okay, your
task is, is to so let's just adjust more readable,
your task is to
find out the teacher integer, portion, integer
portion, before the decimal before the point,
let's say for the for the point, in this case,
in this case, it is 238. And then,
and
and then check whether if that teacher portion
is and even number or not. So just print yes
or no. So print even if it is even number,
otherwise, print odd. So that's the that's
the problem statement. That's the problem
that we are going to solve. And this is just
to commit now we are outside the command that's
a multi line comment. Yeah, so how to how
to solve that problem? How to solve that problem?
So let's start solving this problem. I'm going
to spend some time on this program just to
get comfortable with the if conditions, let's
say let's say that number is x is input, let
me convert that input
into our
real number. That's it. Okay, we're just assuming
that the user will enter a real number. It's
real number. real number might be I mean to
38.0, that's a real number or 238 itself,
that's also real number. That's okay. But
we're not assuming that the user will enter,
let's say some characters like ABC or stuff
like sort of just just assuming that. Okay,
now, assume that x contains real number, it
may be an integer. By default, maybe user
just enters 10. And that's it. So it may be
already an integer, then we have to check
whether that 10 is whether that 10 is even
or not, or the user may enter 11.7, or the
user may enter minus 34.7. Or the user may
enter just zero or user may enter just zero
point 30 535. There are a lot of possibilities
that a user come up with this exe can contain
any kind of number, and we have to check according
to. So how can we move let us just see, whether
that number let us just extract the decimal
portion, the portion before point. Let's just
extract that how can we extract that there
are two conditions First of all, let's see
if x is positive, then do what else do what?
So let's try this structure first. The facts
is positive, then what we have to do? And
if x is negative, then what we have to do?
So if x is positive, then what we do? We,
we just so, what should we do? I'm just stuck
here. How can we extract the, the decimal
portion, the portion without this particular
thing? How can we extract that? That's, that's
tricky. That's kind of tricky. Yeah. So any,
any ideas? I guess this? The the structure
I have, I'm using the let us just first think
that x is positive, just make our life easier.
And then if x is positive, it's a positive
number. How can we extract this portion out?
Just the number that is below? That is before
the decimal point, but what should we do?
can we can we can we apply apply around function?
Will that help? x? Will that help? helps.
Yes. But no round function? So let's say y
contains the rounded value of x then, so what?
Then how can extract How can we extract the
the the decimal portion, the portion the integer
portion? Or maybe there is a function that
actually round down? Let me check whether
there is a function float or not? No, float
is not a function, I guess. So let's say round
x. Okay, now y contains the rounded vol value
forever the Xs we are now assuming that x
is positive, okay, then what? Now, if, if
y is larger than x, that means we moved up.
Okay, we moved up, the round goes up. In that
case, what we do is we just subtract. So the
let me so we just subtract the integer portion.
So the let me in teacher portion, let's say
that's our variable name, then the integer
portion is simply y minus one is that correct?
Is that correct? If y is larger than x, then
integer portion is simply y minus one. For
example, for example, just Just think about
it, if When, when, for example, if the value
was 29.6, and the rounded value will become
30, so 30 minus one will be 29. There is what
we are what we are interested in. So, yeah,
so otherwise, if for example, else, else,
if y is not larger than x, then y itself is
an integer portion.
Y itself is an integer portion. Is that correct?
I mean, is that making sense to you? That
if for example, if if x is larger than effects,
larger than if the rounded value of x is larger
than larger than x itself, then we just subtract
one and we get the proportion. Otherwise,
the rounded value itself is the portion, just
just let's just run this, run this code for
now and check whether what whatever we have
done so far is correct or not. So after that,
just print, let's say the integer portion.
And teacher portion, let's just print that.
Okay. So enter a number. Let's say the number
is, let's say 25.3 45.367. Let's say, obviously,
the integer portion here is 25. So let's say
let's see our program returns 25. And now
Oh, the result is 25. magically Oh my god.
We found 25. Let's run it again. Let's run
it again. Just to see. Okay, let's run this
again. And order this time let's give it to
45.8. Okay, the integer portion is 45. But
when we will round We will get to 46 and 46
minus one, we will dive into this particular
if condition. Let's see. All the result is
45. We are we are still moving very bill.
Great. That's, that's great. So, okay, let's
play with it. Let's, let's give, let's give
0.2 the result should be zero, it is zero,
right? Let's run it again and give it let's
see, let's say four. That's it, the result
should be four now, it is four. Great. So,
we are working very well we have extracted
the integer portion as long as the number
was positive. Okay, right. What if the number
will be negative? Let's say that was true,
if that was true, so, that whole logic works,
if x was positive, so if x is positive, then
whole this logic just works okay, then else
What should we do? If x is positive, then
this logic works effects is not positive,
then what will happen? Then how can we find
out the integer portion because first we have
to find out the integer portion and then we
have to find out whether they are integer
portion is even or not finding out whether
they are indeed a portion is even or not might
be simpler. But first, we have to find out
the integer portion. So for example, let's
check the behavior of round function on negative
numbers, let's say around minus 9.3. So the
result is minus nine. Okay? If we say okay,
round, minus 9.6, the result will be minus
10. So it looks like the same as working in
the positive numbers. So round function is
actually working roughly the same way it should
work in the positive numbers. Okay. So what
should we do here? Any idea? Maybe, maybe
we first convert? Maybe you first convert,
by the way? Yeah, maybe first convert the
number, let's say y equals around x again,
like before, but then what? Then what? So
maybe this rounding helps the same way? Maybe
the rounding helps the same way. We should
extract this out from this here, because it
is going to work in the else part as well,
why to compute it, why white write this redundant
code? So why is round x let's say then if
y is greater than x, what should we do? If
it is negative y is greater than then what
would what will be the portion? It will be
the integer portion will be portion will be
what?
y minus one or one? y plus one? Yes, you got
the answer? That's y plus one. Great. And
else I guess we have in future portion. Equals
Whitesell, I guess, yes, I guess that's the
that's the good. That's cool. I guess that's
checked, by the way, but I guess that's the
code. By the way, this else part is, this
else part is same in both of these conditions.
So maybe, maybe we can combine this code and
write a more elegant code, but I guess this
would work. Let us just print the integer
portion, just to check whether we are working
well, so far or not. So let's enter let's
see 12.3 The result is 12th grade. So it did
not change our previous I guess our previous
logic. So let's say there is minus 9.8. Now
the integer portion should be minus nine,
oh, it is returning 10 Why is that? Why is
that? Oh my God, this should be changed when
it is round. It may go that way or when it
rounds it actually becomes lesser than 10.
Because when it rounds it goes up and it becomes
lesser than a negative word. This condition
should flip. Yeah. So we are making an error
here. Let's fix that. Okay, let's run this
again. And see Let's say minus nine point
minus nine d 3.2. Minus 93. Great. So then
we have let's see, let's run it again. Minus
8.9. minus eight. Yes, we are working perfectly
fine. Once we have integer portion with us,
we just right here. At the very end if integer
portion is your portion, remainder with two,
if that equals to zero, if that equals to
zero, Brent, even, otherwise, else, brand.
Art. That's it. That's the whole program.
Let's see. And let's see, how is it running?
Let's say 22.6. It's even, let's say minus
87.3. That's odd rate. So you see the power,
if condition and, and how can we think in
writing these programs and stuff like so?
That was a lengthier video, I know. But I
guess you get a very good look and feel of,
of if conditions and thinking and building
logic and all that stuff. So in the next video,
we will start loops. So that's a beautiful
structure, hope to see you in the next video,
the best way to understand loops is to think
about in a repetitive structure or repeating
structure. Let me let me give you an example.
And they will, we will dive into this code
in a while. The example is let's say a user
gives you a number, let's say integer number.
And you want to print all the numbers till
that number, let's say you start from one,
and you keep on moving and printing all the
numbers, as long as you reach that number.
So for example, if user enters, let's say,
five, your goal is to print one, then print
two, then print three, then print four, and
then stops, then stop just or, let's say if
user print, if user enter, let's say, three,
then you print one, you print two, and then
you stop. This is easy. If user enters in
n, we can just print, we could have written
this thing, print. Brent, I, let's initialize
a variable by with one, Brent I, and then
I equals two i plus one, or in Python, we
can write this quickly as i plus equals to
one that means I
that means in I store a plus one, this is
the short form of writing this. And then after
that, you just apply an if condition. For
example, here, you can apply an if condition
and say, Okay, if I is smaller than n, you
keep on printing, and after printing, you
just increment again this, then check the
if condition and keep on moving. Well, that
is visible if n is five, or n is three, what
if if n is let's say, if t 1000. In I mean,
you're writing all that structure again, and
again. And again. I mean, that's a lot of
code. Well, the loops are just a solution
for this kind of structure when you want to
perform the same kind of task again, and again,
the loop gives you the facility to do that.
For example, let's just consider the VI loop.
This is again a condition similar like a condition
in if condition like an if condition, you
evaluate this Boolean expression, then that's
an expression that results a boolean value.
While this condition is true, you will stay
in this block and after executing whole block
once you check this condition again, if this
condition is again true, you will dive into
this block again. Then check the condition
dive into the block then check the condition
dive into the block. As long as this condition
stays true, you stay in the block you you
move inside the block. Once this condition
is false, then you exit this while loop then
the loop terminates and you move on to the
further processing just like an if condition
just like if conditions if if the condition
becomes false, you accept that if condition
and you can move on, moved on. So in this
particular case, for example, if n is five,
let's say if n is five, user give an integer
number that is five I is equal to one, now
one is smaller than five, the condition is
true, we move inside, you print I, the value
of i is one. So that's what you print, you
print one, then you change a, you increment
i with one, that means i equals i plus one,
so I becomes two. Now the body of the loop
finishes, that's whole body of the loop, the
body of the loop can have many, many statements,
a whole block of code. Once I becomes two,
you move on and you check, okay? Two is smaller
than five, yes, it is true, you move inside
the block again, you print two, then you update
I, the loop body finishes. Once the loop body
finishes, you go and check the condition again,
whether that condition is still true or not,
it is still true i is three i is three is
smaller than five, yes, you move inside, you
print three, you update, I, you check the
condition four is smaller than five, yes,
you move inside you print four, and then you
update I and then you move on now five is
smaller than five false. Once the condition
is false, you will not dive into the body
of the loop, you will exit the loop and you
will print done. And that's it done. So this
loop becomes very, very, very handy. In in,
in, in applications that have representative
structures. And in most of the interesting
programs, most of the interesting problems,
these are the loops that play a very huge
role. So let's go to Jupiter just to get our
hands, get our hands on this loop. For example,
let's say x is again, that's the end or n,
let's take n and is in input. Let me make
this a little bigger, just do. Let's say that
input and input is a number, let's say n i
is your surgeon, let's say let's say one,
while I is smaller than n, you may have written
this parenthesis just to just to create the
readability just to make readability. And
otherwise I mean, this is also Okay, that's
perfectly fine. If as long as I is smaller
than n, keep doing the following you what
you do is bring, for example, the square of
I paint the square of I, that the square of
it, let's say, and then you say, Grant, for
example. This is a question number. And then
you just print I, that's the iteration number
I have the loop.
That's the equation number I this is just
the spring, this is just a string. And that's
our variable, its value will be printed. This
print function takes as many arguments as
you pass. So you can you can write a comma
here and continue whatever you want to print.
That's very flexible function. Okay, then
what you do you say, Okay, I plus equals to
one. By the way, this i plus equals to one
is the same as i equals i plus one. You see,
I have just commented here just to explain
what this is doing. If I just write i equals
i plus one that is also that is also correct
in Python, but that's kind of shorthand. Okay.
And that's it. Now, again, when I de indent,
I'm outside the loop, let's say sprint. Loop
done, for example. So that's the code for
example. So let's run this code. Let's run
this code. For example. Let's say n is equal
to five, then we have five. So this is one,
this is the aggression number one, then two
square is four, this is the aggression number
two, then three squared is nine, the aggression
number three, then four square is 16. This
is the iteration number four, and then the
loop finishes. That's it. That's the first
snapshot of the loop. We will continue from
here onwards in the next video and I will
show you more and more flavors of this loop.
So hold on and wait for the next video. Okay,
in the previous video, we saw a while loop
and we saw one. One program related to while
loop, just printing Just printing a bunch
of numbers till a particular number. Well,
when you are inside the body of the loop,
that's a whole new you can write whatever
you want to write, for example, you can you
can apply an if condition inside the body
and check that an at each iteration a particular
decision should be made or not. For example,
in this particular case, I'm going to print
I whenever I is an even number, so, I is some
number if it is even then printed, else pass
this pass statement for example, is just a
statement of saying that do nothing It is
just a shortcut of writing do nothing we could
have we could have omitted the whole else
part along with this pass and still the code
is equivalent but sometimes writing this past
make the code readable just so so writing
this boss statement just means do nothing
and just move on. If we omit else statement,
and we omit this boss, that's perfectly okay.
So, for example, let's try it on the score.
Let's say n is let's say n is five i equals
one one is less than five Yes, one is not
an even number. So go to the else part else
means boss, which means go on and then increment
i this print statement is outside the loop
this is this is aligned with this while it's
not inside the body of the loop otherwise,
it should have been intent indented inside
now i is incremented I becomes to now move
back to is smaller than five years. Two remainder
two is zero Yes. So brand two, so two will
be printed. Because if executed else will
not execute and I will increment because I
is not inside the if condition it is inside
the body of the loop. So I incremented I becomes
three you go back, three is smaller than five
years. Three, remainder with two is zero false.
So pass i i plus one, so I becomes four, four
is smaller than five years for remainder two
is zero, yes, so Brent four. So else will
not execute now increment i, once you increment
i you get, for example, I equals five, now
five is smaller than five false, so you go
out of the loop and you print down. And that's
what this code is. So, you can have if condition
inside the loop, you can have nested if inside
the loop
you can have loop inside the loop nested loops,
we will see examples of nested loops as well.
I mean, that's that's all allowed are sometimes
rarely required. Okay. So, next there are
two important statements that are there, one
is break one is continue, I want to focus
these statements because they have a deep
link with loops. A break statement where ever
written inside the body of the loop tells
that exit the loop immediately whenever this
brake is encountered, whenever this brake
executes, it exits the loop immediately and
brings you outside the body of the loop. That's
what it does break. So for example, if I becomes
if I becomes divisible by 17 and the remainder
becomes zero, you will print a break and then
when this break statement will execute you
will exit the loop immediately regardless
of what is the value of AI What are other
states wherever break exits the loop Okay
great. Now, the continue continue statements
continue statement wherever encountered continue
brings the next iteration loaded regardless
of the remaining remaining statements in the
loop for example, when this continue will
be executed, no matter how many statements
are there onwards that are there, in the body
of the loop, the loop will not finish its
iterations iteration by going through all
the remaining statements, but it will start
another iteration immediately. So continue
basically skips the remaining body of the
loop and starts another iteration. Here I
have written this. true true means while true
means always run. You might be thinking always
run it's an infinite loop will it will it
when we will exit the loop because this true
statement will always stay true. We're not
changing this true anymore. There is no condition
here. That's true. While true means always
go inside the loop but once where whenever
this Break his encounter, you're outside the
loop right away. And this break exists, the
loop does continue skips the remaining remaining
portion of the loop body and starts the new
iteration starts another iteration. So this
continue means start another iteration immediately
skip the rest of the stress of the statements.
So the rest of the statements inside the loop
body. Okay, so let's just practice this break
and continue with just just in Jupyter Notebook
to get a better look and feel of the loop.
So let's say we have, let's say again, let's
say n equals let's say 10. Or we might have
taken that as an input, let's say n is equal
to 10. While true, which means keep moving,
it might have taken some value here, I equals,
let's say one, while true, if I remainder
with, let's say, nine, if that is equal to
zero, then just break the loop tells ELS.
Else, what you do is really you increment
a else what you do is, if I is if I is not
divisible by nine, then what you do is i equals
i plus one, that's true. By the way, previously,
we we have written this way. So either way
is fine, whether you write a short form or
this form, so else this okay. And that's,
that's it, the loop finishes. That's the loop.
After the loop, you just write Okay, print,
the loop is done. So let's see, what's the
output? The output is done straightaway. And
the reason is, why it is Oh, one is not one
is divisible by nine, only then you could
have break. While true. Why? Why the loop?
Oh, it does not print anything, we could have
printed some statements so that we know that
we went inside the loop or not. Okay, so inside,
if so, for example, Brent.
Inside else. So let's run this again. Oh,
okay, great, inside sales, inside sales inside
sales inside rails, the first time it go inside,
if that time it breaks, and it goes out and
pants down. That's what this break statement
does. So let's see an application of continuous
statement. That's for example, just copy and
paste that code into another cell and see
how this continue works. So, let's say we
have a loop like so. So, what we say is like
this, if I is nine is not equal to zero. If
this is the case, if I is not divisible by
nine, what you do is you get take i plus equals
to one and then continue continue to the next
statement. And whatever else you write here
for example, brand something brand something
else something else whatever that is going
to be printed and what wants to continue will
will be encountered whenever this eye is whenever
this I divisible by nine is not true. If I
is then you continue once this AI is divisible
by nine for example, then you will not follow
then you will not dive into this if condition
only then these two statements will be printed.
Because this this continue will not allow
anything further that should happen. And once
these are printed, let's say we break our
loop right there, let's say so if for example
for the very first time one is not divisible
by nine, so I equals two. So continue these
three statements will not be executed the
next loop the next loop. The next one If condition
becomes false, this continue will not operate,
and then we print this statement, then only
then we will print this statement, and only
then we will break and we'll exit the loop
and print the data. So let's print here. Brent
inside, if so, let's run this code, let's
run this code and see what happens. That's
the good
I should I should just yeah, NASA better font,
let's run this code. So, when the code is
run inside if inside if you see when you when
you are inside if when you continue when when
this is the body of if condition when if condition
completes, it should print these two things,
but continue is telling the cursor to go back
to the next iteration and move on. And once
this if condition becomes false, only then
you get this distinct printed this thing printed
if this break was not there, you do you then
again was going to the while loop and you
will be running an infinite loop and then
you have done so that's what this continue
and break does. So, in the in the in the very
next video we will see another kind of loop
here we saw the while loop in the next video
we will see a for loop very powerful and very
famous kind of loop for it does almost the
same stuff as while loop while the while loop
runs based on a condition they fire the for
loop it runs based on contracts a counter
loop that many times it should run and so
on. So we will see the details of for loop
and the application The for loop in the next
video hope to see you in the next one. Okay
in this video we are going to discuss for
loop and other kind of loop in the previous
video we saw while loop although most of the
stuff almost all of the stuff can be achievable
through while loop and sometimes it becomes
handy to apply for loop. In this particular
example, I'm going to populate a list. So
before actually moving towards for loop let's
see very shortly what a list is, although
we are going to be or we are going to explore
this lesson in much more detail when we will
discuss the data structures module but just
for the sake of example, a list is a collection
of different kinds of elements for example
234, that's a list of three elements. So two
three and four the list can contains different
type values, for example two 3.4 and stuff
like so, we can access different elements
for example, L of zero means the very first
element the indexing This is called the index,
the index starts from zero then index one
is so if we print for example, Brent Elif
zero the result will the result that will
be printed will be two similarly we can append
more values inside a list append let's say
53 and list after this append operation, the
list will be having these values 234 53 we
can remove delete, update and do a lot of
stuff we will see lists in detail, but just
for this example, just think that list is
collection of a lot of elements and we can
add insert more elements we can delete elements,
we can change elements and so on. Or we can
just initialize the list with just an empty
list and start inserting elements one by one
and expanding that list. Okay. Now, this is
an empty list for example, and four is just
a variable for i in this range isn't it greater
range then means sequentially give a number
one by one starting from zero start from zero
a gift num give numbers one by one for example,
first time give zero I will contain zero second
time give 1/3 time give two and so on after
every equation the range will give another
number as long as the numbers they are smaller
than 10. So, the last number that this range
will return will be nine. So whatever this
is written inside is not included and it starts
from zero. So as long as I is in this range
is lower than 10 as long as that you that
the body of the loop just like the body of
the while loop. So first time I will be zero
and zero is smaller than 10 Okay, you print
i i plus one and abandon the square of that
in a list. Then next time this range will
automatically return the next number into
I. Now next time I will contain one next time
I will contain two Next time I will continue
In three, four or 5678 and nine, once the
value of AI becomes nine, that's the last
iteration of this body of the loop. And after
that the loop finishes. So let's just write
on this very very first time I will be zero
when the loop enters its body very first time
I will be zero and one will be printed because
we are printing i plus one, at that time the
list and the empty list will be having one
number which is zero square. So list will
be having just one number zero, because zero
square, so, next time I will be one and we
will print two and the list will contain one
square which is one, next time I will be three
we will I will be two we will print three
and we will be having a square of two which
is four, and so on till so until 10 here,
when I will be nine we will print print 10.
And in this list, we will be having nine square
which is 81, I guess, and after that the loop
finishes and we will be out of this loop.
Okay, let's see this. Let's see example of
this in, in Jupiter just to get more comfortable
with with list as well as the for loop. So
let's see, let's say we have an empty list,
let's say an empty list. Just to consider
a list like this L is just a variable, you
can write another variable a name, that's
a variable name L. Okay. So for i in range,
in is a keyword range is a function in is
a keyword, i in range. For example, let's
say then, what you do is you brand, your brand
i plus one or whatever you want to do, that's
the body of the loop, and Eldad a band, that's
a function of the lists, we will see that
in detail in the data structure sessions.
Okay, and that's it, the loop finishes. When
you finish the loop, just print the whole
list. So let's print the list. And you can
see the result 1-234-567-8910. And that's
the these are the values in the list. As as
I mentioned earlier, all the little the values.
By the way, this range function actually,
if What if we want it to jump more than just
one, for example, b we want it to start from
zero, it reaches 10. And let's say we want
two jumps to be taken as two rather than one
and one. So the very first time so that's
the start location. That's the end location
which is not included start location is included
and location is not included. And that's a
step size. So very first time I will be one
you move inside, then a jump of two will be
taken the next time I will be so very first
time the AI will be zero, then you move inside
then the jump of two, then you move inside
then a jump of two then you move inside as
long as you stay smaller than 10 you will
move inside the loop body of the loop. So
let's see what now printed let's print just
I rather than i plus one there was an error
was the error 00 the range function does not
have colons, it has actually commas. Sorry,
my mistake. I was just a MATLAB user one.
So MATLAB actually has this colon things.
So I was just confusing MATLAB notation with
this. Okay, great. So so first time i was
zero, next time a jump of two, I becomes two.
Next aim to jump off to AI becomes four, then
I become six, then I becomes eight. And next
time I becomes 10. But 10 is not included.
So you're out of the loop. And that's the
squares that you got. It is not necessary
that you always start from zero, you can start
from one and you can j take a jump for example
the jump of three. And it's not necessary
that you just reach them you can reach for
example 20 it's up to you it's completely
your choice. And in that case, you have this
kind of vibrations. So this range function
really is helpful for creating over over a
loop body or a structure. Okay, great. So
that was introduction of for loop and we have
iterated here on on our list we just have
actually populated a list using for loops.
Okay In the next video we will see more details
of this for loop and more fun stuff. Okay,
hope to see you in the next video. Last time,
we saw four In the last video, and magically
this else has something to do with for loop
in Python. Well this else clause makes sense
for F. But in for loop it hardly makes sense.
But let me let me let me try to make sense
of else clause for follow there is an else
part of for loop as well in Python, not in
other languages. I don't know any other language
that has this L spark maybe there is some
but I don't know.
So this else part in Python, particularly
in follow, this else part or else that was
blocked will only execute if four completes
its iterations. For example, this is a set
a set like a list is is a collection list
is defined by square brackets set is defined
by curly brackets, the set is just similar
like the set in mathematics, we will see the
set lists tuples dictionaries and many of
these data structures in detail in data structures
portion, but just I have introduced this,
just consider this set has three elements
Apple 4.9, and Jerry. Apple is one object
or one data. 4.9 is one data, which is a floating
point data and Jerry is one data which is
a string data. Okay, so this S has three elements,
three different elements. So now for x in
this set, as long as x is in the set, the
very first time the x will be Apple, so it
will print Apple, next time x will contain
a 4.9 as long as so I create over this set,
as long as x is inside the set big elements
one by one, and just print them all. Okay,
we expect that when x is Apple, when the very
first time x will be Apple, it will print
Apple next time x will be 4.9 it will print
4.9. Next time x will be cherry it will print
cherry, and the loop ends because there is
no item in sets to iterate over. Because the
loop finishes it's complete iteration there
are expected three iterations and the loop
finishes those now the else part will execute
and you will say okay, loop completed. So
iterations. Well, you will be wondering in
what case the else will not else will not
execute. If you apply any brake statement
inside the loop body, which means you forcefully
you forcefully remove some of the iterations
that were going to be executed but the loop
did not complete it did not complete citations,
then the L spot will not run. So let's see
an example in in in Jupiter to get a good
grip on this else. Okay, let's define a set
S. S is a variable name. You can have any
variable name that say it Apple, or let's
say 4.9 I guess and then we was having, let's
say, Sherry, if if these Spelling's are correct,
I guess jelly. Okay, then for x in PES, as
long as x is ns Brand X. Fine ELLs rant, when
you finish the law terminates with success,
or all iterations it completed all its iterations.
And this is a statement that is completely
outside the loop. side the loop, so let's
run this. So you can see Apple 4.9 cherry
loop terminates with success outside the loop.
Okay. Now you might be thinking in what case
this else will not execute. Okay, if, for
example, as long as x is an N, if I say okay,
let's say I take a counter here, I equals
one, that's a counter, let's say, and every
time I just increment i, i plus equals one,
and then I check if i is equal to three. If
y is equal to three, then just break. Let's
say
else just for readability else was now this
else is else of this four. And this else is
else of this if and this POS statement is
just a statement for doing nothing. Now what
you do when is equal to one you Brent this
i plus equals I becomes two two is equal to
three false, so you pass you move on. Next
time, x will print 4.9, I will become three
and three is equal to three, that's correct,
the break will execute, which means the loop
should have one more iteration, but the break
just disrupt that one more iteration that
should be there, because the loop could not
complete its iteration due to this certain
condition, this else part of the loop will
not execute, and you will go directly outside
this loop. So let's run this code and see
the result. So you can see this apple four
by nine outside the loop. I would recommend
although this else is there for for loop,
but I would recommend to avoid using ELS in
the beginning, I mean, you may be confusing
this else By the way, there is a there is
a mistake here, this l should be ended with
a colon here, okay. So I would recommend to
not use LS clause for a for loop in the beginning
until you you really need it. Because you
may confuse this else with the with the L
of F condition. And you may think something
else and the program behave in a different
way. So either way, if you want to use LS
LS for a for loop is there in Python. Okay,
just one more example of for loop. And here
we use dictionary, I'm introducing some data
structures here just for fun, we will see
these data structures in detail later on.
So dictionary, that's a key value period like
set, but one item is consists of two numbers,
that's called a key. And that is called a
value. That's a key. And that's a value like
a dictionary, we have key and values. So now
as long as x is an X, X represents two key
and d is our dictionary and D off x represents
to whatever value that x points to, for example,
Apple is a key that points to 44. Cherry is
a key that points to gain. For example, if
we're ID, apples, apple, the result will be
44. Similarly, d of Jerry, the result will
be game. Okay, so let's I create over this
dictionary using this for loop. All am I showing
you that this for loop is very, very handy
of creating over different data structures
and a lot of data and stuff. Whereas file
while loop is more handy and checking the
conditions and stuff. Although you can do
all the stuff using while loop you can always
stuff using for loop but one is better over
the other insert in certain situations. So
that's let's let's just run this for a dictionary.
Let's say I have a dictionary D. It's defined
like a set, let's say my key is a and my value
is 10. Let's say my key is B and value is
minus 19. And let's say my key is C and my
value is let's say ABC, let's say that's my
dictionary. So for x in the Brent the key
as well as the value of that key. So now you
can see the key is a the value of Stan The
key is B the value is minus 90 in the key
of C the values ABC. So this far loop is really
really handy and iterated over a lot of data
structures and stuff although it has other
applications as well but this is handy. Okay
great. So that's about loops for loops. And
while loops These are two kinds of loops in
important loop these are two important kind
of loops and they are in
Python, in the next video I will directly
go to Jupiter and Jupiter notebook and we
will be practicing for this for loops or while
loops. We will be practicing the loops we
will be doing actually examples of nested
loops we will be actually solving a problem
like we did in the if conditions we solve
the problem Previously, we wrote a code for
it. Here we will also write a code and we
will be get a good grip on the loops. So hope
to see you in the next video we will solve
a problem in Jupyter Notebook directly. Okay,
hope to see you in the next video. Okay, welcome
back. In this particular video we are going
to practice for loops are basically loops.
So let's have a problem statement. First,
what problem we are going to solve let's have
comments. And the problem we are going to
solve is let's define given a list of of numbers,
numbers. For example, I II, let's say 124
minus five, a 7932, like this, make another
list making another list that contains all
the items in sorted order from minimum to
maximum, ie, your result will be another list.
Like, in this particular case, we will be
having minus five, which is smallest, then
we will be having one, then we'll be having
two, then we'll be having two, then we will
be having two, then we'll be having three.
So all items, but in minimum to maximum sorted
order, then we having I guess, four, then
we'll be having seven, and then we'll be having
nine. So that's your, that should be your
output in another list. So assuming this list
is available to you, or any list is available
to you assume this list is available to you.
So how to solve that problem? Let's start.
Okay, let's assume that the list is available.
That's it, this is the list we are going to
sort. Let's say this is available. Okay. Okay.
So, what should be the logic? What should
be the logic? How can we solve that problem?
This is, this is an easy looking problem,
but it is not so easy. Let us first right.
Let us just simplify this problem to just
finding out a minimum from the list. Let's
say we are given a list and we just want to
find out minimum number one a minimum from
the list. So how can we move that. So let's
say M is some number. So M is the very first
value of the list, let's MSP our variable,
let's say that's the first value. And what
we do is for i in the for i n L, as long as
I is an L, if I AI is smaller than m, then
if AI is smaller than m, then m should contain
AI. Otherwise do nothing. That's it. So at
the end, rentas m, then this m at the end.
So, Brent, the minimum number, that's great.
So so that's the nasty, basically. So yeah,
that's the that's how we will find out just
the minimum value. So let's run this code.
And the minimum is minus five available to
us. What if we want to store the minimum value
as well as the position of that value? For
example, we not only want to just find out
what is the minimum number, we also want to
find out at what index for example, here 012,
and three, at the third index, we found the
minimum, what if we're interested in the index
as well. So let's say for the very beginning,
the index is zero. And then what we do is
we moved on and we say, okay, we maintain
a counter, let's say a counter is C equals
c equals zero, for example, right now, and
C, just plus equals to one, that's a counter
and then this ID x is just that C, whatever
that c is. So whatever that index is, when
we find this C, that index is also there.
So let's print the index as well as the minimum
value. So okay, so at the position three,
at index three, we found the minimum value,
okay, now we have written kind of a code block
that helps us finding out the minimum value.
How can we actually how can we actually do
how can we act? So the basic logic is you
find the minimum value and swap the that value
with the very first value, okay, great. And
then move the loop next time find out the
minimum value from the remaining list and
swap that minimum value with the second value.
Next time you find the minimum value, as long
as the position and swap that with the third
value and so on. So do that stuff and just
rearrange the same list using this but, but
how can the so that's the logic find out the
minimum value. So happened with the first
value and then start from two till end start
from start from the remaining values, find
the minimum so appid with the first value
of the remaining list, then reduce the list
step by step and you will be having a sorted
order, but how to start with how to find out
like this how to how to do that. So, any idea
and we are going to so for example, in this
particular case, if I want to swap the list,
what I will do is I will say okay, swap with
zero at the at the at the zero, so, I will
contain a temporary variable, temporary variable
will contain the value of zero, this zero,
so what I will do is at least zero, right
the minimum value and the minimum value. So
at zero you write the minimum value, but at
this particular index, from there, we found
the minimum value, just place the just place
the the value at the very beginning. So in
after that, after that operation, the minimum
will be at the first position, or the zeroeth
index, and that value will be some minimum
value will be swapped with the very first
value. So let's run this code and see what
a list looks like after that good. So you
see, for example, the minimum value is swept
by the first value, whatever the first value
was, but we want to do that progressively
for for the rest of the list, we want to find
out the minimum and follow up with the first
one for the rest of the list and keep on moving.
How can we do that? So yeah, that's, that's,
so let me define four. So let me first in
depth a bit, let's say control right bases
that will indent all my code. So for j in
range, length of the list, whatever the length
of list, let's say for G is that so what I
do is M is the gf value the index right now
is J and the C is also C is also the Convert
C is also starts from J, okay, great. Now,
we want it to start with two now we want this
I to start from J and move onwards here. So
let's say i in range, start from G and go
till length of L, one by one, take the step
of one. Okay, great. So what next? Now the
value will be L of I, rather than simply L
of I rather than simply I in that case, you
do this.
Okay, and the index is just C. Okay, great.
Keep on keep on introducing this index again,
after this loop, what you do is you pick the
gf value, you slap the gf value with the minimum.
And you do that. And that's it, you keep on
moving and offer after the outer loop finishes.
If you branch your list, you will be having
the list sorted or at least we hope so. So
maybe there is a bug in the code or maybe
there is a problem in the code. But we hope
this will work. What we are doing progressively
By the way, this is a nested loop. This is
a loop inside the loop and that's and then
we have an if condition inside the nested
loop. Loop inside the loop. Great. Let's see
how it how it works. If there is no Oh there
is an error length of range. Oh, we haven't
write a colon there. Don't forget this colon.
That's a problem. Oh, we have a sorted order.
Oh my god. We have a result with us. You see
the applications of this. Oh, one three is
missing. We were is three, we have two threes
Oh, the output we have written here is wrong,
there is no two threes there is only one three.
So you have sorted a list. If you remember,
we have written a similar kind of code in
the problem. So problem solving session very
earlier, where we solve this problem using
selection sort, but they are we just wrote
a pseudocode. And here we have a code much
simpler than actually the Python code. If
the problem was just sorting there are built
in functions to do that, but I'm just telling
you how these loops and if conditions and
all that stuff can be used to communicate
with each other to match with each other to
to actually perform a problem solving task
when given a problem. Although we will see
later on in Python, most of the problem solving
tasks, I mean many more of them, there are
a built in function for those that are available
functions for those you need not write all
that stuff, but to mastering to to master
any programming language, you have to go through
these constructs. So that for a new problem,
or for a very large, complicated kind of problem,
eventually you you may need these kind of
structures with you. So mastering these structures
is really essential for problem solving and
programming in general. So okay, that's about
the loops and if conditions and control. So,
all of that, in the next video, I will I will
start talking about functions. So you have
seen this L e m data function, you have seen
this range, that's that's function idolater.
Although you have seen around function, you
have seen def mode, you have seen print function,
what if we want to write our own function?
How can we do that? From the next video, I'm
going to show you how can we write our own
function? Wow, isn't that great? That's great.
So hope to see you in the next video. In this
video, I will talk about functions. A very
powerful construct in almost every programming
language. Python also supports functions.
What a function is, let me let me describe
the let me describe the need of the function
by a scenario. Let me give you a scenario.
The scenario is let's say you are writing
a very lengthy program, the program requires
to print particular messages whenever needed,
for example, you need to print this particular
message the task, the task was successful,
let's say you need to print this. And then
you have to print moving to the next task
maybe to to inform somebody maybe in to inform
your client. And then you have to ask, okay,
send me the next task. Because I am done with
the previous task, let's say you want to print
this, or maybe you want to print more or do
some more stuff. And let's say you want to
do this again. And again, whenever needed.
Somewhere, whenever you complete a particular
task or something, you want to print all these
messages, and then somewhere else, whenever
a particular event occurs, you need to print
all these messages again. Now one way to do
that is to write just these print statements
whenever needed in the program. One way is
if you want to perform a task and the task
has a lot of coding, maybe maybe maybe a very
small amount of coding or maybe a very large
amount or magnitude of the coding. In this
case, we have just three statements, but maybe
we have a task that we want to perform again
and again and it is really a very lengthy
task in terms of the coding.
So, one way to do that is to just write all
the coding in coding somewhere and define
a function and that function means the function
contain all the tasks that you need to perform,
whenever you need to perform that particular
task. Just in your coding, just call this
one statement, just this one statement, and
the whole task that is written under this
under this content maintaining this as a heading
that will execute automatically I mean, however,
I mean, that task that is under this heading
may be very lengthy may be short, may may
be complicated, may be simple one or anything,
but the need is we want to perform this task
whenever we need. And we do not write to code
this again and again we do not write to code
we do not write to we do not want to write
the same lines of codes again and again and
again. And again in our program. Just write
this particular lines of code once define
a function, just like a task. Whenever you
need to perform that task, just call the heading
or the name of the function. And the whole
task under that function will execute functions
in almost all programming languages. They
do that even in mathematics. They do that
In Python, the syntax of defining function
is you if you want to define a function, you
have to first start with D E F meaning definition
or defining, then you need to write the name
of that function the name of that function
name a function and name a variable has resemblance,
I mean, the name of functions should be descriptive,
it should, it should portray what the function
actually is doing. So, it is good to write
it is good to suggest the names of the functions
that are very descriptive to make the code
readable and manageable. So, here I have written
the function name is sprint success, you can
write any name, then you start parenthesis
then you end parenthesis and then you write
a colon like you have written the colon for
if conditions are for loops or any other constructs.
And then you do indent like the body of the
for loop like the body of the if condition,
this is the body of the function, body of
the function is all should all be aligned,
then you write all the tasks, all the coding
that you need to be performed whenever this
function is invoked or called, this body can
contain if conditions for loops inside, I
mean, this can have a whole lot of coding
inside it. And whenever you will call this
function, whenever you will type this command,
wherever in your coding, the whole task under
this will be executed automatically again
and again whenever you like. So, let's take
a look of defining our first function in Jupyter.
notebook. Let's just I guess, yes. So, yeah,
so, that's our notebook, we were populating
that notebook. So by the way, if you if you
want to know where this notebook is located,
if I want to, for example, invoke that notebook
again, when you will run your Jupyter Notebook
from the Anaconda prompt, you will be having
all the files that you are working on. And
one file is for example, this you just click
on that, and your file one or more files,
whatever you want to open up that will open
up in the Jupyter. notebook. Yes, so it is
opening up, it's a lengthy file, so it may
take may take a second. Okay. Let me just
take a better zoom level, just to Okay, so
we were working on that notebook, let's define
our first function, let's say D, F, define.
Let's say the function name is Brent. Success.
That's a, that's a syntax, then press enter,
Brent, I am done. Then Brent, send me another
task. Let's see. And that's it. Let's say
that's the, that's the body of the function,
the body of the function here contains only
two statements, okay, then you run this, you
run this command, just like Shift Enter, you
run this. So that
it is it is reported in the symbol table,
there is a symbol table inside the Python
maintaining Python is maintaining all the
variables all the function information inside.
So once you run this cell, then the then this
print success function will be registered
to Python. So that whenever you want to call
this function, again, it will be available.
Now if you want to perform this task, let's
say you want to perform, let's say you want
to perform this task whenever you want. So
you just call this function, this is called
calling of the function. whatever I'm doing
now, when success and that's it, you press
Shift Enter, and the all the statements that
are under this will be executed. And you do
some other stuff, let's say three plus eight
that is that is 11 do some other stuff. And
afterwards, if you want to do the same process
again, then you call this function again and
all the coding inside the function will be
executed it is very, very handy. If a particular
task if you want to perform that task repeatedly,
it is good to just write one code for that
task in a function and then just invoke function
whenever you need. It supplies a lot of managing
power, a lot of debugging power if you have
an error for example, inside the function,
you just go to the code we just go to the
code of the function itself and fix the error
and come back You need not to you need not
to go all over the code if you have not defined
the function and you have called these lines
of codes everywhere inside your main code,
then it will become very difficult to handle
And function actually provides a lot of a
lot of simplicity of managing and readability
and, and a modular approach in that sense.
So that was our first. That was our first
function. We will be talking about more, we'll
be talking more about this functions in the
next video. So hope to see you in the next
video. The function name should be descriptive,
that's okay. But it is further important sometimes
to have a documentation of the function sometimes
called the doc string, the doc string allows
you to write the description of the function.
But that description will never be executed,
it will be available whenever you need help.
Or you need to know what this function does.
Sometimes it happens your function can contain
a lot of code, for example, you have a particular
function, let's say, fun, let's say it contains
def, fun, and it does a lot of a lot of complicated
stuff inside. And it is sometimes required
to know what this function actually is doing.
So this document string is one way of describing
what the function is doing. You might be thinking
that if you're writing this document string
inside the where the where the coding of the
function should be written, we should open
up that the coding file and see what the function
is doing, or should we actually open up this
function implementation where the function
code is written. And then we have to read
what the function is doing. Actually, Python
gives you another power. If you have written
the document string inside, that should be
a top statement before the first coding statement.
Whatever description you want, as a document
string, it will be available without actually
opening up with without actually seeing what's
inside the funk without actually opening up
the file that contains the implementation
of this function. Let's see, let's see. Two
in Jupyter, notebook imore, completely whatever
I'm saying right now. So for example, let's
define a function. def print success. to let's
say the function name, this function is print
success to the function name is print success
two, although it's not a very descriptive
name, but the specimens are also not correct,
but that's fine. Print success to here I just
define a document Strank. The document string
may contain maybe just in one line, or it
may be a multi line, it is like a multi line
comment, or maybe a single line comment if
you want. But it starts with the three quotes
and ends with three quotes. Let's say I write
here this function is doing nothing except
renting. message, printing a message, let's
say full stop. And then I further define let's
say I define more in saying that that message
is
Hello, let's say, let's say are any description
you want for this function. Now, this is a
document string, and it will be available
whenever you need. Now here are the coding
starts, let's say you, right according here,
and again, hello, let's and you run this code.
Now, let's say we are not seeing this function
we are we are not available with this function.
We are not available with the code of this
function. And we want to know what this function
actually does. First of all, we can just write
if we write pri, and just press tab, the tab
will allow us to access all the functions
that are available with prefix pri. So let's
say we go to print success, brand success.
Brain success here brain success, as should
be capital, Brent success, let's say so print
success to let's say and we write a question
mark in front of it, and then just press Shift
Enter, it will pull the document string it
will pull the document strength whatever we
have written and we will get to know what
actually this this is doing. So this document
string actually does a lot of job further
if we I mean this is this is kind of whenever
we need to know what a function is doing.
The document string is one way to just go
and check what is what is happening. Right
now this function implementation is in front
of us But in several times, the function implementation
will not be in front of us several times,
we will be accessing functions that other
people have written in their libraries. And
we need to know what those functions are doing.
So document string is one very, very healthy
way of describing our function. And I will
recommend to make your habit writing document
strings, every time you write a function.
I was telling you that if you write a double
question mark, then it will not only pull
the document string for you, it will pull
the whole implementation as well. So now if
you see you, they said the document string,
and that's the implementation. So whole implementation
will be available, if you want. And this is
true for the functions that are that are,
that are the functions that are third party
functions, or some other person have written
that function and so on. For example, you
know, a function length, we call that function
several times. So let's let let's, let's see,
also the document string is returned, the
number of items in our container, that length
function is not written by us, somebody has
written that function that's a built in function,
by the way. And we can, this document string
tells us, okay, what this function is doing,
we don't have the implementation of that function,
obviously, somebody have written that function.
And, and if we write the double, then we should
get an implementation as long as the implementation
is not in c++, I haven't told you that a lot
of a lot of implementation of Python itself
has been done in C and some other languages
have C mostly. So several built in functions,
because of because of their speed, they are
implemented in C, and if you, if you want
to get their implementation, they get their
code, the code will not be available for most
of the functions. So that's so whenever you
write a double question mark, and the answer
is the same as a single question mark, that's
an indication that this particular function
is not written in plain Python, it is written
in some other language and is used in Python.
That's, in other words, the diversity or flexibility
of Python, you can engage multiple languages
inside, Okay, one more thing, I can write
Help, help command and I can get this Brent
success
success too. And the help of print success
to by just typing this help command. So, this
help will tell us, you see the Help is telling
us the document strike I mean, this help on
this function, if and this and this is the
function we have written, this is the function
we have written, this function is doing nothing
except whatever description we are giving
there. If, at some time, if we are supplying
this function to somebody, or making a package
of a lot of functions, that we are writing
these documents, strings will help to get
to know how to use these functions. By just
knowing the function name, we can, this document
string actually tells us how the what the
function is doing. While great Oh, by the
way, we haven't called this function yet,
we are just playing with the document string,
let's call the function print. Now we know
what the function is doing. let's print, let's
call this function. And whatever written inside
the function will be called See, this is only
called this is just acting as a comment and
it is basically a comment. Yeah. Okay, great.
Stay with us. There is much more about function
that we are going to tell you. Hope to see
you in the next video. Okay, in the last video,
we saw document strength. Or you might be
thinking, what is power of this function,
if it is doing some static task? Well, in
this video, I'm going to tell you that the
function can the coding or the behavior of
the function can be dynamic, based on based
on the arguments based on some properties
that you will be defining at the call time.
For example, the function has in almost all
programming languages, the functions, the
most interesting functions are the function
that receives an argument. And an argument
is just considered an argument just as a variable
and performs its task according to that to
that arguments. argument. Just take a single
simple example. Let's say rather than having
a function print success, we have a function
print message, and it it prints whatever message
it receives. And at the call time, for example,
we call this function like so print message.
And let's say we call this as, let's say,
success. Let's say now success will be printed.
Next time we call the function and we give
another argument maybe in a string, let's
say so 74 errors, let's see, that will be
that will be printed or anything, I mean,
anything that you supply will be printed.
Wow, isn't that great? I mean one function.
And you might be thinking the plain print
function does that what's the power of this?
Well, I'm just telling you the function of
the function does not only contain one line,
I mean, it can be a whole task depending upon
this input argument. And the whole task will
perform dynamically based on based on what
input argument you are supplying there. You
are noticing one one thing that I that I just
forgot, what is that thing I define this function?
I guess everything is fine. I just have just
missed something Oh, document string, I should
have written document string. Although document
string is not essential. If you do not write
document string, it's perfectly okay. The
function will run but it's a good practice.
It's an it's a good habit to always write
a document string. Okay, let's see the power
of input arguments by again, going to our
good friend Jupyter Notebook. Okay, so let's
see. Let's say we define a function define
Brent grant message, let's say, edit receives
an argument message. And this argument is
just a variable, it's just a variable. And
let's say we say okay, print message or further,
let's say you say, if is in stance message
spraying, if this is spraying, then simply
then simply branded. If this is not a string,
then just say okay, brand, your input argument
is not a string. And then you say, Okay, here
is what you have, slide. And then you say,
okay, whatever you have slide, just see, okay,
message. And that's it, that's it, that's
the function, we might have written a document
screen for it. The function rents the message
supplied by the user, or brains, that message
is not in the form of strength. While Don't
worry, we have to see the strings in detail,
we will see the sprint function in detail
as well, because the sprint has a lot of lot
to do with strings. So so just for now, I
mean, that's our function print message, let's
say if the message is of string type, this
string does not good, this is this should
be simply str this should not be that is instant
steak like this, your input argument is not
a string here is what you have supplied. Here
is what you have. So here, we can, we can
say here is here is here is the type
of what
you have supplied. And then we can just print
the Type, Type MSC. So the goal here is to
just create a function that prints a message
if that message is in plain string form. If
it is not a string, then it prints that okay,
you're the whatever you have signed is not
a string, it is not a proper message in string
form. Let's say this print message function
receives a string, let's say that's our logic
or something. So let's run this. First of
all, let's see what it does help rent message.
So the function prints the message supplied
by the user. We can access the same help by
question mark if you want and it gives us
the document string If however, we want The
implementation as well, then we write readable
code and implementation is also available.
While grade Python is really great. Okay,
let's call this function. Let's call this
function, Brent, message. And whatever you
want to print, let's say, this is the message.
This is the message, let's say you want to
print this. And this is the message that's
printed. Okay, now, let's say you call this
function again some time, and you supply 23.
And it will say your input argument is not
a string, here is the type of what you have
supplied, it's an integer type rate, you can
you can have, you can have, you can call this
function in the following way, let's say you
define a variable y, and the variable y contains
Hello.
Hello there.
That's it, that's your, and then you called,
then you call this function on y. And it will
print hello there, because y is also a string.
Great. So that's how you can you can you can,
you can pass different arguments and instruct
the function, how should it behave without
actually writing the whole logic of the task
again, and again, if written all the logic,
once, actually, this is actually the logic
starts from here. That's what the task is
to, that's what the task you want to perform.
And you need not write this again. And again,
whenever you need this kind of stuff, you
just call that function supplied arguments,
and it will behave accordingly you want. Great.
So you might be thinking, the function only
receives one argument, maybe we want to supply
more than one arguments, maybe, maybe two
arguments, maybe three, maybe four, maybe
five, and maybe we want to supply several
arguments. And we want to do some task based
on the values of those arguments, or those
variables. So in the next video, I'm going
to show you multiple arguments. Okay. Hope
to see you in the next video. So in the previous
video, we saw we can define a function, and
we can supply input argument to it. And in
this video, we are going to see that we can
actually send more than one arguments to the
function these arguments are just variables,
these are just variables, whatever value we
will supply to these dynamically, because
Python is dynamic dynamically typed dynamically
they are type will be defined. And for example,
here we have supplied just two variables,
and we just printed them, but based based
on supplying more than one input arguments,
and based on what logic we are going to perform,
we can do anything, we can do anything. So
guess by thumbs, allows us to supply multiple
input arguments to a function and and we can,
we can just perform all the tasks according
to whatever logic we are going to do with
that. So let's go to our friend Jupyter Notebook
and see an example of a function with multiple
input arguments. Let's say the function the
B define a function, let's say, my power,
let's say, my power, my power, let's say,
you remember there is a POW function in in
Python that's a built in function. I'm going
to write my own function, let's say it contains
a and b. Well, document string. My, this function
computes
power
just like built built in power function. Great.
That's the document screen. Okay. Now what
we want to do is we want to print Okay, let's
let's, let's create another variable, see,
that is a power B. Okay, then we print this
C, and we are done. That's it. That's our
goal. So we register that function by just
just calling the job by just pressing the
shift enter in Jupyter Notebook. And now we
check what this function does. Well, this
function can be horsepower, just like built
in power function. Okay, just to Just to remind
you again and again, the importance of document
strength, I'm writing this again and again,
let's run this function, my power, let's say
three ways to recover for illness. So the
result is 81. Oh my god. So whenever, by the
way, if you don't have POW function with you,
although you have, you can you can create
your function and whenever you want to use,
you can use your function, not a big deal.
By the way, what if you? What if you What
if, let's say, you can, you can define a function
with more than two arguments to find, let's
say, display types. That's it, that's your
function display types. And all you know,
is our check arguments, let's say, check our
x. That's it, that's your function, and A,
B, C, D, let's say E, these are the input
arguments. And let's say, at some tasks, you
want to know whether all the five variables
that you're working in somewhere, whether
all of them are numeric values or not. If
they're not numeric values, you're not moving
on, and you're doing something because you
were extra, let's say you're, let's say you're
taking input from somewhere reading from a
file or whatever. And you need to, you need
to check before moving on whether A, B, C,
D, and E, whether they are in sore floats.
Otherwise, if if if any of them is not into
float, then you're not processing, then you're
not moving on, and you're going to check the
input arguments again, and so on. These kind
of functions are there because whenever you
call certain, whenever you want to do processing
on data, sometimes it is required to check
the type of the data whether the data is supplied
in a way that you were expecting and so on.
So let's have this function check Oryx. I'm
not writing document string here, I guess,
I've told you enough to write document string
again and again. So let's see. If is instance.
A, if is instance int float? If that is true?
And 
is it let's just have three variables just
to just to focus on if is instance, a then
B. and 
is instance see if all of them are? If all
of them are? If all of them are integers or
floats, then do something then let's say Brent,
a plus b, plus C, maybe, or a plus b plus
c, raised to the power to just print their
square, let's say else are if they are if
they are all integers or floats, then do some
interesting task here some task. Otherwise,
you can say okay, print,
air. The input arguments are not of the expected.
But it's fine. You have this function, let's
say, let's call this function.
The function was check arcs. So let's check
arcs, check. arcs, check arcs, let's say three,
four, or five. So now you have all of them
are great. Let's say you have jet arcs. And
you call this check ARDS.
On,
let's say, three, four, but this five is a
string, let's say, Gee. Now we'll be having
an error. The input arguments are not all
of the expected types. One of them or more
of them or whatever. Yeah one more thing the
this function is expecting three arguments
if you call this function by less than three
or more than three arguments you'll be getting
an error for example three four although this
function is accepting three arguments, you're
calling it with just two you're getting an
error because you have not specified all the
arguments that the function is requiring although
the the arguments that you have supplied they
are of the type that it is expecting, but
you have not supplied the the number of arguments
that the function is expecting. Similarly,
if you call this function by more than three
arguments, although it requires three arguments,
you again will get an error, because it is
expecting three arguments and you have not
supplied three arguments. later on. In later
on, we will see how to write a function that
accepts a variable number of arguments, we
will see that but right now, in this particular
way, if you write the function, if you define
the function in this particular way, you have
to define the arguments the number of whatever
the number of arguments it is expecting, you
have to supply exactly as many. Otherwise
you are getting an error. Okay, so that's
about the multiple arguments. Okay, what next?
Well, next time, in the next video, we will
see that what is the what's the importance
of order of these input arguments? What will
happen if I just swapped message to win message
one? Will that will that change the behavior?
Or is there any order? With the first mess?
The first variable, the second variable, third
variable? Is there any ordering inside the
input arguments? Yeah, there is. So let's
see in the next video, in the last video,
we saw, how can we pass multiple How can we
define a function with more than one input
arguments, it is important to know that the
order of the input argument is really, really
important. So whatever argument at the call
time, for example, if you call this particular
function, the name of the function is f, that's
not a great name, you should have a name that
a descriptive but I recommend write good names,
let's say this is f, that's a function and
the very first variable is C to the second
variable c one, the third variable is C three.
Now you let's say call this function like
like this, let's say two, four and nine, what
will happen is this too will be copied in
C two, this four will be copied in this C
one and this nine will be copied in this C
three. Now, C two has a value two, c one has
a value four and C three has a value of nine.
If you change the symbols or the variables
order here, whatever order you have written
there, the first value that is passed at the
call time will be passed to the first variable
whatever the name of the first variable is,
the second value at the call time is copied
in the second symbol, whatever the name of
the symbol is. So, this ordering is really
really important. One way to work one workaround
for this is at the call time, you actually
define the variable names and their values.
For example, you call you call F and you say
okay c one has this particular value, but
this way you need to know that there is the
symbol name in definition is exactly c one.
So, C one has this value, C two has this value,
C three has this value, once you at the call
time, if you have defined your variable names
along with their values, then you are order
free. Now you change whatever whatever if
for example, you call this way c two is b,
c one is a now no matter in what order you
have called these,
this C one is going to be copied in C one,
the C two is going to be copied in C two and
C three is going to be copied in C three for
the functions that has many more arguments,
it is it is good to it is good to call the
function in this particular way. If there
is a chance that calling a function in a different
order may may may become confusing and stuff
like so. This actually gives you more grip
on this ordering issue. if if if you're if
you're happy with if you're very smart and
When you say Ok, I will always supply in a
particular order, I will always read the document
string first, and then I will call that function,
that's okay. Otherwise, this is also a feature
that is available at the call time, you assign
the values of the functions that are there
at the definition time. And now no matter
in what order you are calling that function,
see one occurs at third position c two occurs
at first position, the relative values will
be copied according to their names. So and
that's a good feature. That's a very good
feature. Let's see, for example, a running
example of this in Python. In Jupyter, notebook,
okay, define, let's say function f, let's
say it receives a, b, and c, let's say three
values. And let's say prints. A, is that's
it, Sprint, a, is a. And you'll say okay,
B is B. And then it prints Okay. See, C, C
is, whatever the value of c is, that's the
C, okay? Now, let's call this function f,
with, let's say, two, three, and game. So,
they will say, okay, a is to B is three, C
is game, fine, great. Now, this tool will
be copied in a no matter what if we if we
change this, if we change this calling order,
for example, if we if we change this order,
we just we just moved to we just moved to
this particular order, we just say okay, this
is three, this is game, this is to be called
like, so now three will be copied in a game
will be copied in B and two will be competency.
And that, if if if that is the behavior you
want, then you are good to go. Otherwise,
it is it is handy to call the function in
the following ways just fix, okay, a is a
is to fine. B is three. And C is let's say
again, if you want these numbers, now, if
you call a function like so, that will happen.
Now, if you change the order, no matter what
order of add the calling time you come up
with, it will stay the same. For example,
you go and say okay, C is at the first position.
And a is at the second position, let's say
two, and B is at the third position three,
the output will stay the same. And that's
a, that's a beautiful, that's a beautiful
thing. So that's one way of handling with
the order. If you if if you think at call
time it is important to define the variable
names, but it has one problem that you need
to know you need to know exact variable names.
If the variable name is C one there, you need
to know what it's see one, you need not to
I mean the C one matches with C it must match
with C one, C two must match with C two and
so on. So you need to know these names. Okay,
great. In the upcoming videos, more features
of functions are are going to are going to
be discussed. So stay with us hope to see
you in the next video. So we in the last video,
we saw the ordering of input arguments in
a function.
And we saw a fix to it. I mean, if you if
you if there is a chance that you may miss
a proper order, there is a way to fix that
we saw that in the last video. Here, we have
another another thing to discuss this x variable
x input argument This is the variable that
is defined inside a function although the
value it receives is copied from somewhere
else, but it is defined inside the function
that is also the function variable or the
or the variable that is in the scope of the
function inside the function in the body of
the function something like so it may be handy.
For example, let's say you want you you compute
something you do some processing on your inputs.
And whatever the result is you save that result
in another variable. And let's say now you
need the value of this variable. to do some
further process, let's say, what you do is
let's say in a call time, that's let's say
this is the this of the function and say,
This is the complete function. And let's say
a is equal to 12. And B is equal to, let's
say seven. And let's say you call the function
add a, b, now the value of a will be copied
in x, the value of d will be copied in Y,
okay, and now, you need the Sum of a and b,
to be received here, in a variable, you want
a variable in which the results should be
saved. For example, let's say a variable is
D, let's say, and then you want to do some
more processing on D, let's say d doublestar
five, mod three, and maybe you need to apply
an if condition on that if that equals to
zero, then do some stuff otherwise, so let's
say you need this variable out, what will
happen is this C variable is not accessible
outside this function. And the reason is the
C is defined inside the function when the
function body completes its execution, the
C is lost sees no more available, C is defined
when the function call has been made, when
the when when you're executing the statement
C is defined and a memory location was created
in a C sometimes called the function space
in the memory or process space that is created
in memory. But once all the body of the function
executes all the functions that were inside
the variable they are lost, what how can you
How can you receive this value? How can you
receive the value inside see outside this
function? So, that is, that is question in
this slide, how can we do that further,
this particular function can access all the
variables that are not defined in this function,
but that are available outside this function
and are defined already. For example, let's
say I have a function, f. And the function
is let's say I have a function f. And so if
this function is defined, like so f, let's
say F is your function, and it has to find
like D, E, F, and that's it. And here it prints
let's say, some variable, let's say a. Let's
now now you know this a variable is no longer
in F not even defined in F, but as long as
this a variable is defined, before calling
F for example, that's the cell where we are
writing the code and we say okay, a is equal
to seven, and then we just call this F, because
a was available before calling f a will is
accessible here. So, the functions the variables
that are available before the call, they are
available inside the functions, but the variables
that are defined inside the functions, they
are not available outside. That's the problem
further, if we define this ad here is equal
to two now, this a is sometimes called the
local variable or the function where the variable
there is local to the function. Now, this
a is is is defined inside the function and
all the accesses to a will access this value
to rather than the sound considered sound
has a separate location in memory, and this
too has a separate location and memory, both
have names a, but this a will only be referred
to when the function is executing, after the
after the execution of the function completes
this has gone from the from the memory and
this will still be available, the seven will
still be available. So it is good to know
and by the way, if a was not defined here,
and you still call F, then either you will
be getting an error, or this a might be a
global variable or available in some package
that you have already loaded or stuff like
so, in that case, this eight will be accessed
if it's a global variable or accessible. So,
it is good to know the the scope of the variables
inside the function because when you're calling
them what functions if this if x is already
defined, for example, if x is already defined
like 34 and then this x is 34, as long as
this x is not defined here, if x is defined
here, this is this x actually is the local
copy and that will be accessed inside the
function. Once the function is gone again
x will be 34. So, it is good to know the local
copies or or the function space itself. The
but but the problem here is how to access
them. This variable the value of this variable
outside the function, because this is completely
defined inside
how to access that? Well, well, there is a
fix, and that fix is called the return statement.
If you write the return statement, for example,
you return this value. So x plus y, you might
have saved these values, you might have saved
these values, for example, C equals x plus
y, that's okay. And then you say, okay, return,
see, what will happen is wherever you have
called this function, d equals add, let's
do three. Now, this value, this value C, which
in this particular case is five, that value
will be returned in D, and all the properties
of this variables are returned in D. So just
like the C is copied in D, and this is available
further, whatever you want to do with this
D. Okay, so yeah, so return statement is there.
So, in the next video, we will actually code
this in Jupyter Notebook and see the return
statement running and we will see the scope
of the variables and all that in Jupyter Notebook.
So hope to see you in the next video. In the
last video, we saw a scope of a variable particularly
if a function if a variable is defined inside
a function, is it accessible outside the function
and if a variable is defined outside the function,
is it accessible inside the function and vice
versa? and so on. So we discussed those kinds
of things, which is sometimes called school
scope of a variable. And further, we discussed
what if we want, what if we want a value of
the function that is computed value value
of some variable or some result that is computed
inside a function? What if we want that to
be accessed outside, outside the function?
So we discussed that in detail in the last
video, so let's see all those concepts in
a running form in Jupyter. notebook. So let's
see how it works. So first of all, let's define
variables, let's define a function, let's
say define, let's say, my ad. And let's say
it receives two arguments, let's say a and
b. And then let's say C is a plus b, let's
say that C are our c value, that's a c value
or some value, whatever, whatever you want
to call that value, some value. That's it.
Let's say we did, we did that. Now we want
to access that some value from outside the
function. paint some value. By the way, let's
first call this function, let's say my app,
add four values, let's say two, three. So
two will be copied in a three will be copied
in B. So then, let's access let's try to access
this value, some value, it will throw an error.
And the reason is this variable, some value
is not accessible outside this function. What
if we want to access because this is defined
inside the function? What if we want to access
this? I mean, what if we want to compute some
result and then use that result outside the
function? So the way out, as discussed in
the last video is return statement. Return
Value. And now if we call that again, let
me let me go if we call that again. Now, what
we haven't actually registered, by the way,
remember this, that's, that's a common error
I got in that era, a lot of a lot many times.
If you change the implementation of the function,
you have to rerun that cell, you have to register
the updated copy of the function to the Python,
otherwise, you will be getting errors. Probably,
yeah. What's the problem here? Now, when somebody
Oh, we, oh, there's somebody is still not
still not accessible. Because some value is
not is not accessible it is it is a variable
defined inside the function it is scope in,
its the scope of this variable, is just the
body of the function. So let's receive this
output in a variable D. And then let's just
print D and D is five. Great. So one more
thing. Let's say we define a variable here,
of variable outside the function, let's say
that's a label name. That's a very lengthy
name, but let's say that's the name variable.
Well outside the function that saves value
is three. And then
then let's define another function somewhere.
Let's see, let's define another function down
somewhere, let's say define F, maybe G, and
it receives nothing, but it prints this, that's
a variable. out side the function. And that's
it. That's it, that's a function. Now, when
we call this function, this variable outside
the function that is accessible inside the
function. So so and and, and if this function,
and if this variable is not defined inside
here, and if there is this is defined somewhere
else, and it is global or accessible, it will
still be accessible. However, if we define
a function with the same name, let's say variable,
outside, outside the function, let's say five,
now, this function will print five, if we
because that's the local variable, that's
the local variable in the function. Now, this
will be accessed in this print statement.
Let's see. Now the result will be five. But
if you print the variable outside, now the
value will be three, because this variable,
this particular variable that was inside the
function, it got destroyed when the function
finishes. And this is available again. So
yeah, so you need to know, by the way, it's
a good practice whenever you want to, whenever
you want to access a particular variable inside,
it is a good practice to pass that variable
as input argument to minimize the confusions
because this can create a lot of confusions.
So it's a good practice, although the feature
is available and sometimes useful as well.
But it is always recommended to pass the values
as input arguments that whatever you want
to access inside the function. Okay, so one
more thing, this, this function g is returning
nothing. For example, it is not returning
anything, it is just printing, let's say something,
let's say it is not printing anything, let's
say, let's say this is a comment, let's say
it is not printing anything. So this, and
then we call this and that's it. So it has
no return value. By the way, in Python, even
if you even if any function, even if a function
does not return anything, it still returns
a value, which is called none, which you can
see here. So in Python, a function always
returns a value. If you write a return statement
explicitly, it returns that if you do not
write return statement, when the function
body finishes, it automatically returns none.
Let's see the type of this output. What is
the type of this output? What is the type
of this man, what kind of data type is this?
Let's see. It's an n type, I mean, that's
a type in Python. So downs are non type, output,
how fancy Well, one more thing, the return
statement is not only used to return a particular
value, if you for example, in a particular
function, let me write a function here. Let's
say d f, that's the function is H. And then
inside that function, you do something, let's
say print, a, let's say then you define a
variable, let's say a equals to three, let's
say, then B equals let's say five, and then
you add those values A and B. And then you
do some other stuff, let's say plant something.
And then you just write a return statement
without any output or I mean it is not returning
anything. You can still you can still I mean
continue writing the function body more and
more. But what happens is whenever the first
return will be encountered,
the function returns from there. So the effective
body of the function is just that the function
returns right from there. If you return a
particular value for example C, you can receive
that value outside the function. If you do
not return anything, just type a return statement.
That means exit the function right away. It
works like the break statement and loop. Remember
the break statement it It resembles to break
Excitement bulletin means just exit the function
right away, no problem. And by the way, when
return is called the default return value
that is returned is none type if the return
is called without, without an argument here,
so for example, let's run this function. Let's
see. And let's call that function Ah, yeah.
So it prints a, then it brings something and
then it returns. And it returns, for example.
It returns nothing but anon. It returns or
not. And if you didn't see, for example, saying,
then it returns
a C, value of C, which is eight. And this
time this type, the return value is no longer
none type, it is probably an integer type.
Let's see. Yeah, here. So it's indeed a type
Make sense? Yeah. So return statement has
two purposes, one, you can return a value,
two, you can return, you can just return the
control, you can just exit the function like
the break and loops. Just Just one more thing.
return statement can return multiple values.
For example, let's say we have defined a function,
let's say J. Let's say G, G, we already have
defined, we can redefine it. But let's say
our is our function. And we just have a equals
five, b equals seven, and D equals let's say
something. And then we just return them a,
b, and A, D, and D. So return statement can
return multiple values in a sequence. Now,
if you receive those values, let's say X,
Y and Z equals r, so a will be copied in a
is a first return value, it will be returned
in X, it will be copied in x, b will be copied
in y, and D will be copied in z just as a
sequence as you as you keep the sequence in
the return statement, if you change the sequence
and return statement accordingly. So whatever
the first value here is the first value here,
whatever the second value, here is the second
value here, and so on. So let's run this and
just print all these things X, Y, and Z. So
yeah, five salmon and something. So this return
statement is really powerful. I mean, it can
return multiple, not all the languages, actually,
not all the languages, they have feature to
return multiple values. But Python does have
feature to return more than one values. And
more than one values of any type A can have
different types, you can have different types,
you can have different type, and so on. So
that's about the that's about the return statement,
as well as the variable scope. And whether
you can access a variable that is outside
the function or inside the function, and so
on, and all that kind of things. In the next
video, we will talk about what if we want
to access arbitrary number of input arguments.
I mean, we do not know how many arguments
will be there inside. But no matter how many
arguments a particular user is giving, let's
say we want to write an add function. Just
Just to give you an example, let's say you
want to write an add function that says define
add that say add to another function, add
two. Let's say it receives an arbitrary number
of arguments. D in I don't know how many and
it has some implementation, then anybody who
wants to call this add to it, if that person
gives two or two arguments, then just two
should be added. If the person gives three
arguments, then three should be added. I mean,
the person can give arbitrary number of arguments.
How can we handle that because because the
caller the this is the call, this is the call,
the caller can give five arguments, six arguments,
seven arguments. And earlier we saw in the
definition, the total number of variables
when we specify, we have to pass those many
arguments for sure. If a single argument is
missing, or a single argument is just more
than the specified number of variables, we
will be getting an error. But how can we handle
the situation where we have an arbitrary or
variable number of input arguments? How can
we handle that? So to answer this, or to get,
how can we do that? See our next video? It's
coming. In the last video we were talking
about how can we handle arbitrary number of
input arguments. For example, let's let's
say we want to write an add function. That
should be a To add any number of let's say
integer or floating point numbers that are
passed in. Remember last time, we discussed
in an earlier video, that when you are defining
a function, the total number of variables
that you are defining, you have to pause exactly
those many input arguments. Otherwise, you're
getting an error. But but this may be required
some time that we want to add a universal
kind of add function that has that has capacity
to receive any number of arguments. But no
matter how many arguments it receives, it,
just add them all and return the result. Such
a function, if available will be very, very
helpful. Because sometimes we might be calling
that function by just two arguments. Sometimes
we might be adding might be calling that function
with, let's say,
three arguments, and sometimes more arguments
or less arguments and so on. How can we have
this kind of feature available, but the implementation
is just one time implementation? Well, Python
have a very, very easy way of handling this
arbitrary or variable number of inputs. And
the way you do that is when you receive when
you are defining a function, you just write
a star, and then just Brent let's say, one
variable name, let's say arcs. And then after
that, this arts will act like a list. And
I mean, it will be having a lot of properties
are this arts has a property, this this x
like list, so all the arguments that you will
send in will be received like, like you're
receiving those in a in one list. And all
elements, which are the arguments in the list,
they are accessed by different indices, we
will see lists in detail later on. But right
now just think it is a collect all the collection,
it is received by indices, for example, the
ARDS, the very first element is indexed by
zero, it is at the zero location. At the zero
location, there is a three at first location,
for example, the location index number one,
which is actually the second look, the four
will be copied at this and so on. Now, no
matter how many arguments you pass a list,
it will be of that size, and there is a function
length le n that is handy to just check how
many arguments are there. Now if you pass
two arguments, the arcs will, the length of
the arc will be two, if you have three, if
you have passed three arguments, the length
of the arts will be three and so on. No matter
how many arguments you pass this arcs, it
will receive all them in one by one and all
the elements in that arc will be indexed by
012, starting from zero until the length of
the arcs. So see, for example, here, they
said the sum sum equals zero, let's, let's
say we want to add all these for i in range.
And inside range, we just give the length
of arcs for this example 12345, the length
of arg is five. So I will start from zero
till till four, because five is not included.
So the very first time I will be zero, and
our eggs in subscript zero is actually the
value value of the first variable, which is
three, so three is added to zero, then next
time, I will be one and add the position one
four is located. So three plus equals four,
which means three equals three plus four,
a sum equals whatever the some previous value
of the sum plus for the next time, the value
of i will be four, you know how this loop
works, we discussed the loop and loops in
detail. And as you move on, you actually explore
all these numbers. And this variable sum actually
contain the sum of all the variables. Now
you can return the sum and that at this particular
function acts like a universal guide a function
that receives arbitrary number of arguments.
How cool is that? Let's see in Jupyter Notebook
to get more convinced how it works. So let's
say we have define, let's say we have any
function, my ad, they might add, let's say
that function might add powerful, that's universal
or universal. Universal might add universal,
and it received receives star whatever the
variable name is, that you can read, you can
write the name arcs or you can write any other
other variable limits. This is this is just
this is just a name of a variable. Okay, then
let's say we have let's say we have s equals
zero, which is some, then we just apply a
loop. I guess you know, the loops we have
lengthy discussion on loops, in range, length,
that's a built in function length arcs. Okay,
then what should we do s plus equals r x
i, which means access all the elements one
by one. And this is again the same as S is
equal to s plus r x i. Either way you write
this way or that way, both ways are fine.
Then when the loop finishes, s contains the
Psalm, just return it, and you are done. Wow.
Now, let's call this add function, my add
universal. And let's call this function as
two, four and five for these, and let's just
print the result. Let's just print the result.
Okay, the result is 11. Well, because two
plus four plus five is 11. Now let's call
this function for let's say, for for, let's
say, five arguments. It works. It adds all
these five numbers. Wow, that is great. I
mean, now we can add any, we have one function,
we need not write a function for two arguments,
and then another function for three arguments,
then another function for four arguments and
so on. Depending upon the number of arguments,
we need not to write separate functions. We
have just one function working in all scenarios.
While so, yeah. That's doable. I've done in
front of you. No problem. Yeah, Python allows
this.
Yeah. In the next video, we are going to see
how can we actually handle the same kind of
scenario. But we want to handle the sequence
of the input variables in a very controlled
way. Remember, in some of the previous this
this year, in this order of input arguments,
remember that we receive three arguments and
we pass the three arguments in a very controlled
way. And then whatever these are, we don't
care whatever the order here if we don't care,
what if we want to fix the issue? Or we want
to become more careful for input argument
orderings. But then we also want the arbitrary
number of arguments. How can we do that? Yeah,
wait for the next video. And I will show you
how can you do that? In the last video, I
promised you that I will show you how can
you achieve the ordering of the input variables,
but still having the arbitrary number of them.
Remember, this looks like much familiar to
you, that's a call that can be made to a function.
And remember, the function definition in some
previous slide was like C one, C two, and
C three maybe. And then something. What if
we want an arbitrary number of arguments to
be passed, but we want their control. For
example, let's say this particular variable
symbol name that acts as a key, that's a variable
name, and that's the value. So let me call
the variable name as a key. And let's This
is the value that is copied in the variable.
That's another key that's a value, that's
another key that's a value and so on, what
if we have a lot of key value pairs? What
if we have a lot of them. And we also want
to check which value is of what key, let's
say we want to specify those. But we want
to specify an arbitrary number of them. Let's
say here, for example, there are only three,
let's say we want to pass five of them, six
of them, and then we want our function to
perform accordingly. No matter how many input
arguments it received. Yeah, and and maybe
inside the function, we may have applied a
check that if the key value is C one, then
do this processing, if the key value is C
two, then do that kind of processing and so
on, let's say, based on different variable
symbol names, we want to process the value
differently, how can we achieve that, and
still having the need that these number of
variables can be can can be in a variable,
variable length, they can be an arbitrary
number of those. So Python gives you again,
a very, very simple way. Rather than writing
a simple single star, you write a double star,
and then you receive in whatever variable
name. And now in this double double star means
you are receiving a key value pair list. It's
a list of key value pairs. We will see that
that resembles two that resembles to a data
structure in Python called dictionary. We
will see dictionary later on in detail but
right now just just consider that this input
argument this input variable C, it contains
a, it contains a list of key values pairs,
and then you just you can just iterate over
the sea you can just apply a for loop to check
the contents of this Remember, we have actually
done that kind of thing in the, in the portion
of loops. Yeah, here. Remember that was a
key. And that was a value that was a key that
was a value. And we did that thing, we could
explore the we were able to explore the dictionary,
just just using for loop. Yeah, it's the same
thing here. It's not exactly but you can think
of that that's exactly the same thing. So
you can explore that, that see looks like
a dictionary. Now this is key, this is value,
this is key, this is value. This is key, this
has value, you can this x points, the first
key, then C of x point to the value based
on the based on the key x, and then x point
to the second key, then the second value and
so on you that that is very simple procedure,
you're just printing all the dictionary, but
you can, you're printing all the variable
names and the values, but you can do very
complicated processing, if you want to, let's
go to our friend Jupyter Notebook to just
get convinced that this indeed works. Let's
see. So let's define a function first. So
d f, that's the function name is Brent, all
variable, variables, and values. So that might
be a function name. While that's lengthy one,
but descriptor one, maybe we can make it more
descriptive, paint all the variable, variable
names and values, while that's more descriptive
a guess. So it receives, let's say, doublestar.
Any variable, let's say the variable name
is again, let's say arcs or anything, whatever
you want, then what we do is for x in orgs,
just Brent, let's say, variable name is just
Brent x, and then the sprint x and then just
continue, and value is value is our eggs of
x. So let's say you, you done this, you did
this. So the variable name is this, and the
value is this, okay, and you want to do this
for all, all the all the variable and value
pairs that you that you send at the call time.
So now let's call this brand, all variable
names and values. And let's call this let's
say the variable first variable name, let's
say is a, and its value is three. The second
variable name is let's say B, its value is
capital B, let's say the third Will you third
variable name is C, its value is CCC. And
let's say the fourth variable name, I mean,
you can define an arbitrary number of arguments
here. Wow, that's amazing. That's the fourth
variable name is why its value is 6.7. And
further notice, you can you can pass variable
and value all have different types, I'm in
different number of them. And and much more.
Yeah, you can do that. So let's call this
function by just having four variables and
their values. Let's see what we got. So well,
variable name is a and the value is three
variable name is B, and the value is B, variable
name is C and the values CCC, variable name
is why and value is 6.7. You can give an arbitrary
lampi list here if you want. And Python just
allows you to do that. And it allows you to
do that in a very, very simple way. That's
amazing. That's amazing. I mean, that's, that's
why a high level language or radio, a powerful
language should should have a feature. So
Python does have this feature. I'm really
amazed. I'm really, really astonished by time.
By the way, I'm not saying the other languages
don't have this. several languages actually
support this kind of feature, but Python supports
it in a very easy way. It's very easy to do
that. I mean, it's not not a rocket science.
Yeah. Okay, so now we have had an arbitrary
number of arguments even when the ordering
is really controlled.
We have one or two more videos on functions.
Just to explain a bit more than we will, then
we will practice on Jupyter Notebook, we'll
practice we will play with these functions
a lot. And we will be calling one function
inside the other function and so on, we will
be having one better program just just program
and noodle Jupyter Notebook just to get comfortable
with this functions. But before that, let's
have one or two more things to discuss about
the functions. Yeah, let's see. So I hope
to see you in the next video. Okay, I really
want to talk about these default values for
a function as well, because that's important
and mostly needed. The default value is a
value of the input variable that you assign
well, while you are defining a function, and
if the value is, for example, if you call
this F, with let's say, the input value three,
then three will be copied in the sum and the
print will be three. But if you call this
function without the input, then this value
acts as as if you have passed this. So this
is the default value if you do not supply
the value, this is the value that is going
to operate. And by the way, you can have multiple
variables with default values, some variables
with default value is defined some variables.
With default variables, a default value is
not defined, and so on. So you can have this
one here must be taken here that the default
value, when you actually define the function,
and you compile this function, actually, you
you run the cell shift enter in Jupyter Notebook.
At that very time, this variable is assigned
this value at that particular time, it is
not assigned at the call time. So sum equals
to zero is already there, when you actually
press Shift Enter for a cell that contains
this code.
Now later on, if you pass a value, that value
will be overwritten on some, if you don't
pass the value zero will go on, it looks like
very easy, but one care that I want to mention
here that I haven't mentioned earlier, in
Python, there are certain variables that are
that are referenced rather than copied, I
will discuss the referencing in the copying
data in detail in data structures. But let
me just tell you 111 example, let's say you
define a list, let's say one, two, and three.
And then what you do you copy this list into
another variable, let's say l two, what will
happen is in the memory, this list in a particular
way, this is not the exact view of the memory,
I'm just showing you, let's say this is the
particular memory layout for which this L
is pointing to this L is label for that l
two is also labeled for that, which means
actually in memory, this is not the copy of
the structure that is made, I mean this is
not like in variables. For example, if a is
equal to three and b is equal to a, a will
be a will be a position in memory, and B will
be a separate position in memory. That is
what a view of the memory in ordinary variables
are. But there are certain variables in memory
just for memory efficient and cost efficiency
and time. People have people have designed
these data structures in a way that when you
copy them, when you just assign a variable
to another variable, the memory view doesn't
change the just it's it's another name for
the same for the same for the same memory
location. So what happens is if you change
any value, and let's say l two, let's say
l two, at the very, the zeros and add the
zero index, let's say you change that by minus
nine, the because it is the same view in memory
that changes minus nine. And now if you print
the elements of L rather than l two, you will
get the changed value, you will see the change
value. And that happens. Now why that is important
in terms of these default values here for
the function. The reason is, if you are accepting
a list, let's say the default is a list, and
you're accepting a list and you are also defining
some default value for the list. If that's
your definition, let's say then this list
this default value is assigned at the ad the
very first at the very first time, and this
L is really a local variable inside inside
the inside the memory. Now when once this
cell is run, not the call time at the at the
sowhat call the compile time, when the cell
is run this L is assigned this and that just
happens once. Now if you call this list with
some other list let's say l to let's say two
three and four. Then if you call this L two,
l two will go there it will be copied in L
and everything is fine, but don't then expect
this the contents of L to to stay same as
staying l because l is this default. values,
they are assigned just once. And they stay
as it is, every time you call the function,
they don't change. They are not assigned at
the call time they are assigned at the compile
time and they stay fixed. So that care must
be taken. I will show you that example that
particular example, in Jupyter Notebook shortly
at this, this might be confusing right now,
because we have not defined, we have not seen
lists in detail. But I just want to make this
point. I just want to mention this because
that's important difference with ordinary
variables that I mean default values, just,
I mean, just like like a value. And if you
don't supply a value, the default value just
works. But with the variable that are referenced
by variables, you may expect something else.
And the Python function behaves maybe differently.
And that's because these default values they
are assigned at compile time they are not
are compiled time. Actually, this is not a
compiled language, I should not use the word
compiled compiled again. And again, just think
when we define this function, and we run the
cell at that particular time, the default
value is assigned. And the default value never
changes. It stays fixed. Yeah. So and I will
show you that example. Why don't we move to
Jupyter Notebook and see that example? Yeah.
So or why don't we do that in the next video?
What do you think? This video, okay, same
with you. Okay, let's go to Jupiter and mode
notebook and see the default values. For example,
let's see.
Let's say we have define a function, let's
say GG, and the default value s is equal to
four, let's say that's a default value. And
we want to print let's say s, if available.
From the call time, if not available, then
four will be printed. Now we print now right
now we are going to print, now we are going
to press Shift Enter at that time, S is assigned
to for S has no value for it is assigned there.
Now we call GG, let's say and we call GG without
input arguments. Now the four will be printed.
If we call this GG with some input argument,
let's say 56. Now the 56 will be printed,
no problem, everything is fine. Let's see
about the lists. For example, let's say the
list is, let's say 123, that list, and then
l two is simply let's say l two is L, then
what we do is we change the contents of L
two, let's say we change the very first value
in L two, and we place that values minus nine,
and then we print L. Now, you might be expecting
that l is a different thing, l two is a different
thing. Because l and l two, they both are
pointing to the same memory. This, the content
through l two actually changes the memory
view and l also changes and that gives the
result minus nine in L. Well, the behavior
that I want to show you is different in the
default values. When we when we talk about
for example, let's say we define a function,
f f and it accepts a list and the default
value is empty list, or the default value
is let's say one, two, that's the default
value, let's say if, if no list is passed,
the default list is one two. Now, in this
particular scenario, if we just print, so
for example, for i in the list, brand, I let's
say we just print all the list. That's it.
Now we will press Shift Enter, and at this
time this L is assigned this value, and that's
a default value that never, that is not going
to change. Now let's say we have an L tool
that is simply let's say two, three and four,
or let's say 12, three and four. And what
we do is we call F and we just press Shift
Enter. Now, why don't we call f f without
anything. So, the default list is printed,
if we call this f f with L to the L two will
be printed. Now the notice that this L two
actually is copied in this L because we supplied
it. So l and l two you may tend to think that
l is now also pointing to L to an L has also
the same contents as l two. So if next time
because because of the behavior of these lists
because they are by Reference. Next time you
make you make might be thinking that because
l two is past there, so l two L is also L,
L two is copied in L in a memory view way
layout. So l has also the same data as l two
and next time, if we call this function without
input arguments, then l might be pointing
out to L two values. So, 12 three and four
might be printed, but that is not going to
happen, the default values they never change.
So, again, you will be getting one, two, so,
the behavior of these Reference Type variables,
that is different ordinarily, but when you
do that in in the default value structure,
that, that, that might work in a different
way. And the reason is, you, you must know
that these default values they're assigned
at, at the time when the function is created,
not at the function when the function is called.
And they are not going to change whatsoever.
So, so that was about the default value. And
by the way, the default if it was a simple
concept, I guess I have made it too complicated
by telling you layers and default values and
creation of these variables, at what time
and at the call time, I made this complicated,
I guess, I shouldn't have told you the list
values and all that stuff. But but that's
true. And in whatever I have told you is true.
Maybe I have told you in a very complicated
way, but it's true. Yeah. Okay.
One more video on the functions and then we
will be practicing functions in detail on
on Jupyter notebooks. So just be or one more
video with me. Hope to see you in the next
video. Okay, this is probably the last video
on on the functions. Yeah, we will, we will
be having one more video. But but that will
be like coding and practicing all the concepts
that we learn about the functions not? Not
something not not new theoretical concepts.
Yeah. So let me ask you a question to actually,
to actually make you understand about this
slide. Let me go to the Jupiter and ask you
about a few questions. Let's say you have,
let's say, let's say you have this particular
function, and you, let's say my ad, my ad
universal, let's say we have written that
function, maybe two or three or three videos
before, let's say you have this function,
you have written this function, and you are
very, very excited, wow, what kind of masterpiece
you have generated, it can add an arbitrary
number of values pass in it well, but this
particular function is written inside this
particular file, which is mastering Python
zero to hero. Later on, let's say two or three
months later, you are writing some code for
some, some project or you are doing something
somewhere and you are writing code, and there
you just needed.
You just needed a, you just needed a code
for adding a lot of a lot of values together.
And then you just remember, oh, I have written
some function somewhere. How can you use that
function? One way is to just go back to that
file mastering Python zero to hero, and just
copy this function, this particular this code
and paste in the new file, run that, register
that and then call that happy. What if you
want to use let's say, 100 different functions,
let's say you have written a lot of functions
in a lot of different files. And now you want
to use all of them. And, and let's say this
is a repetitive kind of demand several times
you notice that this usually happens that
this particular kind of function, you require
almost every almost in every project, let's
say a set of maybe 50, or 60 functions that
are that are required always, one way to do
that, as I told you is to jump just copy paste
those functions in every file, run them and
do that. Another way is to just just I mean,
make a module a file of containing just those
functions. And whenever any of those functions
is required, just import that module into
your coding file, which has one line of code
and then access all the functions as if they
were they were they were actually available
in in the port file that you are working on.
So that's about the that's about making modules
of so module is basically a Python file that
contains functions that you want to use in
several different coding projects or the functions
that you don't want to write in your the functions.
Having the implementation that you don't want
to write in your grant coding file, so you
can have several of those functions stayed
somewhere else in a different directory they
are residing there, whenever you want to use
any of them, you just import the whole module
and use the functions. So, so module is just
a Python file that can that can contain a
code for you that whenever you want to use,
you can use it. Normally it contains functions
maybe more than one function and several functions.
Normally, it contains functions that you repetitively
use, and that you have written once in very
careful way. And then now you want to use
it again and again in several different ways.
You need not to write the function definition,
in every coding file you need, you just make
one coding file, or that that is the most
important for you, that is called a module
where wherever you want to use any of those
functions that are there in that module, you
can call it, you can use it. So that's about
the modules we are going to make. I'm going
to show you one example of making module and
how to use that. But but to use the module,
we need to actually specify the path where
the module actually resides using this cess
module. So and then we have to do some this
import kind of commands. And then I mean,
there is some work that we need to do to actually
get this module running in our code. So in
the next video, I'm going to tell you what
that extra work, very little amount of work
what that extra work you have to do. So here,
for example, my funks.py, that's my Python
file, and it contains these two functions.
And let's say I want to use one of these have
both of these functions in some other file,
and that file contains this particular code.
So in the next video, I will show you how
to how to actually make and use the modules.
Yeah, so hope to see you in the next video.
Okay, in the last video, I told you about
modules module is just a Python file that
can contain a code that can be used anywhere,
if you want normally, that module. Normally,
the modules, they contain a lot of functions,
but they can contain variables and other values,
and so on. So think about file myfonts.py,
that contain this, these two functions, and
think about a different file, maybe Jupiter,
maybe you're working in a Jupyter Notebook.
And now you want to use these two functions.
So you first have to import another module
call the system module says you have to have
you have to make this path available. There
are a lot of built in modules that are already
there in the path all the already there in
the search path. When you want to call a function,
it is written in some module that is already
in the search path. If you're making your
modules, you have to either
either copy those, those modules into the
modules that are built in or if you want to
maintain them separately somewhere else, then
you have to add the path of these in the search
path as well. And the way to actually insert
this path is sis dot path dot append. And
then you actually write the the path of the
directory where this module file one or more
files are located. Once this is added to the
path, now you can write the import. And you
can import your file and your file as it is
or you can import your file with some other
name if you want, you can rename that on the
fly if you want. Once this is imported, now
you can use all the functions like the built
in functions, the implementation of these
functions are not there in your coding file,
you are just using those and you can now import
this module into some other file and use their
and so on. for, for, for for very large kind
of projects. It is good to make modules. Actually
it is better to make packages, which is actually
the directory structures that contain modules.
But modules at least are really good too,
for maintaining a large amount, of course,
or actually the functions that you want to
use again and again. So let's just let's let's
make a module, why not? So let's make a module.
Let's say let's go to Jupyter Notebook. Let's
create another file. Let's create another
file, let's say new Python three and let's
let's name this file as my IE let's say let's
let's name this file as my universal, let's
let's use underscores my universal functions.
Let's classify the name. Let's create another
notebook. Right now it's just a notebook that's
defined some functions. Let's say we want
to define one function as jack, all orgs.
Let's say that's the function it receives,
let's say,
let's say it receives a dictionary like input.
And then it checks the date, let's say check,
set check type of all arcs. And let's say,
let's say you write a function check, if not
numeric, let's say, let's say you want to
write a function that that just accepts a
lot of arguments. And you want to check whether
any one thought, if any one of them is not
numeric, you want to return let's say, a flag.
Otherwise, you want to return a true, let's
say, so for example, you may you may need
this function in several places. Let's say
in in your core, you're expecting numerical
inputs. And if the input is, and let's say
there are a lot of variables that you are
working on if and if any one of them is not
numeric, you might want to check all the all
the variables and their values. One way of
doing that is just to create a list. And that's
it. I mean, that's and and you may have several
of those, I mean, you can check all of them.
And maybe here, maybe here, we do not need
the dictionary kind of argument. So maybe
we just are happy with just one. So let's
say for so the output, let's say output is
let's say, R or the return value that value.
Let's say that is already true. And we will
say okay, for x in ARDS, let's say for x in
arcs. If x if is in stance, x is and float,
if that is true, then we are happy. But if
that is not true, if that is not true, then
there is a trouble, then we say okay, if this
is not true for any value, then we just return.
False. Okay, we just return false. I mean,
we need not to break anything, we just return
false return means return, whatever. Otherwise,
if we finish this loop, if the loop finishes
successfully, and there is no return statement
that is called already, then we return, maybe
true, we need to do not need Actually, this
variable. Let's see. So this function will
return true if all the variables are either
int or float. If any of them is not of this
type, this function returns false. Well, we
can have another we can have another function,
maybe we can write several function, the same
cell or in different cells. Either way, define
let's say another function, universal. Or
add all values, let's add all that's in Numerix,
and all numerix. And it also contains, let's
say, arcs. And the goal of this function is
just to add all the values and return the
sum. So let's say s equals zero for x in for
x in ogs, as plus equals to tax, and that's
it, then return us, let's say these are two
functions. And maybe one more the name of
this, or some some variable, let's say you,
I mean, these are two functions. Now we are
out of the function we are writing something
else. Let's say my name let's say that's a
variable, my name this, this does not this
my name variable does not belong to any of
these functions. And my name is Python. Course
let's say that's my. So that's it. That's
file with name my universal functions. So
what we do is we download this file as a.pi
file.pi file. So what we do really is the
Go to File, let me just zoom this out so that
you can see the download options. We go to
File Menu, we download this, as we download
this as
we download this as well as by file, so Python
file. So let's download this, or we can write
this Python file as in some other editor if
we want. So open folder, there is a Python
file here, copy it. Now copy that file. And
now you're free to go to any, for example,
any, any folder if you want, just, for example,
you go to somewhere in your directory, and
make a new directory, maybe, maybe you want
to make another directory. For example, go
and make a directory, maybe in D, let's say,
or maybe an E, let's say or maybe in C somewhere
and then make a module anywhere. For example,
in C, make a new folder, call that folder
as my, or any name, whatever name you want,
for example, my module or let's say utils,
for example, utilities or whatever name, I
mean, let's let's call it as, let's call it
as ABC, for example, ABC, whatever. And you
just made that and just copy that Python file
here, my universal functions.by. Now, if you
go back, if you go back to your there, there
is a Jupiter, here is a Jupiter. Now you go
back to your code, this is your file, go back
to your code, let's say this file is no longer
here. And what you do is you import Sis, that's
a system module and says dot path dot bend.
Right the path here where the module is located.
So the module right now is located at ABC,
this is the part of the module. Once done,
you can import what what was the name of the
module, you need to know that that was my
my word. So I just I just don't remember the
name, let's import my universal functions.
How it appears, actually, when I when I have
Eric this part, then this import command and
after the dab completion, just fetches that
file. So that that that name might be very
lengthy. So you can rename that as let's say,
my apps or whatever name you want. So you
import that once you have imported that. Now
you can use the functions if you want, for
example, you can check the implementation
of my efs.if, you see dot add Numerix, you
want to check the implementation of that.
Here, this remember this file is no longer
in this particular file is located somewhere
else. And you can call this function like
like the built in functions, my apps dot add
all numerix. And you can have for example,
let's say accepts the input arguments, let's
say 234. All that says six. And that's it.
That's the, that's the return value, you can
you can save the return value in some other
variable, let's see. And then later on, you
can print this see our do some stuff with
this. See, that's one thing. Another way of
importing the same thing is let's say you
don't want to use all the functions, you just
need this add all the metrics, let's say that's
that's the only function that you want to
use again and again. So you need not the other
functions, let's say for this particular file,
you do not need the other functions, then
what you can do is you can just say okay,
from my universal functions, import,
add all Numerix and you can rename it rename
this function as something and you can call
that function the same way. So you do that
now. You need Not to write any dot kind of
thing, you just call add all Numerix because
it is important now, and you say, Okay 234567
and you'll save that in let's a D, and then
you print the if you want, or do whatever
with that. That's it are you can import several
multiple functions or you can import all of
them. Other than modules, there are I mean,
for complex codes, I mean, this is not one
module that is there, I mean, there are several
modules. And the several modules may be arranged
in in a directory structure, where the directory
and the sub directory and the sub directory
and so on. So the modules that are arranged
in directory structure, although they are
accessed, much like the same way, that directory
structure is sometimes called package. And
these are basically the packages that are
that are most useful. And we will be seeing
some data science packages, like NumPy is
a data science package. Then, we will be seeing
pandas, that's a data science package, we
will be seeing matplotlib that's a data science
package for plotting and visualizations and
stuff. So packages, just the modules that
are arranged in directory structures. So now
you know what module is. And the old one,
Venus two, we actually missed to import the
name of have to see the name Vivi have saved
a name there as well. So let's go back. And
let's go back and do that and see how, how
many things are available. Let's go to some
other cell and empty cell. So my apps dot
tab completion, my name is available. Remember,
there was a variable. Yeah, that's available.
So the name is Python course. So this module
file does not require to only contain functions,
it can contain any information, any data that
you want to use in other files, other coding
and stuff, and so on. So, yeah, that's about
modules. In the in the next video, we will
practice about these functions a little bit,
we will be seeing how to call a function inside
another function, how to make a lot of functions
that are calling each other and so on. So
we will be practicing more on about these
functions, not theoretically, just in Jupyter
Notebook, just to get a better look and feel
of of functions more. And after that practice,
we will be then jumping towards data structure
starting from strings. So hope to see you
in the next video. Okay, before moving on,
let's just practice some, some some, I mean,
let's get a good grip on functions and multiple
functions and handling those. And the best
way to do that is to solve actually a problem.
Remember, we solved a problem when we when
we, when we are done when we were done with
if conditions, then we solved another problem
when we were done with loops just to get a
good grip on loops. Let's solve a problem.
Let's just solve a problem using using the
functions just to get a good idea of functions.
What kind of problems should be solved here?
Should we solve an older problem? Last time
we solve a problem using loops that are sorting
a list? What Why don't we? Why don't we solve
the same problem, but in a different way?
So let's go to Jupiter and see. See our file
Jupiter file? We have actually solved a function,
which somewhere using loops, just let me just
find that out. Oh yeah, they're here. So here.
So given a list of numbers, let's this make
another list or maybe the same list that contains
all the items in the sorted order, from minimum
to maximum, your result will be another list
like this. And we solve that using loops.
Okay, let's solve the same problem. Exactly
the same problems that solve the same problem
using a different way using a different user
using functions just to get a grip on functions.
So let's say that's our problem we want to
solve. So that's the problem again, and we
want to solve that. So how can we solve that?
To solve that, let's first define a function.
Let's just make a function.
Let's just make a function that let's just
make a function, let's say define, find minimum
and the function accepts a list. And we're
times the minimum value in the list not only
the minimum value of the list, but also the
position of that minimum value. So find minimum
as well as find out Some minimum as well as
the position of the minimum in the list. So
how can we how can we solve that problem?
That's that's one standalone function, no
matter what list you pass in, it will find
the minimum. Okay? As long as the the minimum
is defined for the items of the list, for
example, the list items, or let's say all
the metrics, okay, how can we how can we do
that? Let's see, minimum value is the list.
Zero, that's let's say, the minimum value.
And right now the index at the minimum value
is, let's say, is zero. Okay? like we did
in the loops, like is, it is kind of the same
goal, but let's try it a function for it.
Okay. So that's the function fine, man. So
how can we how can we proceed? What should
we write here? Let's see a counter. Let's
see. Concrete let's or it may be that city
counter right now is zero for x in L. K, if
x is smaller than our minimum value, if that's
true, then the minimum value indeed is x.
And the index where we found that is high,
okay, great. Else do nothing I mean, else
just go away. And I plus equals one. So move
on. So AI is just the position so AI is moving
on and on and on. As you follow the list,
and M contains the minimum value and Id X
variable contains the position of the minimum
value. So that's the function for for readability,
we might be adding an else clause just write
balls. And that means the if condition finishes,
I'm in do if this condition holds true, do
that stuff, otherwise do nothing. That's just
because of readability. If you want, even
if you don't write the else clause and pass
statement, even then everything is fine. So
let's call this function just to test whether
this function is working properly or not.
So let's just find, oh, we haven't returned
anything. We need, we need the minimum value
as well as the index. So return a minimum
value as well as the position so return that.
Okay. Oh, but we do view returning that inside
the loop that becomes in the body of the loop.
Oh, no, no, no, no, no, that's bad. Because
even in the first iteration, the return will
be called an even in the first iteration,
the function will finish indentation, remember,
indentation. Now that's better. Now this is
no longer inside the body of the loop. Great.
That was a bug. We fixed it, right? Okay.
So let's go find, let's receive a B, so a
will contain the minimum value, and we will
contain the index of the minimum value. So
fine men, for example. And the list let's
let's give it the list. 13423409. Let's say
now the minimum value is zero. And that minimum
value appears that 0123. That's the third
index. So b should be three a should be zero.
So let's see, what's the value? What's the
result? So Brent? A, B? So A is zero? Yes.
And the position of minimum is three, I guess
it is working fine. rate. So that's one function,
find a minimum? Let's find another let's write
another function. Swap. So define. define
another function, let's say swap values. And
what we do is it it actually accepts two indices
index one that actually accepts list then
two indices, index one and index two. And
what it does is it actually swaps the value
of index. So index, one value should go to
index two position and index two value should
go to index one position in the same list,
and then it returns the list. Okay, great.
So it would it so so that's, that's a good
example it would, it accepts a list type variable,
it accepts index type variable which are integers.
Great. So
let's continue with let's define a variable
temp that contains l ID x index one, just
store it in a temporary variable, then at
this particular index, next one, just copy
this value. Don't worry, we'll see lists in
detail. Later on now list. Now at index one,
the value of index two is copied. But it is
not overwritten, because we already have saved
the value somewhere before that copying appears.
So l at ID x two is simply damp. And now return
the list. So that's how you can swap the two
values if you want. Great. So let's just check
it, whether the two values are swept or not.
So let's say list is 236. And seven, that's
a that's list. And let's say we want alto
that is swept values. And let's say we pass
the list and we want the values to be swept
at position one, and position three, which
may add position one, the value is three,
because the position starts from zero, and
at the third position, the value is seven.
So we want these to swap. So the result will
be 276. And three, let's see what's the result?
So let's print out two. And yeah, it works
great. What else? What else do we need? So
we have find a minimum function, we have swept
values function. What else? So yeah, what
should we do? Now let's write the main function
sorting. Let's write that function. And we
will call we will use these kinds of functions
inside that function when you call these functions.
So let's define sort list. Let's say that's
our function, it accepts a list and it returns
a sorted list. Okay, what should we do? What
do you think? What should we do for the very
first time? Well, first of all, we should
check whether all these list it contains the
list contains all the numeric values are not
let's say we're just doing this for numeric
values. So, we should first check the all
the arguments are are of numeric type or not,
for that, we should write a function that
should do that oh, remember that function
is all written in in a module remember that
module we made that module ourselves? So,
we can import that module if we want import?
My remember that my universal functions and
we just need that function we just need that
function one just from from my universal functions
import what import check if Numerix check
if not numeric, as you can write that function
name something else, but justice. So you import
that function. Now you may be able to use
that function. So after that, you can use
that function. If check, if not, numeric list
or remember that function returns true if
all the values are numeric, otherwise, it
returns false. So if it is true, then move
on the if it is not true. If it is not true,
what should you do? If it is not true? If
it is not true, then you might be printing
an error. Error. Last does not contain numeric
values, maybe that and then you just return.
Return. That's it. I mean, return. Don't need
to write anything in return. Fine. Great.
So else we need not to write else because
this return will take care of that but it
is for readability. That's good, right health.
If all are numeric, then what should we do?
Okay, what should we do? If all are numeric,
what we do is we will be doing what we will
be fine minimum. We'll be finding out the
minimum and then we will be swapping the minimum
from
what should we do what we we have already
a function find a minimum that we can call
just right away we have a function swap values
that we can call right away. We already have
used this function. How can we combine all
these functions? How can we use all these
functions just to achieve the problem sorting,
we want disorder list. How can you do that?
Okay. Yeah, that's, that's, it looks like
it looks like a different thing. Maybe? Maybe.
So, let's just write out, let's just for x
in the list, let's start thinking here for
every element that is in list for x and list
what should we do? We should we should find
out the minimum and slap the minimum with
x r. So, we should find out the minimum as
well as the index of the minimum and should
slap it with with the value x and everything
will become great. Yeah, I guess Yes. Okay.
So, what what we are going to do is we are
going to maintain a counter right now, the
counter is zero, which is just the index,
which we are going to do is we are going to
find out the minimum minimum and index where
the minimum lies. So, by find minimum in the
list, so, it will return us the minimum as
well as the index where the minimum lies and
then what we do is, we will say, Okay, okay,
what we want to do is, L is actually L is
swap, swap values with index see swap values
and list with index c. So, index c should
be swapped with ID x and C plus equals one,
will that work with that work? So, after this
will the will the whole list be sorted. So,
let's return the list is that true, I mean,
we are finding out the minimum value one by
one, the only catch is the list is updated
here. And, oh, there was a problem. When we
are finding out, when we are finding out the
minimum, we are finding out the minimum from
the list. And every time the same minimum
will be returned. That's a big problem. So,
looks like this fine minimum function is not
doing our job, what we need to do really is
the, we should go to find min function and
give it that start your stock your final minimum
from a particular index. So, don't don't search
the whole list to find the minimum, start
finding out the minimum from the following
index, for example. So let's give a start
index and maybe an end index. But let's give
a starting next. So start searching the minimum
from right from there. How can we change all
the code right now? Oh, that's bad thing.
Let's change the code. Let's say that's the
start index. Start index. That's it. This
the index right now is start index and I is
also start up VB we may use a range function
here, that might be much more feasible to
us. So let's use a range function. Rather
than this let's change the coding a whole
lot. That's a bad thing we need to change
the code for i in range
starting from start index, starting starting
from start index, ending at length of the
list and doing a step of one Okay. Now x really
is x is really list at the index i okay if
x is smaller than m then this is that an index
is AI. Otherwise this we need not to do this
because this is this is happening automatically.
And rest of the story is same, I guess Yes.
That will work out. Okay, great. Oh, there
is a problem. Oh, we just missed this column
here. Great. We fix it. Okay. Now, so if value
is there, maybe this works. Maybe Doesn't
maybe there is a bug. Let's see, let's let's
just call this function. So let's call this
function l two is sort list. And let's pass
the list as to 153. Minus 870. Let's see.
That's boss this list and see what it returns.
If it returns fine, we might be happy. Otherwise,
we will see where is the bug? If there is
a bug, oh, this does not contain numeric values.
Why not? list does not contain numeric values.
Why is that happening? bliss actually contains
all the American values. We read the problem,
check if not numeric, let's see the let's
see the implementation of check if not numeric.
Let's see that. Check. If not numeric, let's
see the implementation. And there is the bug.
Because all these are numeric. So check if
not numeric x in arcs, if not is instance
then return false. So if everything is int
or float, so if x is int or float, then return
otherwise return true. So it returns true
if all our if all our numerix. So it returns
true if all our Numerix so not true means
false. And why why does Why does returning
for us? So that is just was let us just see
why it is returning false. That's that's the
bad news that something is happening wrong.
Let us just see how this is working. So that
is just check. Check, if not numeric. And
let's pass the list this list. And let's see
what is returned. Let's just print the return
thing. But it is either true or false. So
it returns a false why it is returning a false.
It is a bad thing. Why does they're turning
a false? Let's go to the File. Let's go to
the File. Here. Sorry. Let's go to the File.
Here in this directory. Let's open up this.
Maybe open this in simply an old bad. Maybe
an old bad, why not? Or maybe some other fancy
editor. Let's open this up and see what is
happening. ad format font, let's have a bigger
follow on and see what is happening.
Self face one of 20 bugs are bad, they're
really bad for x and ogs. Okay? If not is
in stance. So first of all is in stance this,
it will return true always okay. If not true,
which means false. Then we'll move on and
the loop will be running if anywhere you where
it is finding out where it is finding out
basically. So this this is working really
fine. Let's, let's let's write this function
somewhere inside our notebook and see what
is let's say rather than this. Let's say this
function like check the metric to check numeric
to check it not numeric to let's call that
function and see what happens check numeric
to it is returning false again. Why does returning
false? That's amazing. Where is the false?
So two is integer? Yes. One is integer. Yes.
So true. True. True. True. All these are true.
OH minus eight might be a problem. minus eight
might be a problem. Let's see. Maybe. I don't
know. Well, well, there is still false. I
mean, I'm stuck here. Guys. I'm stuck here.
I don't know what to do. I don't know what
to do. I have to debug this function, I have
to go inside that function and see what is
happening. So what we really are eggs. Oh
my god, the big trouble big trouble. Yeah,
I found the air. We are passing a list. And
that list is just one argument. That is not
a lot of arguments we have to pass all these
arguments in in a different way. I mean, if
you want to, you're getting you're getting
the bug, the bug is we're passing one variable,
not a lot of them 2153 817 these are not all
different variables. For example, if we just
go inside and print x, for just first x, it
is the all it is all the it is all the list.
It is all the list. It is not the variables
one by one. Let's see. Yeah, I found the bug.
Found the bug. Wait. Yeah, see, it is not?
It is not a lot of it is not a lot of variables.
It is not a lot of arguments. It is just one
argument that is in the form of placed variable.
That's incredible. What should we do? Should
we go inside and add another function check
if not Americ for lists, rather than variable
number of arguments. What should we do? Let's
write another function that check for the
list. Let's write here check numeric to it
contains the list for exam just accepts list
ello or maybe l or whatever x or art just
simply, you can call the or l list. And it
goes through all the list. And does does the
same job as previous. So now this will work.
So the function that was there in our module
is no longer working, and it will not work.
So we are not going to use the function that
is in the module, we are going to write another
function that will help us here. And we have
written that, and here we go. It just chained
that function to that. And we just we just
throw that out again. And let's see what happens
now. Oh, there was another error whichever.
Find a man missing one o v v did not find
this fireman is missing the starting index.
So the starting index is C rate.
Right? That's a problem. That's a huge problem.
Let's just sorted Oh, my god list finally
is sorted. Oh, huge, huge, huge. So you see,
you can call the functions inside other functions,
you can call the functions from modules. If
they are no longer working or no longer beneficial
for you, you can write new functions, you
can call them you can. Yeah, all that stuff.
I guess that that lengthy video taught you
a lot of lessons, how to how to code actually.
And this actually happens when you are doing
tasks that are really big. You have to define
different functions, you need to define different
functions for modular approach, and focus
on each function as a separate entity. And
that that makes much simplicity in managing
the code and bug fixing and all that stuff.
You see, I fixed the bug by just noticing
that just by just focusing on this function.
I have not thought anything else, just focus
on that function go and see the implementation
fix that everything else stays the same. Yeah,
so too lengthy a swap here. Okay, now you
have done a lot of practice about functions,
loops, and a lot of stuff. That was all the
basic programming in Python. In the in the
next video, from the next video, we will see
the real power, a much more real power of
Python where you need not write a lot of loops
and a lot of gold and still you will be able
to achieve a lot of stuff. And for that we
need to go through the data structures that
are available in Python. So from the very
next video, we will start seeing strengths
that study or structure we will see less in
detail we will see set in detail we will see
dictionary in detail we will see tuples in
detail. And after going through all these
data structures and getting a good grip for
the data structures. Then finally we will
move we will move to the packages that are
available for data science, particularly NumPy,
pandas matplotlib. And we will see maybe I
include maybe I include one or two videos
for psychic learn as well. So hope to see
you For the whole new phase in Python, the
data structures, so we'll hope to see in the
next video. Okay, let's dive into the long
awaited strings. string is basically just
a sequence of characters. And it's a data
type, it's kind of a data type. In Python,
it's much more powerful. The reason, the reason
of, I mean, making this a whole new data type
in, in almost every language is, the reason
is that almost all the data all the text that
appears in sequence of characters, so making
that sequence of corrector, the whole text
as one kind of data type, and writing special
kind of functions to, to deal with that text
might be necessary. And that's what the string
is. In Python, for example, you can declare
a string variable s, or any variable name,
by just double quotes, let's say ABC, are
our equal monthly by a single quotes, either
way is fine, d f. So either way is fine, you
can declare using double quotes, or single
quotes, either way is fine. One thing is,
be careful, don't mix. I mean, don't start
by a single quote, and think that now I will
end with double quote, and that will be fine.
So don't mix them together. If you're using
single quotes, use single quotes, if you're
using double quotes, use double quotes, don't
mix them together, that might be much more
confusing later on. So let's say this S is
a string, Python is the best language for
data science. That's a D is another string
that is defined by single quotes. In this
course, we are going to learn Python, then
you can print s, different in a different
way, let's say you will call you can call
a brand s, you can call a print to D. Or you
can just by the way, you can you can add two
string variables s and D. And the result is
a new variable. That's how the plus symbol
works in strings is plus in strings means
just concatenate concatenate them together.
So first, you just copy this string, the whole
string, and then you just concatenate the
other string with it. And the result is a
new string. Now that's a new variable, you
can use that variable and do a lot of stuff
with it. So let's go to Python and see actually,
the brains in in the strings in in the running
form. So let's say S is
string, let's say, right on is good language,
let's say. And let's have another string T,
that is using single quotes. It's good for
data science, sci fi. Okay, it's good for
data science, let's run these two, and see
the type of s was the type of s. The type
is str string, str, that's what the type is.
And if you just print s, that will be printed.
Python is a good language. Remember, so far,
we are using this sprint. And always we use
this kind of Hello or something like that.
That basically is a string because by the
way, the sprint function, actually, it takes
an arbitrary number of arguments, we can print
hello, then we can print anything in another
type, then we can print another Hello, let's
say hello to hello to that's a multi multi
variable argument function print, then we
can have another string maybe Who are you.
And then maybe a floating point number 5.9.
So we we have used these kind of, we have
used these kind of, I mean stuff a lot. We
have used print function. And we were using
these double quotes again and again. But but
these are actually strings that we will be
that we were using later there. So the spring
function actually accept strings and all these
kind of Normally, the whenever you use print,
normally you're using it normally you're going
to actually display some text, and maybe you're
writing that text into some file and so on.
So this string is highly, highly useful. Most
of the data is available in the text form
in the screen form. And we want to process
the data we want to find the anomalies in
data, we want to fix them again, we want to
stay in the text. So it is good to have a
data type that actually have a lot of functionality
that handles all that stuff. So Let's see,
for example, another another, let's see how
can we concatenate the two strings, for example,
SMT. Let's say we have B, that is s plus T,
that's concatenated. B. And that's francqui.
And we is going to get an ad. While bicon
is a good language. It's good for data science.
Well, it is concatenated. But there is no
space between two because wherever the first
string ends, the second string starts right
from there. What if we can get in a three
strings? s plus another string that just contains
a space corrector? Then this string? Why do
we whatever that is there in double quotes,
or single quotes, whatever, one corrector
to track character, all these things are called
strings. So now we are concatenated, three
strings together as a space, one space string
that contains just a space greater than T.
And let's see what happens now. So Python
is a good language space, it's good for data
science and so on. Well, so
yeah, so that's basically the introduction
of string. What if we want for example, to
concatenate? What if we want, we have a variable
A, which is 12. And let's say we have variable
b, which is the price of this book, let's
say the price of this book, and a is 12. So
let's say this is our price. Now price is
in integer form S is in book form, let's say
we want to make another string we, that contains
the following kind of thing, the price of
this book is and then whatever the private
price is, that should be there. So what how
can we do that? So let's say s, plus, maybe,
maybe another string is then maybe a space.
So that after that the price appears? Now,
if we right plus and right price, price is
no longer a string, it is an integer, and
an integer cannot be concatenated the string
in a straightforward way, like plus, how can
we how can we make a message like the the
price of this book is, whatever the value
of the price is, one way to do that is to
convert the variable price, the Convert the
type of the variable of price, from integer
to string, that means whatever the value,
in this case, 12 is written, that becomes
a string of characters one and two. And now
it can be concatenated with with the rest
of the string, and we will contain the message
that we want. For example, if we now see what
is free, that is, the price of this book is
this book is 12. Oh, we don't have a space
before. So let's let's type a space, their
space is also a corrector can be handled in
strength, while so that's how we can convert
different types to string. We can have a float
type, we can convert that to string, and so
on. Another way of doing the same or achieving
the same kind of stuff is to write Brent,
the price of this book is I mean, we can use
the power of the variable number of arguments
of then price, that's exactly the same thing.
The price of this book is 12, the price of
this book, however, consider one thing, the
print function automatically adds the space
for different kinds of arguments. You can
see that here, yeah, you need not to specify
a specifier space, the space is automatically
added if it is if it is considered to be a
different argument in the print function.
Okay, great. So that's the introduction of
a string. We are going to explore string much
in in much more detail in the upcoming video,
so stay with us, we are going to see a string
in much more detail. Okay, hope to see you
in the next video. A string might be very
lengthy, or may span I'm in very lengthy and
may span more than one lines. Or maybe the
formatting is in a way that you want to even
if even if it is not very lengthy, you will
still want the different chunks of the same
string to be appear in different lines. So
there is a way to declare multi line strength
again using either three single quotes or
three double quotes. And then three double
quotes or single quotes. Whatever convention
you follow Then you write all the string in,
no matter how many lines you want, and that
one variable actually contains a multi line
string. If you now print, for example, if
you call the print function on this multi
line, that that's By the way, a variable name,
multi line string that contains this data,
multi line, multi, multi line that now the
spelling our Spelling's around here, I just
created multi line anyways, if you if you
call that print function, this will the print
will display the string as it is like it is
there. So let's see the and by the way that
the same multi line string kind of fashioned
remember that that is used for comments as
well. If you have comments that span on multiple
lines, you can use this. So this multi line
string really is if it is not saved in a variable
and used as it is somewhere in the code, then
that acts as a multi line comment. Great.
So let's practice the multi line string in
in Jupyter. notebook. Let's see. So let's
say we have a variable A that is multi line
string. And let's say the spring is this is
line one.
Then we have this is line two, and then we
have this is last line. And this line is three.
That's it. Okay, great. That's a multi line
string. Let's see. How can it Brent a, what
happens? So this is line one, this is line
two, this is last line and this line is three?
Why this? The first this is shifted one corrector,
right? Oh, there is a space here. Let's remove
that space if not required. And run this again.
While because space is a corrector that will
be printed if you want. Okay, what if you
really want really want the following kind
of stuff, you have, let's say brand. So what
you really do is you want to bring the following
the following options are available. And the
options are, let's say dab, dab, dab, let's
see a hyphen, a. And that does play from a
that does nothing. And then we have let's
say hyphen B and they're also also does nothing.
Let's say you want our message to be painted
in in such a way, what will happen? Let's
see. Okay, the following options are available
hyphenate has nothing hyphen B I mean, all
this is a string multi line string, these
crackers that you think they are not there,
these are spaces and they are I mean the spaces
are painted here, the spaces are painted here,
we are saying nothing is printed, these are
the spaces that are printed there. So sometimes
this multi line string, it helps to format
our message in a way that we like. So that's
how helpful in most of the cases further if
you write this multi line, by the way, if
you write this multi line, comment in the
start and end of any good script. That means
the if you write this multi line way of defining
the strings at the start and end of any good
script, that code script is commented that
we have seen several times earlier as well.
So, for example, in problem solving, remember
that we define all? Oh yeah. So that's the
comment. That's a comment. Even if some code
is written inside that will not be executed.
Right. Okay, so that's about the multi line
string. In the next video we will see because
because the string really is, is basically
a collection of all these characters. What
if we want to access a particular character?
For example, this is the first graduate is
d here, the second Gregory is at the third
correct? Is it the fourth record is S, the
fifth Gregory space and all? What if we want
to access particular characters inside the
string? Because the string contains a lot
of directors? What if we want to play with
some of the directors inside the string? How
can we access different directors for example,
if we want to access seventh director of the
string, how can we do that? So, let's see
in the next video, how can we index different
characters inside a string, I hope to see
you in the next video. Okay, in this video,
we are going to actually access different
characters inside the string, sometimes called
indexing, the term slicing is basically more
relevant to arrays, lists are actually the
immutable structures, but we will see,
I'm just comparing, because you may listen
this term slicing again and again, but really
this indexing but we will see the indexing
or slicing sometimes is you these two terms
are used interchangeably, we will see the
examples of slicing in detail in lists. And,
and in more detail in NumPy arrays. But here,
you just think that indexing and slicing are
the same things. index. So for example, I
have this a let's say this is a array, and
I want to access its fourth element here,
the fourth corrector element is E. By the
way, this a is a variable, if I want to access
the very first corrector the the indexing
the number, the positioning starts from the
integer zero, that's the first corrector.
So if I want to print out of it, that will
print g if I access for example, if I write
the index three, what do we mean that means
the fourth element, the fourth element is
he what will be printed, what will be printed,
if I access the fourth element of the index
for a fi access this thing or space will be
printed and you will be seeing nothing because
when a space is printed, actually, nothing
colorful is printed there and you might be
thinking Oh, nothing is printed, nothing,
nothing has been accessed, actually a space
corrector have been accessed. So yeah, a more
we can we can we can actually access, we can
actually access a substring inside a string
as well. For example, we want to access for
example, a substring starting from index three,
and all the way up to index eight, but does
not include the index eight. So it will include
the corrector at index three, which is he
correctly at index four, which is space, let
me write space in this way. Director at index
five, which is Oh, correct, read index six,
next record, which is F, then a space, which
is seven, and then the correct read eight.
And so this is not included, to be accessed.
This is included, this is inside, this is
included. This is not included. So we can
access a substring. So starting from three
and ending at eight. Let's see, let's see
an example. And you'll come back to this slide
again, after after a few minutes. So let's
say we have a spring as let's say, how are
you? And who are you? That's it. So let's
do that. So spring, okay. And what do we really
want is we want to access for example, the,
we want to access the element to access the
elements, you have to write the square brackets.
That's a standard notation. In Python. Whenever
you have a collection and you want to access
different elements, that collection might
be a string that collection later on, we will
see might be a list. Maybe a tupple dictionary
may be a set. Maybe a NumPy array may be a
panda's structure, I mean, anything that is
a collection, normally it is accessed by It
has different elements, and we want to index
them. The indexing division is square brackets.
And indexing always starts from zero rather
than one. In Python. There are some languages
in which the indexing starts from one for
example, MATLAB, the indexing starts from
one but in Python and in several other languages.
The indexing starts from zero, which has some
benefits or starting with one it has some
benefits. So starting with zero is okay is
okay. So let's say we want to access element
at index five. The element at index five is
actually the sixth element in the string starting
from zero. So first, second, third, fourth,
fifth, sixth, so our will be printed. So let's
see. Our is printed. Let's check the let's
check the type of this return value. Let's
check the type of this this one element which
is our what is the type of it subtype of different
elements in a string different characters
in a string? What are the types
So what is the type of it. So the type is
also string. So each and every corrector is
also of string type. In some other languages,
the type might be a corrector. corrector is
another type, but in, in Python, each and
every one character is also a string. More
than one. correctness is also string, as long
as they are accessed from a string. Okay,
let's access for example, the element number
three to element number, let's say eight.
So the result is our so element number three,
not three, actually starting from index three,
which means the fourth vector, which is space,
and then e, r, e, and then space, and then
we finish. if you for example, move to from
three to nine, let's say, and the the rally
will be our why or we may move to from for
example, we may start from the very beginning.
So for example, index zero, we may end at
the index 10, but not including the 10. So
the result is, how are you and then I mean,
why Oh, and not the you included, because
that's index number 10. And index number 10.
The last index is not included. Great. We
can have negative indices in strings as well.
So a negative index is just just the indexing
from the right side, not from the left side,
for example, on negative index. So minus one
points to the last corrector. For example,
you similarly minus two points to the second
last corrector, and so on. So minus one, that's
a success, you. And similarly, we have minus
three, and that will access why, or we may
have start from let's say, minus, start from
let's say, minus eight, and go till minus
three, that means go back to go back to minus
eight index, and then move to minus three
index, okay? And minus three. In this case,
let's see what was the result are, what is
that? Why are? Oh, this are, I guess this
are? Let's check it out. So this is this,
you, this is minus one minus two minus three,
that's an X number three. So three is not
included. minus three is not included. So
it has to stop here. Okay. That's minus four
minus five minus six, minus seven and minus
eight. Oh, great. So that should be printed,
it has printed. So let's say we have rather
than minus eight, we start from minus 12,
and be raised to minus three. So we're okay.
Great. So we have negative indices as well.
And by the way, this kind of fetching this
kind of substring is sometimes called slicing,
I mean, we are just fetching the slicing,
although the term slicing is much more popular
in, in in mutable data structures. What What
is a mutable data structure? What is an immutable
data structure? Well, yeah, I should tell
you right now, you can change, you can not
change any corrector in the spring. That might,
that might look like a bad news for you. But
once the spring is created, the elements in
the strings are not changeable. So for example,
let's say at position number one, you want
to place a corrector. Let's see, that's not
possible. And the reason is, the string is
a data structure, the string is a variable
type a data type that is immutable, immutable,
are unchangeable. Once created, you cannot
change its contents, they stay fixed, you
cannot change them, you cannot alter them,
you you cannot delete certain contents from
it. I mean, once created, it stays as it is,
you can copy this into another string, you
can copy and paste, but you can get a substring
and copy into another variable, for example,
but the contents of s cannot be changed.
So all the kinds of data types in Python that
are unchangeable, the contents are not changeable.
They're called immutable. And string is immutable.
So so the the time slicing makes much more
I mean sense or it is more popular in the
data structures that are mutable, that are
mutable, although, you can use time slicing
indexing both interchangeably. But it refers
to roughly in reference to fetching the sub
structure or substring. In this case, in the
list, it will be a sub list or so on. So that's
what slicing is. Yeah. Great. Why don't we
do some more fun with this spring?
Yeah,
let me show you more fun with this rank, more
indexing, let's say you start at index zero,
you go to index 12, but not including 12.
And then you jump, you take a jump of two
rather than one, what we'll do is, it will
fetch all the corrector starting from index
zero, all the way to index 12, but not including
12. But it will take a jump of two rather
than taking the jump of two. So first greater
than take a jump of two, then pick a corrector,
then take a jump of two and then pick a corrector.
So it will actually pick every other characters
starting from zero. So let's see that. So
for example, if you remember the string, that's
the string. So it starts from h Fine, then
it skips Oh, and go to W, then it skips bass
and go to a then it skips R and go to E then
a skip space and go to u and then it skips
Oh, and go to a shoe and then the cloud achieved
and we stop there. Wow. So the general way
of slicing or indexing the general way is
you have a starting next start, then you have
an index and then you have a step size. If
you do not mention the step size. the step
size by default is one that we were doing
already. If you do not mention the end, the
default end is the building and the total
list size. If you do not mention the start
the default start is zero. For example, let
me make that a comment and just practice a
few for example. Let's start from zero we
do not mention the start let's start from
zero and go to 12 if you do not mention the
starting index that starts from the very beginning
zero go till 12 Okay great. If we do not mention
For example, we start from three and we do
not mention the end that means go till the
end starting from index three including the
last corrector Okay, if we do not mention
the step for example, if you start from one
go till 12 and we do not mention the step,
the default step is one okay. There is one
way of reversing the string, I mean very beautiful
way I mean, you do not you do not start the
mention and you do not mention the start,
you do not mention the end, and then just
take a step of minus one in this particular
way. The Start and End index they are they
are just swept and you get the string reversed
way. While so that's the reverse great. Isn't
that fancy? Yes, it is. Okay, a lot about
indexing, you can find out the length of any
string by using l m function, you can find
out the length of any substring if you want
to if you have a substring using again a lamp
function, alien, that's okay. Okay, and now
you've seen how to access sub strings and
how we cannot change the elements of a string
because it is immutable, but we can access
them, we can access them, we can just display
them, we can analyze them and so on. In the
next video, we will see some functions that
are supplied for string processing, what we
can do with strings, I mean how can we manipulate
those strings, although we cannot manipulate
the contents of a string, but we may copy
a string we may get explained, manipulate
it and save it to another variable and how
what kind of functions that are available
in string in string data structure string
data type. So let's see that in the next video.
Hope to see you in the next video. Okay, let's
see different functions that are available
to play with the strings. In this dense string
data structure, let's say you have the string
a a lot of spaces, these are a lot of spaces
at the beginning and these are a lot of spaces
at the end there are some spaces in the middle
as well. So, there is one function called
strip all the functions of the string they
are called by taking a dot A dot something
These are called methods you can loosely call
them functions, but those kind of functions
that are related to some data structure and
called with dot, they are sometimes called
methods. The term method is more related to
object oriented programming actually string
is a class. So all these are the methods But
even without knowing that it's perfectly okay,
you can call it method or function that's
perfectly okay. You can, I mean, it's okay.
It's okay without knowing what a class is
without knowing what an object oriented programming
is, this a dot some function that operates
on this a.
One difference with method and function is
when you call a function with a dot, and you
call some function that say, a dot strip.
Then inside the definition of the function,
this a object or the a variable is available,
like, like you have passed that variable as
an input argument. That's all you need to
know about the difference of matter and function,
the rest of the story is perfectly okay. Even
if you don't know that that's fine. Okay,
eight outstrip, it operates on a which means
that a is passed in this function as just
as input argument or it is available there
inside the function implementation. And then
the script function, what it does is it removes
all the spaces that are in the beginning,
and removes all the spaces that are at the
end, and returns another string that has that
has no spaces at the beginning and no spaces
at the end, and the new string is copied or
created in a variable b, let's say whatever
that we believe we can, we can have another
name of that variable. So let's see. Let's
see the running form of this script function
in our friend Jupyter. notebook. So let's
say a is a string variable. That's a lot of
spaces abcdef, a lot of spaces and hg gilwell,
whatever. And then a lot of space, and that's
it, this is a and then we have B, let's say
a dot strip. Okay, and that's sprint B. So
b is actually everything without spaces without
the starting spaces. And without ending spaces,
it does not hurt the spaces inside. So that's
the script function, sometimes processing
the data. When we when we read the data from
a file, it may have a lot of spaces at the
beginning at the end, maybe due to formatting
issues or something like so and it is this
function is available. If we want to remove
those spaces from beginning or from the end.
Let's see more functions. Another function
is lower, like the name suggests it actually
it actually converts all the string to lowercase.
For example, let's say we have a string, let's
say, a B, A, let's say we have a string, a
equals A, B, C, D, E, F, G, and some directors,
some other directors and Q f, let's say that's
a string. And now what we do is b equals a
dot lower. What it does is it converts all
the string to lowercase. For the characters
that are already in lowercase. It doesn't
hurt it. For the characters that has nothing
to do with lower uppercase, it doesn't hurt
that all the characters that are not in the
lowercase and can be converted to lowercase,
those are converted to lowercase. And this
is available. Yeah. Great. So similarly, we
have another function called upper for example,
C is equal to a dot upper that the like the
name suggests, it converts all the characters
to uppercase. Well, let's see more functions.
Oh, there is a function replace the Replace
function. What it does is it takes a substring
and replaces that substring with another substring.
Okay, let's see. For example, let's say we
here we want to be have the same a, let's
say the a is this thing. Let's say that's
a and what do we want to do is we want to
replace the semi colons let's say with with
with the semicolon, we want to replace the
semi colons with statics. So what we can do
is we can say okay, d equals a dot replace,
replace the semi colon with with let's say
steric. Or, yeah, so let's see what D is.
So each semicolon is replaced by a steric.
By the way, if you if you want to replace
for example, a, a dark replace, if you want
to replace one is there one semi colon One
semicolon with a string. For example, the
string is star star, and, and hashtag or some
person. That means one semicolon will be replaced
by this, seek with this string, and the other
semicolon will also be replaced by this screen.
And the result will be as expected, each semicolon
will be replaced by the screen. And that's
the result what it is further if you want,
for example, if you want, for example, let's
say d equals a dot replace, if you want this
particular substring, that contains the two
semi colons, if you want the two semi colons
to be replaced by another substring, let's
say two semi colons, let's say. And that is
also possible I mean, you, you replace one
substring with another one. Right? There is
one more function called split. That what
it does what what the split does is, for example,
you have a string, for example, let's say
a equals a string, let's say, ABC, then you
have this colon, then you have d f, then you
have semi colon, then you have ads g y, there's
Dan semi colon, then you have y y 3223. That's
it. That's your string. Let's say you read
that string from some CSV file and disappears.
And now what you want, you want all these
values to be separated out that are that that
are separated by the semicolon, maybe these
are different values, ABC is a different value,
then it is separated by a semicolon semicolon
may be an indication or token that the next
value started and so on. Let's say you want
to separate them, let's say you want to just
split them all of them with a particular splitter.
And here, let's say the splitter is semi colon.
So what you can do is you can have a list
and a dot split. And in the split, you can
specify the corrector that that is used for
splitting after and before we split that.
And remember, the split function actually
returns a list of strings, where this is the
first element of the list, this is the second
element of the list, this is the third element
of the list, this is the fourth element of
the list and so on. Because once you will
split, you will be having different elements
that are split it out. So if your brand for
example, l we will be having a list of different
strengths, ABC and all that, Oh, don't worry
about the single code, the single core and
double core is the same thing. Now we can
access for example, the third element or or
maybe the second element by index one. And
the second element here is D, E, F, and we
can work more on that. Okay. Is that it? I
mean? Are these the only functions that are
available? stripped function lower a birthplace
and split function? Or is that it? That's
all the spring is about? Maybe there are more
functions? How many functions are there in
string? How can we use them? What are the
what are the total number of functions? Where
is the list? We visit documentation? Should
should we follow some book? Should we go to
some tutorial and find all the string functions
and see how to use them? Well, if you want
to do that, you can do that. But there is
another smart way. Let's say a is a string
that you know, you write a dot and then a
press tab, and all the things that that are
there in in string, they will they will appear
in front of you on several things. You can
go to this, you can go to that you can go
to that and so on. So just you can check the
documentation of a for example, if you if
you press a and what it does, let's see. It's
a string object and all that stuff. Fine.
It's a string. So further what we can do.
So let's say a.we, press A and then we press
tab. Is there anything that starts from a
Nope? Is there anything that starts from B?
No. Is there anything that starts from C?
Yes, capitalize case fold center count. These
are the functions that are available that
starts from C.
Okay, let's focus on capitalized. Okay, what
is that thing how to use it? That's press
colon, question mark and see what this is
and what it does. Okay, so here is the documentation
here is a doc string returns capital. I used
to worry enough the string capitalized version
of the string. Is that the same as upper?
Maybe? So let's see. Now we know what it does.
Let's just check it out, print a capitalized
and see what's the result? Oh, it's got Oh
no, it does not get delays the whole screen,
does it? Did they the screen a was it does
not capitalize the whole string? What What
is a? Let's see what is a? A is the following
string is the following string, so it does
not capitalize the whole string. Oh, the difference
between the capitalized maybe? And the upper?
Is that the capitalize when it encounters
when it encounters? No, no, no capitalized
just capitalizes the first corrector. Let
me let me read the doc string, again, returns
a capitalized version of the string, more
specifically make the first corrector have
uppercase and the rest lowercase. Okay, that
means if we have a string that has a mix of
values, the capitalized will do the following.
It will convert the first character to uppercase
and all the rest of the characters the lowercase.
Wow, that's awesome function. For example,
if you have string, abs D, A, B and GG, kill
that say. And then we call capitalize, capitalize,
let's say. So what that does is it actually
capitalizes the first director and all the
rest of the directors there as it is. And
there are other functions as well, a dot A
dot, let's see count, what it does a dot count
what it does not count. What is that thing?
Let's check it out. Or maybe we can check
that out using help. What is zero count? So
let's see what is a load count. It's a built
in function called matters is an instance
of and it returns a number of non overlapping
occurrences of a substring. Sub in Oh my God,
if you I mean, that's what it what what is
written there, non overlapping apprentice
of a substring. Great Oh my god. So basically,
there are there are a whole lot of functions
of strings that are available, there are several
use of the string, there are several ways
of molding and playing with the strings, some
of the functions that are available, some
you can make your own, you can make your own
modules on top of that, to customize your
written to customize according to your requirements.
A lot of these are available, and you should
know how to use them. And first thing if you
want to do something with strings, or with
any data type in Python, first check whether
some method is available or not. And one way
to go that is just right away from here. And
other ways to go to internet and see I want
to do this in Python. with strings, whether
there is a function available or not the good
chances are there will be a built in function
that is available. And in that case, I will
encourage to use that function rather than
to write your own one because using the built
in function, or the method that is tied up
there will be much more faster probably than
the function you will be writing at your end
even if you're too smart in algorithms. So
yeah,
so that's about the spring matters, there
are so many other methods that are available.
In the next video, we will see some more some
more manipulation and processing and some
more working with strings. And then we will
move to other data structures. Okay, hope
to see you in the next video. In the last
video, we saw some methods of string. And
these are just a few of them, a lot of them
are available. We just we just discussed some
of them. In this video we are going to talk
more about strings in a particular way. For
example, what if you want to find out whether
a particular substring is there in a string
or not. Let's say you have a string and you
want to know whether a particular substring
is there inside a string or not? Well, you
can easily find out that using the end keyword.
And similarly not in means the reverse of
that, or the complement of that or not of
that. And in keyword always will return either
true or Boolean or false. If it is inside
the screen, it will return true if it is not
inside it will return false. So let's check
this the implementation of that in, in, in
Jupyter Notebook. So let's see. So let's say
we have a string ABC ABC. And we want to check
whether this string is there in this particular
string or not. So the return value is false
because ABC as a substring is no longer there.
A is there. For example, here, a B is here,
but ABC is no longer there. Yeah, so if we,
for example, have an ABC somewhere, at least
once, then the result will be true. In the
last, in the last video, or maybe in the very
first video for strengths, I showed you that
you can use plus with strings, can you compare
two strings using less than or equal to? I
mean, how to compare two strings, whether
they are same or not, for example, ABC, that's
a that's a string ABC, I want to check whether
that string is the same as ABC or not, what
will be the result? So so so the question
is, is this double equal to is used can be
used for comparing two strings? Well, the
answer is yes. Or what will be the meaning
of less than a string as less than the other?
Is that true? For example, ABC, is less than,
let's say d f. Is that true? If it is true,
for example, what does it really mean? How
can we define one string is I mean, this string
is less so than the other string, maybe this,
maybe this operator is working based on the
length of the strings. But if even if that,
then this length is the same as this length.
And to be more precise, we can change that
length, for example, by just saying, okay,
ABC, D, F, G, H, I, and I guess this string
will be still smaller than the right string.
So how this comparison is working? Well, I
guess the comparison is working based on the
based on the alphabetic order, and you know,
the alphabetic order, a B comes first and
B and C and all the alphabetic order that
is there in English dictionaries. That's how
the strings are working here. And the alphabetic
orders for all the special characters will
also be defined in Python, for example, that's
a special graduate, for example, maybe this
string is this string smaller than the following
string. Yeah, we've done for false, because
there is particular ordering. In, in Python
that is defined for these characters that
this becomes first and there's like, a becomes
first and B, B becomes first and C and so
on. So whatever the alphabetic order is, based
on that, or you can compare the two strings,
no problem. So these are also available. And
the third thing is in function that is also
available to check whether a particular string
is inside a substring is inside or not to
in another string. One more thing that I want
to talk about in that, for example, what if
your goal is to print the following, let's
say let's say you want to print the following,
we are learning. And let's say you want to
print the string in double quotes. We are
learning string here. Let's say you want to
print this, you want this string to appear
in double quote, how can you do that in Python?
Well, it looks like same. What's the difficulty?
Let's Let's call the print function. And then
just like here, we are learning. Then write
the double quote here, scraping. And here.
That's it. But there is a problem. The reason
is, the reason is when we call this, when
we write this double code, actually, the string
ends here, exactly the string ends here. And
when we write this single code, and this double
code, another string starts here. And this
is no longer a string. I mean, what it has
no data type inside. Well, how can we then
insert these double quotes inside? Well, there
are several ways. One way is to use escape
sequence and escape sequences just like it
is you use a slash and then whatever you use
is considered as a corrector. Inside the string
that is you're using it now if you want another
double quote, you use a user corrector which
is the backslash or maybe a forward slash
and if you use that That means that means
whatever that is coming in front of it should
be used as it is, rather than, rather than
considering that that's a special string defining
symbol. Now in this particular case, you'll
be having your double quotes available, and
the backslash will be just out, it's justifying
that don't touch this double code, it has
nothing to do with defining a string. It is
just because I want to highlight this word.
Another more. Another more easy way is to
use the single quotes, for example, we are
learning and use the double quotes as a corrector.
Inside that now the single quote, wherever
it starts and ends, they defined the string,
everything else is correct. We do not need
a escape cracker where we where we want, okay,
great. But there are a lot of escape characters,
for example, we have V, our backslash n, that
means go to new line, we are now on an other
line. So this backslash n actually puts everything
that comes after to a new line. That's an
escape corrector. Similarly, we have an escape
corrector, backslash D, that actually inserts
a tab. Whenever we want Sophie, then a tab
then now on another line, now on another tab,
whatever. So there are a lot of escape characters.
I'm in backslash, N, backslash t there are
other. So it is good to know those. One more
thing that is important. For example, let's
say you want to print. Let's say you want
to print some address on the right, let's
see, Mac's slash back slash forward slash
whatever that is called name, backslash Dr.
Let's say you want to do that. And your goal
was to just print that box, what will happen
is this backslash n will be treated as a newline
escape sequence. And backslash n will tell
Okay, go to the next line and create the rest
of the things. But because backslash D is
not any escape sequence, it is not listed
inside, it is treated as it is and that way
this slash is also treated as a director.
But here because if this slash followed by
this n, that's combination that is already
there for a new line that is treated in a
different way. If you want this to be used
as a deus and you don't want these, you don't
want this behavior, you just want that all
this should be greeted in a very literal or
raw sense, then you should just apply and
are there in our will tell, okay, that's,
that's a raw string, everything inside just
treat that as a raw string, there is no escape
sequence inside. Great. So and there is much
more about strings, we can talk but that that
was the most important that I that I told
you, at least to me, we can explore this more
actually, you should now explore the smaller
What are other functions of string, how can
we play with strings in another way and stuff
and
so on. If I talk about strings, I can just
I mean, I can give a whole course on strings
as well. But here I just give you a snapshot
of strings. If you need more about strings,
I mean you should be searching on internet
of seeing documentations and seeing basically
what you want according to your requirements,
search the functions probably they will be
available. Okay. In the next video, we are
going towards list topples, sets and dictionaries
some other data structures that we were talking
about earlier, we will be going to explore
them in more detail from the next video. Hope
to see you in the next video data structure
informally or in a very naive sense is basically
a collection of a lot of basic data types
that contains data one structure contain a
lot of data. And we can define sometimes several
methods and several specialized kind of functions
are customized and define just because of
that data structure to perform efficiently
different kinds of I mean for different kinds
of tasks, we may have to define or we may
have to choose different kinds of data structures.
The basic data structures that are available
in Python is a list tupple set and dictionary.
These are the basic data structures that are
available. We can create our own data structures
if we want to. But most of the problems almost
all of the problems mostly they are solved
by these four basic data structures. Although
a lot of these are not that efficient. There
are efficient ways for customized kind of
problems, we will see that efficiency when
we will deal with the package NumPy that is,
that is faster than all of these, but will
but we will see what kind of constraints are
there to make it faster. Anyways, data set
in a very loose term is collection, it is
a collection of a lot of values a lot of data
inside. And all these data structures list
tupple set and dictionary, they they are a
collection of data of heterogeneous types,
which means one value can be integer another
element let me call an element, another element
or item, another item or element can be of
string type, another element can be off, let's
say floating point number another element
is a whole list itself another element is
a topple and so on. So different elements
can be of different types. And that makes
this heterogeneity that makes these four data
structures much more applicable and much more
abstract. And they can be applied to almost
all the problems. So let's see one by one
and let's compare them together because the
best way to understand four of these is just
to compare them which can do what as compared
to the rest. So let's let's compare them and
learn how can we use those in detail. So list
first is list list is ordered ordered here
means it is indexable which means there is
a particular element number one is at position
one element, there is an ordering of elements
first element second third 25th element, there
is an ordering of element with respect to
their position. So that's what we mean by
ordered changeable or sometimes called more
more reasonable term or more usable term is
mutable. mutable means once the list is created
as contrast to string, once the list is created,
you can change its elements for example, you
can change the third element with another
element and that's perfectly fine you can
change it that what we mean by changeable
or more popularly called as mutable duplicates
means the list can contain more than one one
element more than two, I mean, at the position
number three, you can have the same item and
position number five you can have the same
item that so the duplicates are allowed tupple
however, although ordered, there there is
an ordering of elements there is there are
indices of different elements, this is immutable,
you can once topple is created like strings.
Once the template is created, you cannot change
different elements in the tupple you have
to create a new topple if you want to, but
you cannot change the items in the tupple
and the duplicates are allowed again set on
the other hand is unordered which means there
is no indexing there is no positioning, there
is no first element there is no third element,
there is no Fifth Element, there is that's
a collection without it without actually indexing
because you cannot access a particular element
with index you cannot change it, but what
you can do it you can insert more elements
and you can remove existing elements if you
want to. Again, the set like in mathematics
sets does not contain any duplicates. So one
item appears just once we will see the examples
Dictionary of very, very, very powerful data
structure. Again, it is it is dictionary is
just like a set, it's a set it is unordered.
Again, chancer bow, you can change them but
you can change the items you can and the dictionary
the pocket and it does not have duplicates,
because it's it's basically a set it is just
like I said, the power of dictionary is each
item consists of consists of a pair and one
one value in the beer is called key and another
is called the value for example, well is key
for 12 name is key for band and and so on.
So we have seen this dictionary before in
loops and stuff in just a very loose way.
But then that's really a very, very powerful
data structure. And later on we will see in
pandas basically all the data is basically
managed, just like a dictionary if you if
you have a good knowledge of dictionary, you
will be having a very good grip very quickly
on on a Big Data Science Library or Big Data
Science package which is called pandas because
each and everything in pandas is handled just
like you're handling a dictionary. So it's
it's a really powerful data structure to know
about.
So, so so
list is mutable dictionary is mutable set
is mutable, in a sense that you can insert
and remove elements. topple is not mutable.
And that's a comparison theoretically What
is there, all these types, each and every
of them is a collection of different values.
And the values can have different types. That's
the that's the abstract power of all these
data structures. So, in the next video, we
will, we will, we will actually try to get
a good grip on list topple set in dictionary
and we will actually define them code and
access different methods of those and we will
be we will be trying to become comfortable
with with these data structures by coding
them in Python. So hope to see you in the
next video. Okay, continue in previous video
we were talking about data structures in the
last video. So let's go to the Jupyter Notebook
and see how a list can be defined or declared
how a tuple can be defined or declared set
and dictionary, let's see how can we make
these data structures in Python? So then one
by one, we will compare how can we access
elements of the list? How can we insert more
elements in lists tuples are in dictionary
and and see the comparisons of all these one
by one operation by operation. So let's see.
So let's go to Jupyter Notebook, our friend
this file is getting lengthy, lengthy, let's
let's make multiple files. Let's say this
is part one. Just save it. And let's make
another let's make another file. For example,
let's just close this file, or maybe state
opened, let's close this file and make another
file. Python three. Yeah, so let's name that
file as this part two, let's start a new file
that that file was on in that was okay to
stay with that file as well. But just let's
make another file. Okay. So that's just have
a markdown cell. And let's have a heading.
data structures. Remember the markdown cells,
I just introduced them introduce those just
in the very beginning. And then we just forget
them. Because writing these description again,
and again, we'll make the video length here.
And the purpose is not to actually format
the notebook, the purpose is just to show
you the power of Python. So I just omitted
writing these descriptions more and more,
but just write a few descriptions in the star
and then we will forget again. Oh, that's
it. That's amazing. Let's see, find a list.
So list. Any variable name, that's a variable
in the list is, let's say this. You define
this by square brackets and different elements
they are separated by comma, that's a 134,
point nine. Name anything I mean, or five,
or maybe maybe three again. So that's the
list. Okay. ductile, on the other hand, is
defined using parentheses. So let's say 134.
point nine. That's the name. And that's a
three again, that's okay, that's a tupple.
A tupple is defined in. So when you write
parentheses, that means by default that topple
the variable name has I mean, if you have
written t that has nothing to do that it's
a tupple. That's because the Python is dynamically
typed. When you will write the parentheses
that means the tupple is being defined. Let's
define a set Let's call the variable as S,
the set is defined with with these curly brackets.
So let's say 134.
point nine, I want to tell you that all these
things they can contain each element can have
a different type. But then, even if we include
this three again, because the set cannot contain
the duplicates, later on, we will see only
one copy of three will be there in the set,
the other will, even if we want to include
it will not be included. Okay? Then let's
say a dictionary. dictionary is again defined
like a set, but but each element is a pair,
separated by a colon. Let's say the key value
is 23 as a key value, that's the key and the
value. Here is a string, let's say
two,
three, that's let's see the value. Now comma.
Now one element is there. This one element
that consists of key and value pair, another
element, another element may have a key with
string. So so the keys can be of different
types, the values can be of different types,
and so abstract. So the key is, let's say,
let's say B. and the value for this is, let's
say 43, then maybe we can have another key
value pair with key as, let's say, c. and
the value is, let's say, cc. CCD. That's a
charge coupled device. Okay, anyways, so.
So again, now you know how to define less
how to define a topper, how to define a set,
and how to define a dictionary. The difference
is, is the main difference here is in dictionary,
because one element consists of two values
rather than one. Okay, let's print that and
see the types let's print all the types sprint
died off. So let's paint them. That type of
L is. So the table L is just printed. That's
L, let's print that. Let's see the other types,
let's print the rest as well. So just copy
them and B is the type of list L is that the
type of topple is D. And that's a D, then
we have s and then we can just replace this
to the s. And then we have, let's say, D dictionary.
And that's, that's D. Okay, so that's been,
so the type of L is less the type of t is
topple the time of s is set. The dive of D
is dictionary. Oh, great. So that's how you
can define these lists. You can define list
you can find topple, you can define set, and
you can define dictionary, no problem. Next,
let's see how to access different elements
from from these data structures. What are
the way for example, to access an element
from a list, let's say the element number
element that indexed with one remember the
element that index with one is element number
two, because indexing starts from zero. So
you can access that using the square brackets.
If you want to access from topple again from
the square brackets exactly like the list.
In set, for example, you cannot index it because
the set has no ordering. First, second third
element is no longer there. But you can you
can, you can check whether a particular element
is there in the set or not using in keyword.
In dictionary, for example, if you want to
check whether a particular element or if you
want to access value, for a particular key,
you just create the dictionary variable name
and then write the key and it will return
the value. Okay, so let's practice this in
in Jupiter. Let's just practice this in Jupiter.
So let's say list value at index one. So that's
brand new, this list added next one, the value
should be printed as three brand topple at
index one, again, the way of accessing the
same Brent Brent, whether three in s or not,
the return value will be the return value
will be true or false. So print will be true
or false. And then print the and just access
the value with the key 23. So let's see what
happens. So l added index one is three tier
index one is three s, three years in S Yes.
And what is the value with the key 23? The
value is the value is two three. Let me just
describe more about this D. What is the value
at index B for example, now we have to give
the index B in the string format. That's 43.
Yeah, so that's how we can access that. Let's
sprint s also let's see s because when we
have defined as we have defined this duplicate
three But if you see the elements of s, there
are no duplicates. And it does not maintain
even any ordering, I mean, we have defined
s in a different way, it is maintaining everything
maybe in a different way, one three. Yeah,
oh, the ordering this way is the same, but
there is no index for the first or second
or third element and so on. Okay, so that's
about the defining, declaring or accessing
different elements. In the next video, we
will see more about about the data structures
actually, actually want to spend some time
on the data structures because that will be
a basic building block for for the data science
packages, too. If we if we know very well
about these data structures, these data structures,
we will be very fluent in the data science
packages and working with those. Okay, hope
to see you in the next video. Okay, in the
last video, we define less topple set and
dictionary and we actually access different
values. In this video, I'm going to actually,
I'm going to actually introduce more indexing,
how to access list and topple in particular,
because the both are very, very easily indexable
like strings. And I want to show you that
all kinds of indexing that you have seen in
strings, exactly works and list as well as
in tupple. So let's go to Jupiter, and see
what a list is, for example, a list, if you
print the list, that's the list, it has these
kinds of values, if you just see the list,
for example, starting from index one, ending
at index three, that that means the same big
a slice for example. So index one value is
three, index to value is 4.9. And the last
element is not included. So, if you get that
you get three and 4.9. So exactly the same,
the same kind of indexing that you have seen
in strings, exactly there is working here
as well. So for example, if I say list, start
from the beginning go to N but then I just
give minus one it will reverse the whole list,
I mean the whole list will be reversed. I'm
in all the same all the things that that we
saw in in string indexing stays exactly the
same in list as well as in topple, so topple
For example, let's access element from let's
say from the very beginning till the till
the third element, that's not the third element
till index three, which is actually the fourth
element. So topple unless they are exactly
they will be exactly index as as it as it
is. So all the slicing all the indexing all
the sub sub listings, all all the sub topples,
they can be accessed exactly the same way
as you as you've gone through through the
through the strings. One difference here that
I will explain later on, because list is mutable
it is changeable, I will discuss one thing
that one use when you slice it, when you get
a sub list then actually it refers to the
same memory and if you change the sub list
contents, the actual list chord changes. That
is that is true for list in slicing. And that
is true for sets and dictionaries, in the
copying the references and so on. So I will
discuss that later on. But rest of the things
are roughly the same as as they're in string
indexing. Actually, indexing is almost the
same everywhere in Python, it has this kind
of slicing is almost the same if you know
the index, how to index planes, you know how
to index lists, if you know how to index lists,
you know how to index couples and strings
and, and everything. And by the way, if you
know how to index strength lists, you will
be very fluent and NumPy. That's the very
powerful data structure. That's very powerful
kind of array processing package. with with
with some defenses that we will see but
even the indexing is same in pandas when you
are working with large amount of data data
file and stuff like so the indexing is more
or less the same that you've seen in instruments
we will we will cover indexing, masking and
fancy kind of indexing in much more detail
in NumPy. But this stays the same as, as you've
seen in in, in strengths Okay, so now can
we can we expand the list can we add more
elements? Can we insert more elements to the
list? The answer is yes. Because list is changeable.
New trouble you can insert more elements.
One way of inserting there is just to call
an add operator, you can just add plus and
you just insert in other lists like like two
strings are concatenated by plus two lists
can be concatenated, or combined together
again by plus, but there is a faster function
called append l dot append. That is sometimes
faster than using this operator we will see
that topple because it is immutable. You cannot
touch any content of the double you cannot
actually insert any element to a topple you
cannot delete any element to a tupple. There
are workarounds for example, convert a tupple
to a last change it then convert the list
to a tupple. There are ways to do that. But
tupple in its true sense, in the literal sense,
it is immutable. You cannot insert any elements
you cannot delete any element you cannot change
any element. However, you can combine two
tuples. Together, you can concatenate two
tuples together again by plus operator and
save the result into a new double that's possible
set. The you can insert elements using an
add function add function allows you to just
insert one element. If you want to insert
more than one elements, then you can call
an update function that actually accepts more
than one that accepts another set that need
to be inserted. That's possible dictionary,
you can insert a new key by just the new key
equals to that you just assign a new value
to a new key and key value pair is just inserted
there great, you can delete or remove any
element from the list using D l Command D
l l one that means the this particular element
is deleted from the list that is possible.
Deleting particular element from the tupple
is not possible However, you can delete the
whole variable whole topple that is possible,
you can remove elements from the set using
remove function as dot remove, and then you
just give the element that you want to remove
that as possible, it will be removed and you
can delete the whole delete the whole variable
that is always available. Similarly, you can
delete a particular item from the dictionary
by just deleting by just calling the D of
the value for example, whatever the key is,
so you call with the key and call the Delete
and it will delete everything I want to mention
here for to remove items from the list there
are other methods and functions that are also
available that I mean there is a remove function,
there is a pop function, these are available.
Similarly, from removing elements from the
dictionary, there are other functions that
are available. But just to compare them together,
I am using this de l command, although there
are other ways of doing the same stuff, as
well. So let's let's let's let's end this
video here. And in the next video, I will
show you all these operations that concatenating
together, inserting more elements, deleting
different elements, I will show you all these
things in in Python. So So hope to see you
in the next video. Okay, in the last video,
we saw how to insert different elements to
different data structures. And we for example,
in the case of tuples, it is not possible.
And we also saw how to how to actually delete
different elements wherever possible. So let's
go to our friend Jupyter Notebook and see
all these concepts in a running form. So let's
go. Okay, so let's say for example, we have
list, that's our list. Let's append an element
to the list or maybe more elements, that is
L plus. Let's say we can have another list
for example, how
are
that's six, and then you that's and these
two lists will be appended and the new list
will be as you can see this similarly we can
append an item using append function for example
6.8 that will also be appended and this will
contain these kind of values. So yeah, so
both arrays are fine. This plus is this plus
can be used to append to append to lists and
this append function can be used to simply
append a list with a with an element. Okay,
great topples. You cannot change the topple,
you cannot change the topple. But what you
can do is you can have two tuples for example,
T two is a different couple. Let's say a A
and B, and let's say you have four or five,
that's it that's supposed to, then you can
have a third double, that is just the combination
of double one and double two. And in this
case, you have double three, which is this.
Yeah, so double one and double two are combined
together, but you cannot actually insert into
the assembly, the tuple is immutable, you
cannot insert another element, you cannot
delete existing elements, you cannot update
any element and so on. Similarly, as the set,
let's see the state of the set, that's the
set set God add function, you can add anything,
let's if the six that is added there, and
the new state of assets this, or you can call
the update function. If you update method,
if you want to insert more elements, for example,
if you have multiple elements to be inserted
23. Again, and let's say you wanted to insert
an element that is already there. So for example,
one, then the duplicates will no longer be
there, but the new elements will be inserted.
Now let's see the state of D, the state of
D is this. If you want to add another key
value pair, you can add a key here, for example,
the key might be new key, for example, new
key and the value might be the value might
be, for example, a new value. Well, and now
if you see D, the D, the contents of the D
has changed. Well, that's simple. Yeah, great.
Can you concatenate two dictionaries together
using a plus operator? Is it possible? Is
it possible to concatenate two dictionaries
together? Let's see I have another I have
another dictionaries dictionary D two. That
is that say the key is why. and the value
is why why? And then we have another key letter
Z. and the value is. Let's sit down, can I
can get an A D and D two together? Can I?
Can I just update my D and add these values?
insert these values also there? Okay. I left
you with this question. You try to answer
this. And in the next video will answer this
question. But try to answer this question
yourself. And one way to try that is just
to go in Jupiter and just dive and check whether
plus is working or not. Or maybe there is
another method and stuff like so. Okay, great.
Hope to see you. Oh, I have not used the D
l delete and all that stuff, and so on. So
this question is there, let me use the removing
the elements. So let's say l is this list.
If I want to remove an element, let's say
element number three, if I want to remove
element at index three, which is this string
name, I can use simply this delete. And the
L is everything but without that element.
Similarly, I can remove if I want to remove
any element from S, I can call the function
remove. And whatever I want to remove, let's
say want to remove game, and the game will
no longer be there.
Great. If I want to remove some element from
dictionary, again, let's say that's the that's
the view of dictionary. I can call the Add
I can I can remove the element with key let's
say C, whatever the element is with key C,
delete that element, and the dictionary has
this particular state with this item, this
particular item is gone. Okay, great. I can
do that. But But d L is not the only way of
doing that. There are so many methods. I mean,
a lot of methods to do that. But just to just
to compare all these, I'm just giving you
the most similarities and differences wherever
available. Okay, great. So I have asked you
a question in this particular video. Can we
concatenate two dictionaries together, particularly
with a plus operator? If yes, then we are
done. If not, then Are there other ways and
stuff like so that's the question. So hope
to see you in the next video with more on
these data structures.
Okay, I asked you a question last time. Can
we concatenate this two dictionaries together
with a plus operator? So what's your answer?
Yes or no? The answer is Nope, yeah, so we
cannot concatenate them together, we cannot
insert another dictionary to this dictionary
using a plus operator. Because this plus operator
is not defined for dictionary, what we can
do is we can call an update function, because
dictionary is also a set, I mean, a set of
key value pairs. But at the end of the day,
it's a set with specialized function, of course,
but we can call update functions, and insert
the whole new dictionary inside dictionary
as as as follows. Yeah, so the answer is using
plus operator No, but there is a way using
update method. Right. So next, we focus on
the copy function, the copy function is available
for less the copy function is available for
set, the copy function is available for dictionary.
So let's see the need of this copy function
here, I want you to be very careful. Because
that's, that's really important. Let's say
we have a list, let's say, That's list. And
by the way, the same goes with set and dictionary
as well, whatever I'm going to do with list,
let's see a list. Now, what you do is you
copy the list or you just make another variable,
like you can assign the value of l to another
variable l two, what you do is that now l
two is also has this, now these are two different
variables, L is this variable, l two is this
variable. So you might be thinking l two is
separately a completely a new thing. And Alice
new thing, you might be thinking that both
are independent. But Python internally manages
the data structures, most of the data structures
in a way that because the data structure is
a collection of a lot of data it has it is
consuming a lot of memory, what it does is
when you assign a variable, or data structure
to to another variable, it does not actually
copy all the contents, it does not actually
make a new memory, and store the contents
in this. It actually this variable also actually
points to the same memory as this. and and,
and and the consequence of that if you change
any value, for example, in L two, let's say
you change the index to value from this, the
index to values 4.9. Now you're working in
L two, let's say you change this L to value
from 4.9. To Let's 4.9. Let's see you do that.
So you might be thinking that this happens
in L two, well, in L two, that has happened.
But what it also does is it does the same
thing in L as well. So l also changes. The
reason is L and L two, they both are pointing
to this structure in the memory. And whether
you approach that structure through L, or
you approach that structure two l two, you're
approaching the same memory anyway. And that
is called referencing I mean, it does not
create the data, it actually create a reference
in the memory to actually create a new name
for the same memory. And both are pointing
to or accessing to the same memory. And if
you really want the behavior so that l two
becomes different than L and what I what I
do with L two, that should not affect L, then
you should call copy function. l two is L
dot copy. Yeah. So that's the function, I'll
copy. Now you have l two. Now you do whatever
with L two, it will not affect L. So l two,
for example, index at index two, you again
say okay, this is 4.9. So l two changes. Now,
l two changes, but l doesn't change, l doesn't
change, l stays the same. Now this is different
copy, same concept, go with the set. And same
concept go with with the dictionary. If you
if you just make another way will s two n
equals two s, then if you change the contents
of s two s will change. If you don't want
that, then copy it similarly copy the dictionary,
because the contents of the topple they are
not changeable. The copy function is not available
for double. Because even if you assign this
T to T two, you can now not change D two because
it is immutable. So having a copy function
doesn't make sense in tupple. Wait.
One more thing regarding slicing. Let's say
you have let's say you have Dell that's available
to you like so that's L and let's say you
make l three another list by slicing Let's
say a list from let's say one to five, let's
say. So you start from index one, which is
three, and you go to five by not including
five, this way, the L three is automatically
a copy, it is not a sub list, which is referencing.
So l three. So l three is a different l two
is a completely new list, a new memory view,
if you change the contents in L, three, if
you change the contents in L three, for example,
l three, or index zero, it should go from
three to let's say, three, if you change the
contents in L three, these contents, these
change will not reflect an L. So if you do
the slicing, slicing picks a copy by default,
it does not pick a reference. And that's a
huge difference between this list and a NumPy
array, when you end it, we'll see that when
we will see a NumPy array, the slicing actually
also, again refers to the same memory location.
And that might be one difference in indexing,
indexing in the whole Python, whenever you
do slicing, you get a copy. But in NumPy,
when we'll see NumPy in detail, in NumPy,
when you do slicing, you get again a view
not a copy, and if you change in the slice
torian anything the actual the actual contents
also changed. And there is a reason to do
that there is a there are efficient reasons
to do that and stuff like so, again, the dot
copy function becomes the copy function become
much more applicable there as well. So, so,
so you need to know that even if you do if
you do slicing in general in Python in any
collection in any array, in any, if you do
select a collection for even for mutable objects
like list, you get a copy, but in NumPy array,
the things the things these things, this particular
thing with with a lot of other things this
but this indexing scheme actually changing,
changes with with this kind of slicing. Okay,
so I am this video here, I mean, you can explore
much more functions of lists tupple, seven
dictionary and what you can do with each of
them, and what you I mean, in which scenario,
what kind of thing is more suitable for the
other that completely depends upon the problem
at hand. But what we can do in what what we
will do what we'll be doing in the less next
video, we will be seeing some using some functions
of just list. And then I will be just just
letting you to explore the the tupple set
and dictionary and all their functions on
your own. And to see what function or what
method is doing what for what, which kind
of data structure. So in the next video, we
will be seeing some methods just for list
data structure. Hope to see you in the next
video. Like in screens. Let's Let's explore
a lot of functions in list. Although in, in
in sets and dictionaries and tuples tuples,
as well. But many more functions are available
in list. And by the way, let's see how many
things are there in this list. And let's say
l dot tab, and tab will open up a lot of things
with me for me abanda we know already clear
copy, copy, we know already count, we don't
know count, extend, index insert, pop remove
reverse some of these functions. They make
sense by the adjuster name. But let's see
one by one. Let's see some of those. What
they do. One way to do that is go to internet
and see some book or tutorial or something
like So another way is just write this apply.
Maybe, maybe help function maybe apply a help
function, it may help you how to use that.
Great this help function is great. So abandoned
object method of building list in stance about
an object to end of the list. Oh, it appends
an object to the end of the list. Which means
we may be able to append another list to to
a list maybe. Have you thought about that.
The append method just takes 111 object. Maybe
it takes a whole lot of list. But then it
may be possible that a list is appended inside
another list and that whole list becomes becomes
one element because list can contain other
lists as elements are that's a problem. Yeah.
So let's see more functions. Yeah, so let's
see clear what this clear What is this clear
what it does? Sometimes I use help, sometimes
it's used that remove all items from the list,
oh my god, if you call the clear that the
list is empty, okay? If you just call clear
function on a list will become empty. Be careful.
Okay, great. What else? So that see I have
this function maybe, Bob, what does Bob does
watch. So let's see. So Bob removes and returns
item at index defaulted the last, which means
if you also that's the default value remember
the default value. So, if you call a part
function without an index, it will return
it will remove the index it will delete the
last item and it will give you that it will
return that are if you give an index, it will
remove that value at that index. And it will
after removing it will return you that. So
you can use it wherever you want. So there
are many more functions for example, you can
see all of them one by one remove function,
for example, reverse reverse, like, like,
like the name suggests, if you call the reverse
function, the list will be reversed. Yeah,
and remember, we have reversed the list in
the following way as well, we have a way of
reversing any way, this way. So now if you
see the list is again reversed. So I guess
both of them are working like so same. Similarly,
you can explore several functions from a set,
you go and say add Clear. Clear might be working
as same as intersection intersection and update
is destroyed is a subset of the other. Yeah,
add by default or update by default, actually
take a union. So I'm not seeing update function.
Here it is update. Oh, union is there update
is there, which means the list you're seeing
is here is not a complete list you may be
writing, what are the functions that start
from you. So here are the and and several
others. Similarly, you can go to dictionary
and call for several functions clear copy
from keys get items. That item might be might
be interesting. What is this item? what it
does? Oh, it has an error? What? So how can
you use this? How can you use this function?
Let's see, oh, this is just an object, it
is not a function? I don't know.
Let's see again, are it is not listed anywhere?
Oh, it is items not item. Okay, items. That's
a function maybe. So these are all the items
23 with this, be with that new key with that,
and so on. Great. So actually, the purpose
here is not to tell you each and every function,
what it does, it will take a whole lot of
time. You can go and explore all these functions.
The purpose here is to tell you what kind
of data structure has, what kind of properties
and what are the similarities and differences
in between. So if you remember this one slide,
for list, double seven dictionary and some
text that is written out above, you'll be
having very good knowledge of where to pick
what kind of data structure in practice. So
in the next video, I'll be actually going
to Jupyter Notebook as our as our style and
I will be coding or solving some problem for
you that will involve list topple set or dictionary
are one of them or we will be choosing based
on problem what kind of data structure is
well and what so we'll be doing that. But
before that, I just want to I just want to
I just want to mention that list tupple set
or dictionary they can contain any items inside
any kind of type, which means a list can contain
another list. A list can contain a set a list
can contain a dictionary, a list of dictionary
can contain a list which itself contains a
dictionary, I mean, this is all abstract,
this is all abstract, one thing can contain
the other one thing can contain an instance
of I mean, a list can contain multiple lists.
And those lists can contain more or less and
so on. So before actually going to problem
solving, let me give you a flavor of that
how abstract these things are. Let me give
you a flavor of that in in just just in a
couple of examples. So in the next video I'll
be giving you a couple of examples based on
the abstract mess of these data structures.
And from the next next video, we'll be probably,
we will be doing some problem solving based
on that. So next two videos are completely
on Jupyter notebooks. So get ready, I hope
to see you in the next video. Okay, let's
see the abstractness of all these data structures.
Let's see just one example. Let's say we have
l as the list, we have all rich top all that
stuff. So let's say we have set that set,
let's say n, we have dictionary, that's a
dictionary. Okay? So let's say we have all
these things that say available somewhere.
So let's make another dictionary. For example,
let's say D, D, Ma, that's a D tool. And that
dictionary has key value pairs less The key
is a and the value is whole list l master
value is possible. Let's say the key is B.
and the value is just to topple the whole
topple, that's the value. Let's say the key
is C, and the value is the set. And let's
say the key is D, and the value is the dictionary,
the whole dictionary D it is possible. I mean,
you can just do that, that that is just one
example, oh, what's Oh sorry, I should have
I should have incorporated this way. Okay,
so this is possible. Now, for example, if
I access, if I access the element with, let's
say, a, I will, I will get the whole list.
And not only that, I can again access the
whole element. And then after that, for that
element, I can access for example, the third
element, the element at index three. So this
particular, this particular first level will
extract the list. And that will in that is
just the indexing or for that list. See, for
example, if
I access D two, and inside the tool, if I
access the dictionary that is inside, and
let's say I save that dictionary in k, then
it I can see the contents of K but I can just
for example, this or I can just access all
elements of this dictionary, or k by just
having 4x in gay brand, for example, x and
k of x, just do that i can i can just do that
we have done that in loops as well. So I want
to tell you that the these even if for example,
if you want to create a list l let's say l
three let's say you want to create a list
that can contain a whole list that can contain
what will get Oh, I mean one element is the
list another element is to pull another element
is the whole dictionary inside and then you
have some other elements let's Lee's game
and that's perfectly fine i get i mean you
can do that, these data structures are much
more abstract I mean now if you for example,
access element at index two which is dictionary,
that is completely a dictionary if you if
you check the type of that element that that
will be a dictionary object and you can extract
that element and play the way you want to
play and whatever. One more thing if you can,
for example lists we can let's say we want
to make a list list very quickly for example
list off all the squares till till starting
from zero list of all the squares till till
10 for example zero square one square to square
let's say we want a list of that. So one way
of doing that is a quick shortcut is to just
use the loops so in loops, for example, we
right okay, x square for x in range. Then
for example, so it will start from zero go
till nine, including nine and you will get
x one by one. And all this index is for making
a list of x squares where x starts from zero
and go to go to including nine go to nine
one by one and that's how you can make a list
and I'm in these kind of these are kind of
shortcuts. Again, you can make a sale For
example, let's say you want to make a set
of all the squares for x in range, let's say,
starting from starting from two, ending at
20. And you want to take a step of, let's
say three. So, start from index two go till
20 do not include 20, but take the step of
three, and you can now have a set, which is
which is this. I mean, there are, there are
a lot of ways of working these working with
these. One, one can explore more and more
about these things, but what what what the
basic thing about these data structures are,
they are very, very abstract, they can I mean,
a list can contain a dictionary, and that
dictionary can contain a topple and that will
have an element which is another list and
so on. It is that abstract, it allows you
to do each and everything in that way. Okay,
so I end this video here in the next video,
we will actually solve a problem using these
one of these data structures or we will try
to choose one of those. And that video naby
lengthy may be small, because we may have
bugs inside. And we will we will play around
with these data structures in the next video.
So do attend the next video because it's really
the practice and you will get your hands you
will get a very good grip on the data structures
in the solving the next problem that we are
that we are launching for you, okay, hope
to see you in the next video. Okay, let's
see a problem just to get comfortable with
these data structures. So let's let's design
some problem and solve that problem here using
using these data structures. So the problem
that I'm thinking is, let's say the following.
Let's say let's say you are you a teacher,
should I type all these things? Okay? Let's
say you're a teacher, you are a teacher. And
you have
different student records to learn records
containing containing ID of a student and
the mark marks list in each subject, where
different students have taken different number
of subjects. And all these records all these
records are in hardcopy. You want odd copy,
you want to enter all the data in computer
and want to compute the average marks of each
student. And display. That's the problem.
So the problem let's say is, you have for
example, you have a hardcopy you have you
have some papers, upon which you have different
students, each student have a different ID.
Some students may have taken seven subjects,
some student may have taken three subjects,
some student may have taken eight subjects
and so on different students may have taken
different subjects. Regardless there, you
want to first enter each for each student,
you want to first enter the records, I mean
all the data that is in and then you want
to compute from that data, you want to compute
the average marks of each student. For example,
if a student have taken five subjects, then
the marks for all the five subjects are available,
you just add all the marks and divide by five
and that's, let's say, the average marks.
So first of all, let's ride away two way to
compute for example, the to just collect the
data, how to collect the data. So let's write
a function for that. So let's say define a
function, let's say get data From user or
teacher, let's say, let's say that function,
and it returns data. Okay? So what I do really
is I say, okay, while
true,
I made a loop while true, just take the data
from the from the user, and the data is in
the form of you first say, okay, ID, student
ID, let's say that is inter, or actually input,
enter student ID. So he enters the the person
enters the student ID. Yeah. So adopt, you
might have define a dictionary, maybe a dictionary
D, that is empty right now. But you may, you
may add and remove different values. So what
you do is, you add a student ID, you get a
student ID, and in the string form, and then
you get the you get, for example, the input
as the marks list. So marks list as input.
Enter the marks,
by
comma
separated values. So enter the marks using
for example, if you have five subjects, just
write the five subject marks by separating
each with the comma, okay, then this, let's
see
more
students is equal to let's say input,
enter,
yes, or no.
for
adding more students, so if for example, you
have more data to insert, then press Yes,
otherwise personnel. So that's, for example,
our setup. So we will keep on getting more
and more, we will keep on getting more and
more data from the user user will keep on
increasing the data. But one thing that we
must know is that if for example, a student
ID, student ID is already in D, if that is
already in D, then we should give a message
brand. brand that student ID is already inserted.
So that might be a message else. ls we want
to do something else, what we want to do is
the following. What we want to do else is
we will make a dictionary, we already have
a dictionary with a student ID as our key,
that's our key. And at that key, what we do
is be the pick the marks list, and just split
it using comma because you're expecting and
all the marks they will be saved as a list.
So that will return a list. List of string
values. These are not indeed values, these
are string values. But all these lists they
are tagged by this ID. So that is a dictionary
that will be that we'll be getting populated
on and on and on. Further if we check F for
example, more students dot lower, for example,
let's call the lower function because the
user may interest at a lower form or if that
is equal to let's say no, that is equal to
No, if this is the case, or if there is no
enter for example.
No
inter no inter Know, to quit when insertion,
insertion into node with insertion. So let's
say that's your message. So wherever the user
inserted, if that's a no, then you return
the and that's it. Otherwise, you keep on
moving. So that's the whole goal. So you keep
on asking the, the, you keep on asking more
and more values. If whenever the teacher enters
a no, then you just return. Otherwise, you
keep an up, you make another equation, you
make another equation and keep on moving.
That's how you get the data. So the data will
be available to you. Once you are done with
that, then after that, we will see how to
once we have this data collected from the
user, then we will see how to compute marks
for each student individually average marks
and so on. So let's just check whether this
function works or not. So let's say we have
our dictionary that says student student data
is equal to get data from user, let's just
call that function. Let's see what happens.
Okay. Enter student ID, let's say ID is 12.
Okay, in remarks by comma separated values,
let's say, well, one, let's say
24,
comma 65, comma 87, let's say the first two
in just the first tool and just have these
three subjects, then internode width, so I
will enter something else. And oh, what's
the problem? There is a problem. If more students
taught lower is more student is not defined.
More student that's, I guess, more students,
more student here, oh, the spelling mistakes.
That's a huge mistake. So I just copy there,
these bugs are there. That's part of life.
Part of programming life, actually. So I guess
now it will work. So let's do the process
again. So 12, let's say, and the marks are
the six comma 45, comma, let's say a bad subject
with let's say, 13. into no to quit. No, I
will intro something else, I will keep on
moving. The other student is the student ID
is 45, let's say. And the marks that this
student has gained, actually, let's say this
student has, has registered has already registered
seven subject or let's say five subjects.
And the marks are, let's say 44 to five, six
to 677. And let's see a bad subject, let's
say four. Okay, then internodal, quit. No,
I want to insert one more, so do anything
else other than No. So student ID, let's say
now the student ID is 12. Again, let's say,
let's say want to insert another ID again.
And whatever the marks, let's say 45, and
45. Again, that's a now internode width, no
something else. But now, the message is there,
the 12 is already inserted, because the ID
the key value index, now you cannot repeat,
and so is the student value. So it does not
inserted the because this may be my mistake,
so it asks again. So now let's say I enter
ID, let's say 23. That's the ID or maybe a
different ID. That's the ID and the marks
are let's say 45, comma, 45. That's it. And
internodal grid. So let's say I enter No.
And that's it. So now I have received the
student data, if I show you the student data,
that student data is student data. That's
a dictionary, that's a dictionary with the
with key 12. And that's a list. But this list
contains all the values that are our string
type, we will see how to handle that. That's
a 45 as a key value, that's ID and that's
the marks list. And that's the ID in that
small list. Okay, great. Now we have student
data. Let's write another function that helps
us working on the student data, basically,
we want to find out the average marks of each
student. And then we want to print those.
So let's define another function and get average
marks of each student. And that function actually
receives this dictionary, let me call it as
D, any any variable, that's a local variable.
Okay, so what we want to do with that is the
following. Average marks for each student's,
so we will define another dictionary, let's
see everage marks dictionary, let's say that
is empty in the beginning, maybe, and then
what we do for x in D, let's icreate over
x and d, what we really do is we go to the
we find out the list of located at ELLs are
located at x L is basically D sub x. So that's
it, that's our list. That's our list that
is located there. So then what we do for i
in L. So for all i that is an L or let me
call it for marks, marks in L. In this particular
list, what you do is you actually have this
sum of sum is equal to zero right now,
there is no marks. So what you do is s plus
equals two marks, but convert the marks to
integer because they are already in string
format. We have we have saved everything instinct
string format, so you populate all the list.
Once you are done with this loop, the S will
contain the sum of all the marks, then what
you do is you compute the average and just
save that average in ABG. Marks decked dictionary,
let's say on average marks, just just don't
use the word deck, for example, you can but
let's stay gradual and add x, you just write
the average marks. And the average marks can
can be computed by s divided by length of
the list, whatever the list is. So that's
what the list is. Yeah, so that's the average
marks. And once you have an N one by one,
all the average marks will be populated. And
once we receive all these, we will then begin
then we can then just display by populating
the average marks. So let's see, let's call
that function. So let's call that function.
So ABG marks for example, equals to get a
VG marks, and let's bond these student data
inside. And if there is no error, then it
will return everything. Then just print the
average marks for each student for x in a
Vgm. brand, let's say student and Brand X
God average marks as then you just Brandt
okay ABG m of x, x, and that will display
everything Oh, if there is an error, non type
object is not equipped. I prefer nine type
object why non time object? We have done some
mistake. Yes. Maybe. Let's see. Let's see,
for example, when we run this, so let's run
this and create a cell Let's run using alt
Enter to create a cell everage m What is that
thing? Oh, that's nothing. Why oh, we haven't
returned anything. That's a bad programming.
Really bad programming. We have not returned
actually. The the value that we need. So the
default value is none. raid actually not so
great. Okay, great. You have this and now
we have something in Emirates marks. Yes,
this is and now we can just populate that
and we have this student 12 got average marks
38 student 45 core average marks 90 49.2 and
student 20 He got average marks as 45.0 Okay,
great. So that was just a review of split
function of string, type and marine through
int, and functions in general input function,
and, and dictionary and list and all that
stuff. So although it was a just a tiny problem,
but it gives a good flavor of the data structures
and strings and all that stuff. Okay, that's
about the data structures. From the next video,
we are actually diving into the data science
packages. And we will start from NumPy and
we will spend some time on NumPy and then
we will be moving towards pandas, which is
very, very powerful built on top of NumPy
and after that, we'll be moving towards matplotlib
and we will also try to give you some snapshots
of psychic learn as well. So hope to see you
in the next video. Okay, the next few videos
will I will discuss NumPy which is the which
is the very very popular package for numerical
Python. Actually NumPy is like list but it
is much much faster than list.
One one restriction if we restrict the list
of Remember, a list actually is a collection
of a lot of data objects. That was so abstract,
as we saw in previous videos, if for example,
we restrict a list that all the objects they
must have same type all elements in the list
for example, they have same type then that
list with all the same type, there is what
the NumPy looks like, but NumPy is very, very
more faster. And the reason is, even if you
define a list with all the elements that are
let's say of same type Yeah, but because list
in abstract way can handle heterogeneous kind
of objects, the functions that we will apply
on these items, they will no longer be faster
further to store each element we have to store
that information or metadata for that element
in NumPy, it is both I mean, it is efficient
with respect to memory, because if the type
is saying we need not to save information
about each element, because we need just to
save the information about the type because
the type is same for all elements further
when the type is same, we can write functions
that are much more faster than then then a
list. So NumPy is very, very popular, it has
very very fast universal functions available
the methods that are available in NumPy. And
it's a package i mean it's it's a whole directory
structure containing a lot of packages inside
a lot of modules and so much at the end of
the day, it's it's it's simply or in laymen
terms, it is like a list with all the same
type objects and it is much more useful when
all these objects are numeric type, although
you can have a NumPy array with with spring
data types, I mean all the strings are all
general objects as well, but the the most
the power mill the power of NumPy array will
be will become much more evident when we will
be working on numeric type data. So in this
particular in this particular course we will
focus more on numeric data then other kind
of data. So that's how you you write import
NumPy is installed or if you if you have installed
Python using Anaconda NumPy is already installed
there it is in the side packages kind of a
built in package. So import NumPy we can stay
as it is but we can rename this NumPy just
NP that's most popular name, we can write
any other name but if you see the books or
internet or somewhere this NP somehow becomes
much more popular. Okay. Now we can define
an array for example NP dot array that array
is just a method of NP kind of function. And
we can define an array using list this is
the list of several numbers or we can define
array as as a topple as well. So whether we
give a topple whether we give a list an array
is defined and then we can see the contents
of this array, this NP array so let let's
just go to our friend Jupyter Notebook and
get our hand Well dripped on, on this NumPy.
So first of all, we need to import NumPy package.
And we may rename as for future use as NP.
So let's say that is imported. So now let's
say a is an array, let's say NP dot array,
that's a function and we may have a list and
say, let's say 12357. Let's say that that's
right, we can also define the array using
a topple rather than a list, it's our choice.
Which way we define the array either way.
235 Let's, that's, that's another array for
example. So if we print for example, a it
will give us a but if we just see the type
of a it will no longer be list it will be
an ND array numpy.md array that n dimensional
array, okay, great. So, there are so many
attributes of this a and this B. Same. Similarly,
if you see the type of B although we have
defined this be using the tupple. But the
type is the same the it's a NumPy object rather
than a list or a topple.
So that's how you can create the the array
1111 more thing that is that is important
is to check the attributes of a for example,
k dot d type, that will tell us the data type
in a so for example, a stores all the data
that is integer 32. At defined time, for example,
we can we can specify the data type if we
want we can specify the type if we want. For
example, in teacher that means as in teacher
here, we can here we can define, for example,
the type as float, for example, so data type
becomes float. There are several other other
options that are available to define the data
type but, but even if we don't define the
data type can be defined automatically based
on contents. That's what the dynamic typing
means. So if we now define type that is, if
we, if we now check the type of a that is,
again in digit 32, but if you check the type
of be the type that that might be a float
number, yes, that's float 32. Again, there
are 64 bit support as well, I mean, we can
define here there are several options here
available. So that's the that's how we can
define the NumPy array that's just getting
started with NumPy array. In the next video,
we will play with these arrays a bit more.
So hope to see you in the next video. Okay,
in the last video, I introduced NumPy. And
we actually declared a NumPy array using a
list as well as a topple. In this particular
video, we will be seeing some of the properties
of the NumPy array variable or sometimes called
the object that variable there are several
properties, but I will discuss for example,
last time I discussed one property which is
d type a dot d type, and that store actually
the that actually stores the information of
the data type of the elements of the array
of NP array, remember NP array, all elements
of NP array they must have same data type
it cannot store heterogeneous arrays as it
is. Okay. Now, there is another property sometimes
called the dimensions are n them. That tells
actually, what are the dimensions of of the
array, I need to explain this term dimensions
with the following example. Let's say for
example, that's, that's that's an array just
consider that a list for example, 123, that's
one list. And if it is if it is an array,
for example, if np.if this is NP dot array.
With that list, we will say that array as
a one dimensional array, because we only need
one index to access that. For example, if
you need to access any element in this array,
you only need one index either 01 or two,
only one index, that's okay. So in this case,
we have just one dimensional array. On the
other hand, for example, if you see here,
that's one array or one list, that's another
array, another list. And that's another list
that contains lists inside for example. Let's
say that array one, and that's array two.
And that is simply an array of two different
arrays. That's, that's an array and that's
an array. For example, a One is this array
and a two is this array. Now if we need to
access any element in this particular array,
we need two indices. First of all, we have
to locate whether we are going to talk about
a one or a two, we need one index for that,
for example, if we want to locate a one, that
means we are going to access with elements
zero, let's say this, this whole array is
a So first of all, we say okay, zero means
we are going to access from from a one and
a to one of those. So zero means the first
one, okay, now a one. Now inside a one which
element, this is the zeroeth element, this
is the first element, this is a second element,
let's say we want to access the first element.
So that means we are going to talk about we
are talking about this. So very loosely speaking,
the total number of indices that are required
to access an element inside the array is called
dimension of the array. And m them that actually,
that actually defines that that actually describes
the this property, the total number of dimensions.
Consider, for example, this is a 2d array
or two dimensional array, let's head out to
two dimensional array A one, and let that's
another two dimensional array a two, that's
another two dimensional array, a three, for
example, and let's say this is an array of
two dimensional arrays, let's say NP dot array.
Now, that's that whole array, whatever that
array is a three dimensional array. And the
reason is to access any element, we need three
indices. First index will define which one
of these we are selecting, for example, let's
say you're selecting that. So one index is
needed that index is one for example, then
inside this structure like so, we need two
more indices to locate a particular particular
index. For example, because it is a two dimensional
array, it has two one dimensional array, so
which one dimensional array you are, it has
more, it has many one dimensional arrays,
so which one dimensional array you want to
pick, let's say the sixth one will index with
index five, now you have located the fifth
or sixth array. Now in that array, what element
let's say the eighth element. So we need three
indices to access a particular element. So
the dimensions of this array is three. So
let's play with that in Jupyter, notebook
just to get more comfortable with with the
term dimensions. So let's say for example,
we have an array, let's say a is NP dot array.
And let's say it contains a list, let's say
123. And then we have another array, one dimensional
array, let's say four, five, and six, that's
another array. And that is an array of these
two arrays. So that is basically a two dimensional
array. It is array of arrays. list of lists,
equal entries. So that's a for example, oh,
what's the problem? Oh, we haven't imported
NumPy, we should have. So import, import NumPy
as NP? Okay, we need not to import that every
time. Actually, I'm recording this video after
a few after a few hours. And I'm really I
have restarted all these things. So I have
to import now for the first time. But once
imported in the notebook, as long as a notebook
is running, you need not re import anything.
Okay, so a DOD for example, and then Iraq
and them. So that is to hear because there
are two dimensions. For example, if I want
to access element number three, this element,
so this element is located in the first array
of the two arrays, which has so the first
array, there are two arrays with index zero
or one. So I am going to look into the first
array, which is 123. And in that array, I'm
going to look for the element number two element
with index two. So that's how you can access
the elements of multi dimensional arrays are
arrays with more, more kind of dimensions.
Let's say we have another array just to just
to get more familiar with NP array, let's
say, and we have a list. And that list actually
contains that list actually contains three
one dimensional arrays. Not only that, actually
Oh, I'm confusing you a lot. Let me know Let
me just, let's say we have 123. Let's say
we have three one dimensional arrays. Let's
say we have another 2459. The the sizes of
arrays, maybe, maybe, maybe, I mean, maybe
different. Yeah. Is that true? maybe different?
Yes or no? Let's see, for example, the first
array has size three, and the second array
has total size. Does that okay? I guess, yes.
And now if we want to access, for example,
an element of an element with a, let's say,
I want to access this element five, so that
is in the secondary index with one, and then
in that array, it has index two. So I've accessed
this element, oh, we're not too many indices
for an array. Why?
Why is that? Why too many indices, for for
an array, B selects a B dot n dems. And then
that is one y one dimensional, I have to,
I have this one dimensional array. And this
is another one dimensional array. And I have
made a list out of it. I'm in this is 1d array
and another 1d array of concatenate them together,
so I shouldn't have accessed this element.
The problem is when you are going to define
multi dimensional arrays, the the number of
elements for each dimension, they should stay
consistent. For example, if the first array
has three elements, the second array must
have three elements, or if the secondary has
four elements, and the first must have four
elements. If that is not the case, the array
will not be defined like a multi dimensional
array. For example, if we, for example, extend
our first array with let's say, minus one.
Now, B will be having two dimensions, no problem.
And now we will be able to access for example,
this element five, like so. So we will go
to B again, we will see okay, select array
number two, and in that array, select index,
select the value indexed by two, which is
five. So accessed no problem. And that stays
true if you if you're going to define for
example, a three dimensional array, let me
just give you an example of three dimensional
array that's a C equals NP dot array. And
let's say we have one, two and three. And
then we have another array, for example. 456,
remember or so let's say that, that we can
have one more for example, we can have one
more list, why not? So let's say we have a
00 minus one, let's say, and that is what
that is. That is a two dimensional array.
That's a two dimensional array. Great. Let's
say we have another two dimensional array.
Let's say we have another two dimensional
array with same kind of consistency, the number
of elements and stuff. Let's say these elements
are our minus of the, the other ones, let's
say there's minus, minus, minus and this is
plus one. And now we have this, if you see
this thing, that's a 2d array. That's a two
dimensional array, that is also a two dimensional
array. An array of two dimensional arrays
is basically a three dimensional array. Now,
that's a three dimensional array. This one,
C, so if you Oh, we have some, Oh, I should
have defined this with commas. Rather than
rather than spaces. Actually. Yeah. The reason
I did that is MATLAB. I worked in MATLAB also.
So MATLAB allows this space separated list,
but I just confuse the things with with Python
as well. But Python requires comma, they're
okay. With MATLAB. By the way, just as a side
note, MATLAB allows you to have commas as
well as spaces, but this Python is just restricts
everything to comma. That's great. Okay, that
is C. So now, if you check c dot n them that
is three, if you for example, want to access
this particular element, what should you do?
First of all, you select the, the one of the
2d arrays, there are two 2d arrays. So this
is the first 2d array and that's the second
2d array. And if you For example, want to
access this particular element, this particular
element, which is minus three, if you want
to access that, you first have to access one
of the two 2d, two dimensional arrays.
So let's access the second one with the index
one. Now you are in this particular 2d array
in that array with list which 1d array you're
talking about. So I'm talking about the very
first 1d array, so the very first 1d array
is indexed by zero, and in that one D array,
which element you are talking about. So I'm
talking about this element that has index
two in this particular array. So now, if you
press enter, you will get minus three Wow.
So that is basically how and by the way, you
can make a four dimensional array, a four
dimensional array will be an array of three
dimensional arrays, and so on, you can make,
you can make, for example, n dimensional arrays,
and that's one reason why we call this as
nd array, n dimensional array, not the type
of C's nd array n dimensional array, you can
add as many dimensions as you want. Great,
we will continue exploring this NumPy more
and more in in the upcoming videos in particular,
I will talk about this shape property of this
NumPy we have already discussed D type we
have discussed and then in the next video,
we will talk about shape and we will discuss
more about about NumPy. So hope to see you
in the next video. Okay, in the last video,
we discussed this number of dimensions or
ending property of any any NumPy array. And
we also saw an example of defining a three
dimensional array in Jupyter. notebook. Let
let's discuss another property which is which
is the shape property. Let's see what what
this shape actually represents. So let's go
to Jupyter Notebook and see what actually
this shape represents. For example, you have
seen this C as in the last video, we define
the C as a three dimensional array that contains
two arrays of 2d. And each 2d array contains
three 1d arrays, and each 1d array contains
three elements. So what do we mean by shape?
So if we just say shape? What is that thing?
So shape is 233. And let me tell you what
that means. The return is tuple. So that's
a tuple. That is returned to three and three.
This two means how many two dimensional arrays
are there? Here we have two. So in each two
dimensional array, how many 1d arrays are
there? Well, three in each one, the array?
How many elements are there? Well, three.
So basically, this C dot shape, zero, tells
you the total number of two dimensional arrays,
that is too. And this shape. For example.
One tells you in each 2d array, how many 1d
arrays are there, these many? And this shape,
for example, to tells you in each one the
array, how many elements are there? Well,
three grade? That's awesome. Yeah. Can I tell
you 111 screens kind of thing? You can you
can define a NumPy array, for example, a as
NP dot array with just one element, let's
say two. That's an array raid. What's the
number of dimensions here? What do you think?
What is that? Is that a 1d array? What are
the number of dimensions? Strange? It's a
1d array. Yeah, it is. see another thing?
For example, b is equal to NP dot array. And
you define it with let's say three. And what
are the dimensions of B, it looks like the
same, the dimension of B should be one as
as their the dimension of A is one, it looks
like the dimension of B is also one. No, it's
zero. Because that's an array. If you pass
it as as a list. It's an array of one D if
you just define just one number that can be
defined as an array NumPy allows you that
but that one number is just as a yo D array.
Now if you can get in it, a lot of zero days,
you get one day if you concatenate the last
one days, you get a duty. If you're getting
a lot of duties, you get a 3d and so on. Get
a look and feel Yeah. So that's what it is.
So yes, In this video, I discuss the shape
there is another There is there are so many
properties, let me let me discuss some properties,
let's size that actually tells the total number
of elements complete total number of elements
in the array. So, how many elements are there
that is size. There is also I guess m bikes
property, that tells the how many total number
of bytes that the destructor is taking inside
the memory. And there are several other I
mean properties, if you just apply a tab and
get certain things, you will see a lot of
functions. And you can you can check a lot
of properties that some of these functions
we will explore later on. Sometimes they are
called the universal functions, we will see
them because they are very, very fast. And
these functions the vectorized implementation
of these functions. That is the reason why
NumPy is so so fast, and why it is so popular.
Anyways, so in the next video, we will go
to explore the NumPy a bit more. And we'll
show you more fun stuff with the NumPy. So
hope to see you in the next video. NumPy actually
provides a lot of functions to create arrays,
special kinds of arrays just for testing.
And sometimes just for. I mean, there are
a lot of ways to create arrays from scratch,
for example, what if you want to create an
array containing all zeros, so there is a
function in NumPy NP dot zeros that tells
you how to do that. Similarly, if you want
to generate a lot of generate an array containing
a lot of ones or all ones, there is a function
to do that and stuff like so, there are some
functions that are actually used a lot and
I want to discuss those. One function is NP
dot arrange, actually, this is a single R,
this is not a two Rs, this is single r NP
dot arrangement, one R and NP dot arranged
function, what it does is it creates an array
for example, if you say NP dot arrange, it
creates an array for example, if you say okay,
100. So it creates an array that it creates
a 1d array that starts from the the values
in that array starts from 012, all up to 99.
So that's an array. That's a quick way to
create an array with all the numbers till
100. Yeah, so let's see, let's see running
example of this NP arrange method in Jupyter
Notebook just to get a better look and feel
of how it works. So let's see. So let's say
we have a equals NP dot arrange. And let's
see 100. So that's it. If you want to see
what is inside a, you can see this is an array
with all the values starting from zero up
to 99. Maybe you want to create an array that
starts from a particular number ends at a
particular number. Maybe those two numbers
are different. And maybe this arrange function
actually allows that. Let's say I want to
start with 20. And I want to end at 100. And
I want to create all the array that does that.
So let's say this. So that's okay, start from
20 and 100. But the last element last index
is not included. That's possible. Last but
not the least, if you want for example, to
start from 20 and add 100. And let's say you
want to take a jump of three. That's possible.
Remember, does this does this resemble with
something that you know already? Remember
that? Yeah, let me pause for a minute, but
not for a minute, just for some seconds. Let
me pause. Do you remember this arrange NP
dot brains function? It looks like something
like what? Remember that for i in range? Yes.
for i in range, for example, start from 20.
Go 200. Take example three. Remember that?
So it has some resemblance with range function?
Yeah. Although range is an arbitrator.
What's an arbitrator? why I'm telling you
that? Okay, let me tell you an arbitrator
as well here, just just just just spend a
few seconds on on this range function. You,
you might be thinking when we call this range,
let's say starting from, let's say range them,
you might be thinking that it returns a list
of numbers, starting from zero to nine, but
that doesn't happen. It returns nothing. Actually,
when you actually call it when you actually
call it it returns just an object. When you
call it in a for loop or somewhere. It progressively
do. rounds one by one element one by one.
So it returns an element, then it hydrates
and return another element that it never creates
a list of elements, it now creates a list
for you. That's awesome. Actually, it generates
numbers, it generates the next number and
the next number as you move on. So it saves
a lot of memory and these kind of objects,
they are called I craters that I played, they
they never played. But if you want, for example,
to get a list, if you really want to get a
list, then what you can do is you can call
the range, let's say in the same way, and
you can just write a list. So provide me a
list don't just provide me an ID. And that
will give you a list. How cool is that? Right?
Anyways, that was just a side note. It has
nothing to do with this arrange function anyways.
So NP dot arrange, it actually returns an
array does not it is not like an iterator,
it returns an array, complete array the way
you want. So that's what this arrange is it
has resemblance with this built in range function
that mostly used in in for loops. Okay. Next,
let's discuss this NP dot random dot permutation
NP dot random is a package. And P is a package,
it has a lot of sub packages inside random
as a package. Random has a lot of modules
one module is permutation. There are a lot
of other modules. So let's see this random.
Let's see what it does. So for example, let's
say a equals NP dot random dot, permutation,
let's say permutation. And what I do is I
say okay, np dot arrange, let's see 10 what
it does is, this NP dot arrange will return
an array containing all the values zero to
nine, these are 10 values, and then this permutation
function that resides in the package and P
dot random that is in the random packet of
MP, it actually shuffles all the values and
rearrange all the values in random fashion.
And he will now be an array containing the
same elements, but in a different order in
a different random order. So let me know print
this a, it will be having all the elements
from zero to nine bought in a really shuffled
away. And that shuffling is completely random.
Yeah, you see that? Sometimes you may you
may call some function, you may want to write
some function on arrays. And you may want
arrays that are that that do not have a particular
ordering, there are just random arrays, just
to test your code just to test how it works
on any kind of array. In that case, one way
of getting shuffled kind of array. One quick
way is to just use NP dot random dot permutation
function. The NP dot random package does not
only have this permutation, there are a lot
of other functions and be random, for example,
np dot random random dot Rand int, for example,
Rand int, that creates a random integer. That's,
for example, if I that's that, let me call
this and we have, how can it be used? Okay,
you can give a low value from the very start,
we can give a high value, I mean, and it creates
actually, random integers starting from low
ending at high. So that's how it can be used.
For example, let me call it as NP dot random
dot Rand int, create a random number between
20 and 30, create some random integer, and
it will return some random integer between
20 and 30. If we call it again, it may return
some other is it is returning 30 again, 29.
Again, and again. Now two turns 2932. Maybe
we want to maybe want to generate random integer
between 20 and 30. So it creates a random
integer. One thing that you might be noticing
what is the what is the return value? the
return value? Is we for example, what should
be the type of E or do you think? Is this
V is an array? No, it is a number. It's an
integer, the type of VA should be an integer
because it is returning a random integer it
is returning an integer but it is selecting
that integer randomly from 20 to 300. So it
should be integer and it is Yes. Wow.
Yeah,
so we will be exploring some more functions
in the random package of NP and then we will
be moving towards this fascinating function
score function called V shape. So there is
more to come for NumPy so hope to see you
in the next video. Okay in the last video
we saw a range function that's a very useful
function to just create a test testing array
and just see see the output of a particular
operation or algorithm, just on different
kinds of arrays. Further we saw permutation
functions permutation function in NP dot random
package. And we saw that this this permutation
function, actually, it reshuffles, it shuffles
different kinds of odd if if array is applied
to this permutation function, it actually
shuffles all the, all the elements of that
array in a random way in a completely random
way. Today, we will explore this random package
a bit more, and then we will see a reshape
function, but that reshape does basically
this reshape, for example, if you have an
array, let's say, array, is let's say we have
an array with, let's say, 10 elements, and
if we call a dot reshape, and we give, let's
say, two by five, so it will make a two dimensional
array out of a, which is B, and that will
be a two by five matrix R, that will be an
array, or a matrix with two rows and five
columns. And now we can, we can just work
with this B, just like it's a two dimensional
array, and we can just, we can just treat
this B as a two dimensional array and work
with that. It is it becomes handy sometimes
if for example, we want to, we want to test
certain operations on on matrices. A quick
way to make a matrix is just to call arrange
function, and then whatever the result is
just reshape it into the desired order matrix
and test the algorithm. So let's go to the
let's go to Jupyter Notebook and check this
random package a bit more and then see the
reshape function. So let's go to Jupyter.
notebook. Yes, so there are a lot of ways
to generate these random numbers. One for
example, we already have seen Rand int. And
other way for example, array, an array can
be generated, like MP dot random dot RAND
function. So now, if we create this, if we
create, let's if we pass let's say 1000, random
value array will be generated in a and a each
value of a will be a random number between
between zero and one. So all these numbers
are just random between zero and one each
number is zero and one random number. And,
and this distribution basically is the distribution
of this random number is all the distribution
is uniform. If for example, you want to plot
the histogram, the histogram or the distribution
of a it will look like uniform. Let me just
give you give you one or two plots, using
matplotlib package, although we will see matplotlib
package later on. But let's assume that this
is just a plotting package. This is just a
package that helps us plotting just import
that import mat plot lib.pi plot as PLT import
that. And after importing that, you just plot
a histogram PLT dot hist, for example, and
pass a and you can see the histogram is roughly
uniform. I mean, everything is equally likely
we can make more bands, for example, we can
have bands, equals let's say 100. And we can
see almost all events they are I mean just
look like uniform. If we make more and more
data set, then they will all look uniform.
One more thing we can we can have, for example
this. And let's say B equals NP dot random
dot Rand n, and that generates normal random
numbers, or Gaussian random numbers, let's
say which which the distribution of the numbers
are is the bell shaped curve, for example,
so let's just PLT dot haste B. And then let's
say equal to 200. And we can see a bell shaped
curve because the distribution of this data
is is Gaussian distribution looks like so.
So this this random packages, this NP dot
random is really important package. It has
different, it can create different kinds of
random numbers from following from different
distributions and doing in machine learning
or in statistics, sometimes we need to generate
these kinds of random numbers for sometimes
for testing purposes, sometimes for adding
noise of a particular type to test our model
and stuff like so. So it's good to have a
good grip on NP dot random package. Okay.
Next we see reshape function. One more thing.
For example, if you want to create, for example,
a two dimensional array of just random numbers,
let's say you can call NP NP dot random dot
Rand. And you can just call a, you can just
pass two arguments, for example, two by three,
and the C will be a two by three matrix. If
you see the C, it will be a two by three matrix
of four random values. If you see c dot, and
then it will be having the dimensions are
two. And it's a two dimensional array. Further,
we can create, for example, a four dimensional
array c equals NP dot random dot Rand, maybe
two by three by four by two. And that's a
four dimensional array with this particular
order. So if you see this C dot m, then that
will be level b, this. Yeah, so let me let
me just give you an interpretation of what
that thing is. There are two arrays that are
three dimensional. And there are two of those.
Okay? Now, each three dimensional array has
three two dimensional arrays. Wow.
So each
two dimensional array has four one dimensional
arrays, and each one dimensional array has
two elements in it. So that's what the structure
is. Yeah, get a good look and feel. So let's
see the reshape function. For example, let's
say we have d equals NP dot range. Let's say
we have 100 values. And then we say reshape
these 100 values to let's say, let's say four
by 25. So this D will be a four by 25 matrix.
So if we just get the shape of D, so that
will be a four by 25 matrix or a two dimensional
array with four rows and 25 columns. Yeah,
so sometimes we want to work on matrices,
and we just, we can just plug in these arrays
function to generate a bunch of numbers. And
then we can reshape those and build a matrix
quickly, and then just test the performance
of our algorithm or stuff like so. So, not
only the reship not only returns the, the
I mean, you can you can reshape a matrix,
and you can reshape an array into more than
two dimensional array if you want to, for
example, arrange 100, let's say dot reshape,
maybe or as four by five by five, it's a three
dimensional array. Now, this D will be a three
dimensional array containing different values.
Yeah, so now you can access it and do whatever
you want to do. So not only the reshape, arrange
and permit random, there are other functions
as well NP dot zeros. For example, if you
press z, and you just see the zeros, and then
you just press the question mark, you will
know what that function is how can we use
it and so on. Similarly, you can have several
other function there is an important function
once for example, you can call that function,
and that will generate an array of all ones,
you can see how to call that function here.
There is NP dot empty, there is NP dot empty,
like there are so many functions just to create
some matrices very quickly. And you want to
test your core algorithms based on those.
So yeah, so there are a lot of functions that
we want to that we can work on. So next, so
there are a lot of functions that can quickly
create a NP array and an n dimensional array.
That we can quickly create an array test or
algorithm or use the array wherever we want
to like we're everyone to use. And we can
move on just a few functions like arranged
ones zeros, they are there are random dot
Rand random dot Rand n, and other functions
they are available. For In the next video
we will be seeing we will be seeing the indexing
or slicing inside NumPy array and we will
also be seeing the difference of that indexing
with or slicing from the array In the list
or or are the ordinary data structures? What
is the difference in? What is the difference
of slicing in NumPy? with for example, with
the list, we will see that in the in the next
video, hope to see you in the next video.
Okay?
Here is my favorite topic in NumPy slicing.
Actually, indexing or slicing in NumPy is
the way you access sub arrays is just the
same as the way you access sub strings or
sub lists. And you already have seen, how
can we how can we use the slicing or indexing
in lists and in strings, the difference here
in NumPy is in list for example, if you slice
you get, for example, let's say B equals a
one colon five, if you slice that thing, from
NumPy, then B is not a copy, it is actually
accessing the same memory view as an A. Now,
if you change any element in B, the corresponding
element in a will change as long as as a NumPy
array. However, if A is a list or any other
data structure, ordinary data structure, then
the slicing this, this kind of slice gives
a copy rather than a view. So that's an important
difference, we need to know that rest of the
indexing technique is almost the same. You
do this kind of indexing that is how you can
reverse this a start and step all all the
things are same, except How can play How can
we play with the two dimensional arrays. Let's
let let's see that. Let's see some examples
of indexing one by one in in Jupyter Notebook
and see how the slicing actually creates a
view rather than a copy. So let's go to our
Jupyter Notebook and see how can we play with
different indices, let's say a is NP dot arrange,
and B dot arranged, let's say 100. And let's
shuffle them. Let's say as it is, let's say
that's a now a, let's say, let's bring some
certain things. Let's A B equals a big all
the elements starting from index three, ending
at index nine, Sudan is not included. That's
B, that's blank v. Let's see what's B. So
b is this array. Okay? Now what I'm going
to do is I'm just changing the contents of
b, this NumPy array is mutable, you can change
the elements inside, no problem. So I'm going
to change the elements, let's say one element
in B, let's say, I'm going to change element
numbers zero, and B, which is three, and I'm
just placing that element as minus 100 minus
1200. That's it. That's the case. Okay, now
the contents of B has been changed. We are
but now let's see the contents of a the contents
of a also has changed. That's a big difference
between slicing an ordinary Lester adini data
structure or slicing a list, when you slice
a list, you get us you get another label,
but that label or that variable is accessing
the same memory, the memory actually is not
copied. There is one memory view. And these
two different names, whether you access those
elements using B, or you access those elements
using a the same memory is being accessed
if you change the memory using B or A you
will see the effect in both of the variables.
So that's one difference. Now, after having
knowledge of this difference, if we really
want this behavior to not happen, one thing
that we can call is we can say okay, a, for
example, a, let's say three to 10. And then
we can call our famous function, remember
that copy, you can copy that and now B is
completely a different array. It's it's a
different memory view, if you change B now,
the effect will not be seen in a so copy function
is there whenever you need copy. One thing
if you are not going to change elements the
number is applies you very fast implementation
of slicing by not changing the memory view
if if you are aware, your algorithm is not
going to change the elements slicing will
give you much much efficient access to the
elements or the or the sub blocks or sub arrays
without actually making the copies inside
the memory which can take time and space both.
So this is one plus of NumPy Over the over
the other data structure that we have seen
so far in Python, okay, let's play with indices,
let's say what do you think? What is that
thing? colon, colon to what? Or colon colon,
let's say five, what it will do, it will start
from the very first index, which is zero,
it will go to the last index, but it will
pick every fifth element. So let's see. So,
it picks zero then five then 10, then 15,
because the jump is five break, what do you
think what this will do? Let me just let me
just teach you by example, what this will
do. Yeah, what it will do remember, if you
apply a minus here, the end and the start
and end they just get swept, and this becomes
a step from from the end. So, what will happen
is the same kind of impact, you start from
the very end, then you take the step of minus
one from the end, and you just based every
element, so this is kind reversing the array
with with kind of step starting at the end
rate. So, another way of reversing the array
is if you want to reverse the array as a whole
display minus one, which means start from
the end and pick every element from the end
till the beginning and the end, and the array
will be reversed. This element is there, remember
that this is there, let's chain that element.
Let's chain that element. So, so a adds position.
So, I want to find out the index, where this
minus 1200 is located. So Id x is equal to
a dot index I guess there is a function index
Yes, he has a no index Oh, there is no index
there. Is there an MP dot index and P dot
index? I want to find out the index where
so in DAX there is no index function indices
or something, I want an index function is
there any index function I want to find out
the index? Where minus 200 is located? There
are several ways but I want to find one. So
for example, for example, let me see whether
there is an index function and not available
in NumPy or not. No, it is no longer there.
But there is in the CS function, I guess.
So in the CS, what that does, I guess that
does the same job. Let me see MPR indices
returns an array representing the indices
of a grid, okay. So I have to give a grid
and then it returns for example, the indices
of all that grid, how can I use that? Well,
it becomes it becomes difficult, there may
be a find function, or how can you locate
the index where the minus 200? Is, is located?
How can I How can I do that?
Huh?
Yeah, very difficult. Seems like very difficult.
Oh, why don't I rather than finding out a
function? Why don't I just play with play
with the NumPy? Why not? So let's say a equal
equals minus 1200. That gives me a Boolean
array comparing each and every element with
minus 1200. So, the array the returning array,
let me call the index array or the Boolean
array, let's be that array is true or false
array or zero or one array, wherever there
is minus 1200, that index is one that value
is one otherwise it is zero, completely zero.
And then what I do is, I just multiply that
with with NP dot arrange NP dot arrange with
with saying that a dot A dot A dot size, so
whatever the size of A is, so because these
are the indices Okay, then what that's point
wise multiplication grade. So, when I will
multiply them together, what I will get is
is what I will get from multiplication, I
will get, how can I How can I find out actually,
a train lost here literally, how can I find
out how can I find out the index where Where
am I? So that will give me what? Let's see,
what is B. Now, the B is B is just an array.
B is just an array, and there is this three.
That is looking at it. So how can I find out?
Where is this three? How can I, again, the
problem is finding out the index. Okay, that's,
that's really a bad thing. Can I call this
aid dot indices? And just give a minus 1200.
And everything just worked out? No, there
is an error, there is an error. Oh, I'm lost
here. Literally, I'm lost here, I need to
know how to find out the index where this
particular element minus 1200 lies. So
that's a
question for you as well. I'm also lost. So
let's see you in the next video. And we first
will solve this problem to finding out the
index of a particular element, or maybe a
lot of elements. And then we will continue
from there onwards to see more indexing. Okay,
great. So hope to see you in the next video
by first solving the problem, how to find
out the index of a particular element in a
NumPy array, or maybe more than one elements
in a NumPy array. And then we will be practicing
more about these slicing examples. Okay, hope
to see you in the next video. Okay, let's
say this element is there. And let's say we
want to, we want to locate that element in
the array, we want to just know where this
element is in the array. So array has this
element. Let's let me paint array as it is,
this array has this particular element, and
we want to know where what is the index of
this element inside the array, there are several
ways of doing this. One way is to find out
their index is simply you call the function
arc where arc where for example, org, where
A is equal to minus 1200. And that will return
a 2d array. And if you just want any one index,
then you return that kind of thing. So if
you write this thing, you will get the index
exactly of the element that is there. So the
index is three, if you want to change that
value, for example, the value should be three
here, if you want to change that value, what
you can do is you can right, okay, ie x is
equal to three, and is reverse to its position
wherever it was created, okay, great. Now,
let's play with the two dimensional indices.
Let's do dimensional arrays, let's say we
have a equals NP dot random dot, Rand, let's
say, let's say we have a five by four matrix,
let's say a two dimensional array, let's round
all the values by multiplying them to 10.
What it does is because all the values this
RAND function, all the values it generates
are the values between zero and one, what
this multiplied by 10, what it does is, it
actually scales up all the values to 10. And
then round function, actually, round downs
are actually rounds the values to the integers.
Now a will be worse the problem round that
third round method is no longer there. Okay,
maybe there is NP naught round, maybe that
NP dot round, maybe NP dot round is their
Yes, and B dot round. So round function of
NP. So this a is a is this array, for example,
that's five by four, a four, five rows and
four columns. So let's say I want to access
the second row. First of all, let's say I
want to access this particular entry. This
particular entry is second row and third column,
which means the index is one comma two, because
second row means the row row first has index
zero. row two has index one. Similarly, column
one has index zero, column two has index two,
a one and column three has index two. So that
is what this particular entry is. What if
we want to access the whole second row, for
example, we want the second row. So that's
how you call that's how you slice. A normal
meaning of this is you the role should be
one and the columns, all the columns, so That's
how you access the whole second row. If you
want to, for example, access the whole third
row, for example, or a whole second column,
let's say that means you say this, okay, the
column number second, and all the rows, which
means the whole second column that is accessed.
That if you see, that's the whole second column
six, four to 10. And one, that's what the
second column is. Further, once you have a,
you can, you can, for example, access a sub
matrix, let's say you want, you want row number
one to rule number three, not including three.
And then of these rows, you want column number
two to column number
four, let's say. And if you do that, you access
the whole sub matrix. First, it actually picks
row number two and row number three, because
row number two starts from one. And then of
those rows, it picks these columns, and you
can just pick the pick the sub matrix inside
more, you can, you can do a lot of processing
on these matrices. For example, this is matrix
A, if you just type a dot transpose, that
these four transpose, the matrix just is taken
transpose of it. Further, there is a complete
library, linear algebra library in NumPy.
For example, if you just import NumPy NumPy
dot linear algebra, as a for example, then
this linear algebra library in NumPy, has
a lot of functions, Eigen values, chelski
decomposition, computing determinant of a
matrix, finding out inverse of a matrix and
what not. For example, let's say we have la
dot inverse, and here is NP dot random dot
Rand, let's say, some three by three matrix.
So what it returns is, it returns the inverse
of this matrix, and this linear algebra library,
and there are other libraries as well. But
this is one scientific library, that may be
most of data science experts who actually
want to do research, they might be thinking,
this linear algebra library, that that specifies
a lot of functions related to related to these
matrices or two dimensional arrays. So that
is there. Okay, so that's about indexing.
We can play with these indices a lot if we
want. One more thing, just just one. One last
thing, let's say this is our a. And what we
want to do is let's say we want to sort this
A with respect to the columns, we want each
column to be sorted individually, what we
can do is we can call sort function, and we
can pause X's equals zero, access equals zero,
that means sort all the columns individually
and the result will be if you see the result,
the result will be every column is sorted
individually. If we want to sort for example,
every row individually, we will say okay,
sort x is equals one, and every row will be
sorted individually. And if this is a multi
dimensional array more than three more than
two dimensions, then x is can be two x's can
be free. So which with respect to whatever
axes you want, your sorting can happen. It
can do that, if A is one dimensionally, then
dot sort function without an access, just
sorts just sorts the one dimensional array
from beginning to the end. And if you want
to descending order a sword just sought them
sorted first and then reverse it using indexing.
Great, I mean, there is a lot to discuss,
there is a lot to discuss, I'm ending this
slicing here. In the next video, I'm going
to show you kind of masking or sometimes called
the fancy indexing that is much more powerful
and useful in a lot of different contexts.
So hope to see you in the next video with
more NumPy indexing. Okay, there is another
way of indexing a NumPy array. In the last
video we saw we can, we can do slicing notation,
for example, start from here and here and
stuff like so. There is another way of accessing
a NumPy array as we have an array and we can
just give the give an index array inside for
example. Let's say a is one dimensional array
and then we just give 146 that means big element
at index one, pick the element at index four,
pick the element at index six. So this kind
of array inside can be a list or an array.
That is called an index array. And you can
just pick the elements that you want to pick,
for example, you want to pick all all elements,
you want to pick first element, fifth element
and 17th element, you can just create an index
array and pass it. And in an index your and
access your elements using that index array
that's possible in NumPy array. Further, you
can access different elements using a Boolean
mask as well. So Boolean array, for example,
true, true, false false, wherever there is
a true pick that element wherever there is
a false, don't pick that element and return
the elements that are picked. For example,
assuming here that you have an array, which
is one dimensional array, let's say, assume
that has eight elements, 12345678 elements.
Now you pass a Boolean mask inside, where
with with obviously, eight elements, a true
or false values, wherever there is true. So
pick the very first value, pick the second
value, pick the don't pick the third value,
don't pick the fourth value, pick the fifth
value, pick the sixth value, pick the seventh
value, and don't pick the last value. So that
is also possible in in NumPy. One thing that
is important is if you do this kind of indexing,
which is sometimes called masking, if you
do that, if you do if you supply an array
index, or index in a Boolean form, you by
default get a copy as as as compared to slicing
in slicing, you get a view that's a separate
copy, you need not to call a dot copy function,
it is by default, a different copy. And this
is a difference between the ordinary slicing
that you do, for example, start from one go
till 50, take a jump of let's say two, if
that is your indexing style, that is called
a slicing, the return value is a different
view having the same memory. However, if you
do the, if you use the array index, or the
Boolean array called masks, then you get a
copy of rather than also so which means if
you if you get a new array, you change the
elements in the new array using the array
indices. You're not getting that change happen
to the original array. So that's the difference
between slicing and masking. Okay, this kind
of Boolean indexing becomes really handy.
For example, what if you want to exit? What
if you want to get all elements that are smaller
than eight, one way to do that is just write
a and then apply a condition is less than
eight, well, a is less than eight, we'll create
a Boolean array. And everywhere where the
element is smaller than eight, there will
be a true otherwise it will be false. Now,
the inside array is a Boolean array, and you
access all the elements with respect to that
condition. So it will return all elements
that are smaller than eight. How how fancy
is that? Further, you can you can have these
conditions in a combined way. There is one
difference there is an AND operator A and
D and, and there isn't an operating in a different
way. So I'm going to discuss the difference
of this and this and as well in this in this
whole in this video. So let's go to Jupyter
Notebook our fan and see how can we play with
this masks.
So let's say a is again and B dot arrange,
arrange, let's say 100. That's it. That's
our a. And what we now do is we access the
elements of A, B access, for example, the
third element and the fifth element and the
sixth element. Let's say we want to do that.
And that's our B. So that happens, let's say,
so what B is B is this, something that you
need to know is if you change the elements
of B now, because that's a copy, let's say
minus four, that change does not happen in
eight that happens in B for sure. But that
doesn't happen in a, a does not contain any
value that is minus four. Because using these
kinds of indices, the array index By default,
the result is a copy rather than a view. Further,
let's say you have this a and you want to
access all the elements that are smaller than
let's say that are smaller than let's say
40, access all elements that are smaller than
40. So that is possible now even contain only
the elements that are smaller than 40. All
the elements while further if you want to
access all elements that are that are smaller
than 40 that are smaller than 40. And they
are bigger than they are smaller than 40.
And they are bigger than 30. Let's say you
want to access all the elements that are between
30 and 40. You can just access those elements
like so there is a problem. A dot any a dot
all what's the problem here? The truth value
of an array with more than one element is
ambiguous use a.ne or a dot all. Okay, this
a is less than 40 is a Boolean array is greater
than 40. That's a Boolean array. So what's
the problem? What, why can't we not use this?
What's the problem? We should have used that.
So use and, and, yeah, I guess we were missing
these, we were missing these brackets because
it might be confusing this 40 with this a
and stuff like so. So use parenthesis rate.
Now, B contains only the elements that are
between 30 and 40. Now, one thing, what's
the difference between this particular and
and this symbol and the difference is this
and AMD an operator It is used when both of
the sides of this end has what is one object
and it has one true value either true or false.
And this particular symbol is used when the
left side and the right side can be arrays,
and each element of that array can be true
or false. And so, so, you can think of this
and is using arrays, however, this is used
when both the sides are single objects. So
that's the difference. Other variants of and
I mean, the end is like this, that these are
these are the same things, but remember the
use this is used for arrays, this is used
for single objects. Similarly, there are other
symbols like
or
that is used this way or or that is used that
way. Similarly, there is a not not for arrays
is used like this way and not for otherwise,
is used like that way. So remember these the
left side, I have symbols, they are used for
arrays, the right kind of symbols, they are
used for single objects that has true or false
values. So these, this kind of masking is
really, really powerful. Later, we will see
in pandas accessing different kinds of data
with particular kind of conditioning, that
becomes really handy if we if we are comfortable
with these kinds of indexing. And that's really
powerful indexing. Okay. So, I've told you
the difference here between Aaron and I've
told you that this is copy rather than a view.
So just bear with me some more time on NumPy.
And I will tell you some more truths about
NumPy. And then we will move towards another
package called pandas. So before pandas more
NumPy is coming, I hope to see you in the
next video. Okay, in the last video, we saw
masking, which is sometimes called the fancy
indexing as well. And here we are going to
discuss one more feature of NumPy, which is
very powerful feature called broadcasting.
I think, for example, you have an array, let's
say two, three, a matrix, that's a two dimensional
array 235 and nine, and you want to add, in
every element, you want to add a number, let's
say five. So one way to do that is create
another array with 5555. And just apply this
add operator and you are done. Great. But
this NumPy allows you to just write let's
say this is array, a NumPy allows you to just
do this particular thing. And this five is
automatically broadcasted to match with the
dimensions of its other operand. And addition
happens you need not to do this explicitly.
And this broadcasting is not just one scalar
value. For example, if you have one variable,
let's say a is this and you want to add, for
example, this particular column, let's say
one three, you want to add this particular
column in the first column as well as in the
second column, but then you need this one
three to be copied again and make a bigger
array and then you do that well, broadcasting
allows you if you just write this as a plus
one three, it will be automatically broadcasted
to match the size of the other operand, wherever
the book broadcasting is possible, there are
certain rules to to know when broadcasting
is possible it is not possible each and every
time. For example, if you have this matrix
239 and Jeff 421 Let's at this matrix and
you want for example, two one and six two,
for example, if you want to do that, the broadcasting
may not happen because in this way, if I want
to broadcast this structure, the structures
should be if if the structure is broadcasted
to in horizontal way, the the two columns
will be arrayed and the addition cannot happen.
If it expands to a vertical way still the
addition cannot happen. So, this here you
will get an error because broadcasting is
cannot happen, but in several cases when you
want to add for example, a scalar multiply
with a particular thing wherever possible
this broadcasting is possible and broadcasting
is just a I mean it just a feature of NumPy
that allows you to not repeat to match the
dimension of the other operand to apply a
particular operator it does it by itself great.
Next, we see some more important functions
to no one is horizontal stack. That means,
if you want to concatenate two different array
two arrays that are that can be concatenated
together horizontally, you can get out you
can call at stack function and that will concatenate
the two arrays together and returns another
array. Similarly, V stack is if you want to
concatenate two arrays vertically, if they
can be concatenated vertically, vertically,
similarly, there, there is another powerful
function sort, and there are a lot of other
functions, these kinds of functions, they
are called Universal functions. And they are
very, very, very powerful, very, very fast
their implementation is vectorized, where
Christ mean the implementation the all loop
kind of layer is deferred to at the compile
time and the things are really faster when
you do a vectorized code. So, having said
that, it is always recommended to not use
explicitly for loops to achieve these kind
of,
to achieve these kind of results, whenever
a universal function is available, use that
because the efficiency of that universal function
will be way, way way more than then whatever
loop loop or whatever function you will be
writing other than the universal function.
So, and by the way, there is another function
concatenate as well, in which you can specify
axes. And it will either act as horizontal
stack or either act as vertical stack, depending
upon whether the x value is zero or one, whatever.
So, let's just get comfortable with these,
these three functions, just quickly neural
Jupyter Notebook and see an example of, let's
say, broadcasting as well. So let's say we
have a function, and let's say you have an
array is let's say, np dot random dot Rand,
let's say that is two by three. And then I
just multiply this with them. Remember the
last thing and then we just NP dot around,
we just round everything. So that it becomes
it becomes whole, in this particular way.
Okay, that's a, let's say, so that's our a,
that's the now if we say a plus three, three
will be added everywhere in a, and that happens
through broadcasting. Well, if we if we do,
for example, a plus, for example, np dot range,
let's say just do values, and then we just
reshape it, reshape it, to reshape it to let's
say, a two by one matrix. If you do that,
then still, what what will happen is just
apply the parenthesis just to show that this
should happen. First, what what will happen
is there will, there will be a column that
will be added to every column A, and that
again, will be happened through through the
broadcasting. So broadcasting is that powerful.
Next, let's see the stats. So that's it, this
is a, let's say we have the that's another
way, let's say NP dot random dot Rand. Let's
say that new array is two by two. And again,
let's say it is multiplied by Dan and NP doc
round just to avoid the decimal points. That's
it, this is B. Now a is two by three array
D is a two by two array, if I just concatenate
them horizontally, I will get another array
which will be two by five. So C equals np.at
stack horizontal stack, at stack, and I will
call these A and B. One thing that you need
to know is if you if you want to call this
x stack, horizontal stack or vertical stack,
these arguments in B that you want to concatenate
you have to give them in a topple or you may
you may want to give several values to concatenate
together maybe you have maybe you have 10
matrices to concatenate together horizontally.
You have to give all these as a tuple inside
a All right. Now similarly, we can do a vertical
stack if we want. I mean, one on top of the
other. And we can call it and getting it function
as well, if you want. Third is sort function.
For example, if we want. If you want to use
NP dot, let's say a is NP dot random dot permutation,
let's say NP dot range, let's say the 10 values.
Let's say that our a, let's say, this is a,
and we want to sort this array. Oh, this is
already sorted. Why is it sorted? No, it is
not sorted 1/4. It is not sorted? Yeah. Let's
say we want to sort it a dot sort. One way
of doing that is just call a dot sort, and
you're done. That's the value of a another
way, which is sometimes more readable, although
exactly the same is to use a universal function,
using NP dot that thing that also is the same
thing. Now sort by default sorts in ascending
order. If you want to sort in descending order,
then what you can do is you can sort aid or
sought, for example, do that in ascending
order, then what you do is you just reverse
it, minus one, and just copy that in a again,
now he will be sorted. While sorted in descending
order. Yeah, great. Um, one more just just
just just to give you one more flavor, if
you create an array, for example, np dot array
of strings, for example, ABC, and another
string is, how are you and vai maybe we have
another string? Whew, 785. And maybe we have
another string, one, three e r, that's it.
That's a string. That is possible. As long
as all the objects have same type, you can
create an empty array. Now, you might be wondering,
what we'll do this sort function on a because
these are all strings? Well, the answer is
it will sort the strings according to the
alphabetic order, whatever the alphabetic
order is, whatever string according to the
alphabetic order should become first that
will become first and the other strings, they
will they will just join. Yeah. So yeah, so
that's about something that is not that is
not the numeric value. Okay, great. There
is a few more things to come about NumPy array,
and then we will be moving towards panda's
library that is built on top of NumPy array
for better processing of data, I hope to see
you in the next video. Okay, in last video,
we saw horizontal concatenation, vertical
concatenation sort function, we also saw some
broadcasting and stuff like so. Universal
functions, it should be speed here, sorry,
it should be speed, speed. Universal functions
are really, really speedy, I always am talking
about NumPy. Whenever I start NumPy, I said,
it is fast, it is fast as fast, I never show
you how fast that is. So let me give you an
example. Let me let me just create an A NumPy
array with a lot of numbers, and then just
apply an ordinary function, let's say want
to add all the numbers in this array B, let's
apply an ordinary function that is not in
NumPy. And then let's use universal function
dot sum, and see how speed differences there.
If for example, we apply apply a universal
function to achieve a particular task how
speedy that universal function is, because
a vectorized implementation, as I told you
is much faster, how faster let's check that
out in new Jupyter Notebook. That's a magic
command time ID that will tell us how much
time this particular task has, has taken.
And if you run this command, it will it will
call this function again and again several
times. And then we'll report an average value
that will be much more stable than just calling
once. After that, we will also we will also
write our own sum function using loop. And
we will see whether that is even closer to
a universal function speed or not. Let us
just check the speed of universal functions
that will give you a look and feel of how
much NumPy implementation is faster. So let's
say we have an array, let's say B and B dot
random dot Rand. And let's say that array
is huge, really huge. Let's say that's the
case. Now what we do is we let's say we we
call a function sum. So let's say we call
a function sum. That's a built in function.
In Mumbai, that's a built in function that's
a built in function in Python, not a NumPy
function. And then let's say we do the same
task using NumPy universal function and P
dot sum, that's the same as NP dot sum is
the same as if we if we write, for example,
b dot sum.
So whether you write b dot sum, or you use
NP dot sum and be passed and passed, as an
argument, both these things are roughly the
same. So let's run it, it will take a while
It will take a time because, okay, the sum
function takes 307 milliseconds, that is not
a universal function in NumPy. That's a Python
function. That is not written in NumPy. That
is not a vectorized code, nothing. It takes
307 milliseconds to perform to take the sum
of the elements of this array. And it does
that by applying seven rounds in in Santa
loops. However, the universal function takes
just around three milliseconds, I'm assuming
2.7 milliseconds, how will how are you going
to compare this 307? With three? How much
faster you are around? Around 100? times your
faster? I mean, yeah, I mean, this NumPy is
literally faster NumPy, the universal function
will faster, maybe you attempt to know that,
okay, the sum function might be too slow.
Let me write my own function. To do that,
let me define my son, and my son just take
an argument, let's say something, let's say
G. And what it does is for, let's say s equals
zero, what it does is for x in g, s plus equals
2x X plus equals to x and then just return
as nothing. That's your function. Let's say
you think that this is really a great function.
Let's do that. Okay, let's compute the time
for this time it my son. And let's pause the
rabee and see how faster this is. This is
roughly the same as your calling the sum function,
but this NP dot sum or the universal function
is very faster, fairly faster. So, use universal
functions, avoid for loops, avoid your own
functions, if the same task has been a can
be achieved through universal functions, whenever
possible, avoid loops when you are working
with NumPy. That serious suggestion, follow
that, because the universal function written
in NumPy, they follow the vectorized code,
all the interpreted slowness that is deferred
to the compilation layer. And the NumPy becomes
really really faster and shows its power when
you are working on large arrays using the
universal functions. So I can speak more about
NumPy. But I have told you some basics of
NumPy. And we end the NumPy here and from
the next video, we will be moving towards
a very, very fancy and beautiful kind of package
called pandas to handle data. And by the way,
the pandas library the pandas package completely
is built on top of NumPy. Everything that
is there in pandas is built inside is built
on top of NumPy as all the indexing and all
kinds of stuff, slicing and speed. All is
there in pandas that is due to the NumPy.
So we will see one more package after pandas
which is matplotlib for for plotting afterwards.
And we'll do a project at the end using scikit
learn as well, just to wrap up all these things
together. But for now I'm ending NumPy here
and in the next video, we will start pandas
hope to see you in the next video. Okay, welcome
to pandas data science package that is very,
very powerful of handling data, manipulating
data and used a lot in data munging and data
cleaning and data pre processing and whatnot.
This pandas basically is built on top of NumPy.
So most of the features of NumPy is also available
in pandas.
Let's let's dive in. I mean, this pandas is
a very, very fancy library, very, very fancy
package, that you can handle very large amounts
of data in CSV files or an Excel files. Wherever
the data is located. The missing entries are
there. You can handle all the data you can
manipulate all the data you can prepare all
the data in just a few lines of Using this
pandas package, so let's just start pandas
package. There are two most important objects
of pandas. One is series and other is data
frame that we will see later on, there is
one more index. But the most important one
is, or the useful one is the series and data
frames. So let's just define, first of all,
you need to import pandas package import pandas.
And you can rename this as PD, that's a, that's
the most popular renaming, although you can
rename it any. And then you just say okay,
PD dot series, and then just like a NumPy
array, you pass the data that you want. And
you can create your own indices, for example,
like, just like dictionary, this a is a key
value. This is a key or index for this point,
two, five, this B is index 4.5, C is index
4.75. And these index four one, so you can
you can, you can supply your explicit indices
as well. If you do not supply the indices,
the default indices are 012, and three, but
you can define your own his own indices in
the way you want. Now, once this data object
is created, you can call the data values and
you will find out the values you can call
the dollar index and you will find out the
indices let's see in the Jupyter Notebook
just to get comfortable with pandas. First
of all, import pandas as PD, maybe or something
else. So okay, let's import it, maybe we can
check what we're going to reveal working in
PD dot worryin. The version of pandas we are
working in right now is 0.2 4.25. Read. So
let's create data or whatever variable let's
say a as PD dot series buzy dot series and
there we just give a list of some values 2345
let's say these are the values. And then we
can give index as another list. Let's say
the indices are a maybe the indices need not
to be strings, anymore, anything AB, C, and
let's say the index of fighters. Let's see.
So now the series object or the pandas object
series is created. Series basically handles
one dimensional arrays, later on, we will
see DataFrame handles multi dimensional arrays,
I mean more than one dimensions. Normally
typically two dimensional arrays, but okay,
a dot values. So let's call the values, values,
and you will get all the values inside the
series. And by the way, this values array
that you get, let's check what's the type
of that array was type of battery? A dot values?
What is that thing? That's a NumPy array.
Wow. And what's the type of a itself that
will be a pandas object. Great. So everything
inside pandas, the NumPy is playing all the
role inside pandas. Great. So now, let's check
the index a dot index. That's also a NumPy.
That's also an array of index type, that's
a different actually index is also an object
in pandas. That's an index type object with
these kind of indices, we can access for example,
this a, just like we are working with dictionary
for example, a dat returns a value, we can
change the values, we can add different, we
can add more key value pairs. So just think
like these.
Just think this data I'll just like the dictionary
object that we saw this, these are the keys
and these are the values. And this is one
one very good way of remembering what the
series does, and manipulating series The way
we want. Okay, one, we can access a z like
this, we also can do slicing. Let's say we
want to access from A to let's say C let's
say we want to access all these one difference
is when you access like this, in the normal
slicing using implicit indices, for example
123 or zero, the final index is not included,
but if you access like so, using explicit
indices that are there, the final index is
also included. So that is one more fancy way
of indexing using in this pandas. Okay. Great,
that's a serious object by the way, we can
create a serious object by first creating
a dictionary for example. Let's let's go back
to our slides and see this example, let's
create a dictionary. For example, of plates,
let's have a lot of students with Grade A
grade A minus Grade B, red b minus, and let's
create that dictionary, then we can just create
a series object or panda's object, by just
passing this dictionary inside, we can make
another dictionary for example, and we can
make another series object. So a one way of
defining the series object is just to is just
to pass the data as well as index in other
ways to just first create the dictionary and
just pass the dictionary variable inside,
and the series object will be created. Okay,
that was just an introduction to series, we
will move on and see more features of pandas,
as we as we explore it more and more in the
upcoming videos. Hope to see you in the next
video. Okay, let's say we have two different
dictionaries, let's say we have a lot of students
and the a grade is defined to be four and
a minus grades defined to be 3.5. The b grade
A has a number three, the B minus grade has
a number of a numeric value that is 2.5. And
similarly b grade has an American value let's
do and then we create just a series object
using this dictionary, let's say rather than
just the numeric values as GPS or something
like so let's say a grade also is defined
at 85 marks in total, a minus graders defined
at 80 marks in total, and similarly these
and then we create another series object,
let's say named with Mark marks using these
PD dot series. So let's go to Jupyter Notebook
and just play a little with these dictionaries.
And build the series object, let's say marks,
or let's say grades. dictionary equals, let's
say, a grade, is has has an eighth grade has
number value for RGB value for let's say,
let's say we have a b grade with GPA value,
let's say B is let's say it's 3.5. Let's say
we have C grade with GPA value, let's say
three. And let's say Finally, we have d grade
with GPA value, let's say 2.5. Let's say that's
a dictionary. Okay? What we do now is we create
a grades series object, let's say using PD
dot series, and just pass this grades underscore
teched. Now this capital a capital B, capital
C and capital D, they will act as indices
and this for 3.53. In 2.5, they will act like
values. So for example, if we call her and
just now called grades dot v dot values, so
we will get, for example, what is that? That
just values, let's say, beget this grade stock
values, and we get all the values that are
available. Similarly, if we find grades or
index, we will find out A, B, C and D. Let's
define another dictionary, for example, marks
dictionary dict. And there is let's say again,
a while the total marks are 85. For the a
grade, let's say, for b grade, the total marks
are let's say, 75. Let's say for C grade,
the total marks are
let's say 65. And for D grade, let's say the
total marks are 55, let's say. So let's say
that's another dictionary. Now, let's create
a series of objects, a series object PD dot
series, series, let's say marks dictionary.
So now again, we have if you just write this
marks, just like so, you will see the marks
is 85, b 75, c 65, D is 55. And all the values
they are integer 64. Ghana values, now we
can access. Now we can play with this marks,
for example, if we just want to access for
example, what are the marks? What are the
marks between, let's say, for example, what
are the marks given a at a we can access that
we can change that we can just play like a
dictionary. What if we rather than using the
index In a, we use for example, slicing, we
want to start from the very beginning. And
let's say we want to go to two what will happen?
Let's see. Yeah, so, the slicing is there
for example, if you want these are explicit
indices A B, C, D, these are explicit indices
and they are there. For example, if you can
slice the you can slice the data using explicit
indices that you are given that you are given
or implicit indices that are the default indices,
the first value index at zero, the second
value is index two one and so on. So, you
can do that as well, one catch here for example,
that we will see later on, there may be a
problem that your explicit indices they are
also numeric, and then you do the slicing
like so, then the series object may be confused
whether I have to use the explicit indices
or implicit indices inside we will see how
to resolve that issue, but by this pandas
allowed to use explicit indices as well as
the implicit indices. Okay, we were here.
So, he just so, yeah, so, we were here. So,
we have created these grades a series object
This marks as a series object, these the series
object is good for one dimensional arrays
or data with just one dimensional list or
dictionary, kind of with just one dimensions,
later, we will see data frame that actually
is is actually the extension of curl can be
looks like it can be looked like as an extension
of series towards more than one dimension,
we may have, for example, two dimensional
arrays or two dimensional data structures,
something like so. And we will be seeing this
data frame which is much more powerful, particularly
for reading data from files and manipulating
it and stuff like so. We will see that in
the next video data frame that running form
of data frame in the next video, hope to see
you in the next video. Okay, in the last video,
we were discussing series, and I told you
that data frame is basically if if the data
has if the data in the form of different columns,
for example, a record as an array, then you
have another record, then you have another
record. And each element in that record is
a different attribute. So this particular
way of two dimensional data is very well handled
using data frame inside pandas rather than
series. So but you can make these data frame
objects using different series objects. For
example, you have a great object that grades
object that we created last time, you know,
marks object that we created last time, let's
build a data frame using these two and see
what it looks like in in Jupyter. notebook.
Let's see that. So remember, we have a marks
series object, and we have a grades series
object. Let's now make grades. Maybe, maybe
the name is rates, okay? The name is like
grades. Okay, so grades object, this one,
let's make a data frame.
Let's say D, or maybe whatever name you want
to do data frame with, again, that data frame
can also be defined using a dictionary. Again,
now we have let's say, marks is the key for
data marks. And grades is the key for data
grades. Let's say let's say we define a data
frame like so. And now if you see if you just
display this D, we get a very beautiful look
and feel of I mean this as the index is the
explicit index at index a, the marks, the
marks is 85. The grades are for at index B,
the marks are 75, the grades are 33.5. And
so on that that looks like so not only that,
you can just transpose it like you have transpose
to a NumPy array, and you will get the flipped
version or the transpose variant if you want.
Great. So that's how and you can have for
example, more dictionaries to concatenate
together and more columns will be added here.
And that's what the real data looks like.
I mean, it has a lot of columns, which normally
are attributes. And each row is basically
one record or one sample of the data that
you want to work on. So this data frame is
really, really ideal data structure for working
with files, having a lot of records and you
want to manipulate the data and stuff like
so. So yeah, so one more thing, let's let's
access the D, for example, that's brand D,
that's the, that's the D, let's access the
values inside D, other than No, so what are
the values, so, the values inside D is completely
again, a two dimensional array that is completely
like so. So for example, if we want to access
this particular element 65, that is row number
three, and column number one, excluding the
indices at row number three and column number
one. So we can access that particular value
T dot values, just assuming that dimensional
NumPy array, row number three is to index
with do and column number one is index with
that, and we will be able to access 65. Wow,
great. So that is there. There are more things
that are available d dot for example, columns,
d dot columns, columns, it will give us what
are the columns, the columns are marks and
grades. There and there are other properties.
And there are other several properties that
we need to know Rs, for example, this there,
we define this as di d dot index and stuff
like so. Okay. One more thing that you need
to know is we can repeat right now we have
that sub D, that is this one. That's the D.
Let's say we want to add another column here,
just we want to add another column here. And
that is the name of that column is scaled
marks. And the scale marks are what if we
have computed marks, rather than from 100?
What if we have computed marks out of 90?
What are the scaled marks up 90? So one way
to do that, and very quick way to do that
is just like a dictionary, again, like a dictionary,
you just add a new key, let's say, scaled
marks, that's a new key. and the value is
simply all the marks column divided by 90.
So is that true? No? divided by 90, if we
have just completed all the marks by 90, and
then how can we? How can we compute the marks
from 90? It is rather than 100. It is from
90, I guess? How can we compute the marks
from 90? If you want to compute the marks
from 90, I guess they will look like and divided
by 90. And maybe 100 is multiplied here. I
guess maybe the formula. I guess that that
that's what it is, I guess let's see. So now
if you see D, there will be another column
that is there. And oh, it does something else.
Anyways, it does something that Yeah, so something
anyways, so we see we have just, I mean, we've
just computed this, we just
we just found that we just inserted that column
inside that I'm in, there is a process for
each of these kinds of values. Maybe we have
added this column in a very wrong way. And
later on, we suggest that okay, we should
delete that column. Well, that's very simple.
Again, using the concepts again, just like
the dictionaries, delete this, and this column
is deleted from data. And you're again with
the data that you had. So you can add columns,
you can delete columns, and indexing is really
fine. I mean, indexing like like masking,
let's say, you want to bake for example, or
you want to bake the DataFrame such that you
want to pick all the records such that the
marks are the marks are. The marks are greater
than let's say, greater than, let's say 70.
You want to pick all the records where the
bulk of the marks are greater than 70. This
is that simple. All the data will be will
be copied into g with this condition. And
this condition can be arbitrarily complex
using ands and ORS and combinations and all
that stuff. And you have seen this kind of
stuff in NumPy as well. I mean, this is called
Okay, great. So that's available in pandas
as well. Okay, so that's how you can index
in the next. In the next video, I'm going
to basically show you one type of problem
that normally happens in real data that is
the missing value problem. Sometimes you read
a data and some of the attributes or some
of the row column p values they are just missing.
I mean, they are not available due to certain
reasons. How can you How can you handle those
values? And how actually pandas suggest you
to handle those kinds of missing values, which
are sometimes called Nan values or non type
values. Also, they they mostly used interchangeably
in pandas. So in the next video, we are going
to handle or see how to handle missing data
in pandas hope to see you in the next video.
Okay, in the last video, we saw data frame
object. And we saw actually how to add and
remove columns how to process data, how to
index how to actually mask or how to apply
conditions and selections in in bond as we
saw that very briefly, but in this particular
video, we are going to see one kind of missing
value, sometimes called name or not a number,
or maybe not anything or sometimes this nun
type none, which is the default return type
of any function. In Python. This non type
is also sometimes in pandas is treated as
Nan or Nan is treated as none or interchangeably.
Any anything. Let me give you what do we mean
by that, let's say we have two dictionaries,
let's say one dictionary is a with key value
a and value is one, then B and the value is
two. Okay? The other dictionary is B and C.
So for example, that is one record with columns
A and B. So a and b are the columns. On the
first record, the value of a is one, and the
value of b is two. Now let's say we want to
insert another record in the same data frame.
Now the value of b is available in the second
time, well, if b is available, which is three,
and the value of c is available, which means
a C column is added now. But for the value
c the first row value is not available. So
we will say this value is missing here. But
in the second row, we have four similarly,
the value of a is missing for for the second
row, and that is a missing value, which is
sometimes called Nam. So these are missing
values. And they are typical. When you are
working with data. And you're reading data
on you're getting data from, from out from
somewhere or large files and stuff like so.
So pandas give some methods to handle these
kind of
these kind of I mean, this kind of situation,
let's say let's say a equals PD dot data frame,
data frame, again, a dictionary, let's say
we have a,
one and B, let's say four, that's the first
row or record. The second record, let's say
is another dictionary, let's say B is minus
three, and C is let's say, nine. That's it.
That's it. That's our data frame a. So now
if you bring this a if you see the data inside
a, you will see Oh, what's the problem? Is
this and be heavy? Have you played something
in a wrong way? Let's see. Oh, we have to
create a list. That's okay, we have to create
a list of it, you have to create list of dictionaries,
that's the proper way of calling it. So we
missed just this index list of that. Okay,
right. So now we have this A, B, just call
that a and this value is missing and that
value is missing. And in large data files,
this is typical, I mean, there are a lot of
values that can be missing. One way that pandas
supplies to hell these missing values is to
just fill these missing values with some some
fixed number for example, there is a fill
na function, fill any function and let's say
you supply as zero that means wherever there
is a not available or not a number value,
fill that with zero, or maybe any any value
you want to fill that with. So that is One
way to do that, and now if you see the value
of a is all the non values are filled with
that, another kind of function that is available
in pandas that is sometimes used a that is
drop na that that function drop na, what that
does is it drops all the records that contain
a missing value. Sometimes if that is visible,
I mean dropping all the records that contain
missing values, if that is visible, then go
for that. But if if the if the missing values
are a lot and they are spread over a lot of
rows, then dropping all those kinds of records,
they will create a lot of I mean data loss
and and then it becomes really, really important
how to how to handle these missing values.
However, you can fix you can fill the missing
values using fixed value or you can drop them
and later on we will see in scikit learn that
there are other ways of handling the missing
values as well, you can fill the each column
missing values in each column using an average
or using for example, a regression there are
ways to to handle these missing values. But
in pandas, these two functions are right away
they are you can fill all them with a fixed
value for example or you can drop them and
you are ready to go. Okay great. Next, we
are going to see oh as as I mentioned earlier,
what is the what is the confusion between
what if there is a confusion between implicit
and explicit indices. And that I will discuss
in the next video basically, just to give
you a look and feel what if the explicit indices
you supply they are one three and five. And
what if you call this this particular command
one colon three, will it call the implicit
index or the explicit index, that's a problem.
So we will see because 1.1 colon three, one
and three they are also explicit indices.
And whether this one colon three is referring
to the implicit indices that are default indices,
or they're referring to these indices. So
this confusion is there and we will see how
to handle that confusion. Using this lock,
LLC function and index lock ilsc function,
we will see that in the next video, hope to
see you in the next
video. Okay, in the previous video, I mentioned
a confusion that can be there, if you have
supplied the explicit indices that can conflict
with implicit indices. In particular, for
example, if this is the series object, or
maybe a data frame object if you want to if
for indices, let's just think about the series
object, it has these values ABC with index
one three and five, if you for example, access
a particular element let's say data with index
one that means the explicit index for sure,
but if for example, we slice the values for
example, one colon three, the default behavior
of slicing if you give an American disease,
that is to use implicit indices, and by implicit
indices, we mean by we mean that what is at
index one at index one this is b, so B will
be printed for example, or B will be fetched,
and then you move to do which is C then C
will be fetched, and these are the values
that will be printed, but the behavior might
be different, you might be expecting to use
explicit indices, which means access one colon
three, and when the explicit indices are used,
the last index is also included. And in that
case, you might be expecting the index one
is of a so as should be printed, and index
three is of B and B should be printed. And
this configure might be there if if this is
there. So to handle that there is there are
two functions one is called l OC. And another
method is called i l OC, whenever you call
LLC, that means you are using explicit indices.
I mean, you're forcing to use explicit index.
And whenever you call, I LSE that means you're
accessing elements using the implicit index
what whatsoever. So let's, let's practice
this and see the confusion. See the detail
of this kind of confusions in in here Jupyter
Notebook. So let's say we have a series object,
let's say a equals PD dot series. And let's
say it has values as a, b, and c, NASA value.
These are the values and index as let's say
One, three and five let's add these are the
indices let's say this is eight Okay, let's
say we access a using one that means that
means the explicit index and that is this
let's say B access and using the slicing operator.
Now, this will use implicit indices and it
will access I mean it will access these B
and C because one colon three using indices
implicit indices results that and we might
be might be expecting that use this kind of
stuff. So, if we are really interested in
using explicit indices, what should we do
is we should call the lat function a lock
and then one colon three that means, use explicit
indices there is to remove the confusions
now, it will use the explicit index one and
three and if for example, we are interested
in using implicit indices, then it is good
to use ilok function Yeah, now, one one column
three is to use implicit indices and the implicit
indices are like these. So, and like in series
objects you can you can you can do the same
in data frame objects. Once you are using
lock and ilok then the further indexing inside
these square brackets is exactly the same
like NumPy. So, whether you use log or ILOG,
the indexing mechanism is exactly that the
slicing mechanism is exactly the same like,
like you you you have used in in NumPy. I
mean all indexing that stays the same log
means you're using explicit index ILOG means
you are using explicit implicit index. Let's
say for example, we have our data frame, I
guess D, that's our data frame available to
us. Let's say I want to access d dot ilok.
Let's say I want to access the second row
completely the second record, oh, the record
that is indexed at look at an index at two,
which is a third row completely, let's say
I want to
access that. Now this two is acting as this
two is acting as, for example, if you see
the the second row or the or the row at the
second index, which is a third row that is
completely this edit returns that once you
have used a lock, for example, and mostly
people use ilok. Sometimes lock is also required.
But I log is just to explicitly mentioning
that I'm using I'm going to use the implicit
indexing scheme. Again, you can consider hold
that thing as a matrix. And once you have
applied this eye lock, then you're free to
play with the indices, like you play with
two dimensional arrays, for example. I want
to for example, I want to reverse, for example,
all the rows and I want to reverse all the
all the all the structure, for example, let's
say I want to do that. And you can see everything
is reversed. I mean all the indexing like
like nine by all indexing is there in, in
pandas. I mean, once you have used ilok inside
is just just remember the NumPy indexing and
everything like so. Okay, so that's the log
and I log function. In the next video, we
are actually going to going to just practice
the pandas to actually to actually work on
our data file that is saved as a CSV file.
So we will, we will show you how to how to
actually add how to actually manipulate read
and write the data and play with the data,
the data, the real data that is there in in
some CSV file, and how pandas will help you
to to manipulate the data very efficiently
and very quickly. So hope to see you in the
next video. Okay, in this particular video,
I will be talking about real data set. The
data set I have chosen just to show you some
some functions that are available in pandas
to work on real data set the data set I've
chosen as COVID-19 data set that was available
on kaggle. And it's surreal data set that
contains information of victims recovered
the total number of recovered people in per
country per province, the total number of
died people and the total number of number
of reported people per date available that
that data is available. Let's see the look
and feel of that data in a file. Just to just
to see what kind of data we are talking about.
Let's say this is our data. This is the serial
number column that contains just the record
number. That's, that's a column called observation
date. That's a date, that's a province or
state. That's country or region that's last
updated when the record is updated was the
time and how many confirmed cases were there
at that date, and how many deaths at that
date and how many recovered at that date,
as the date is moving on and on, you will
be seeing that the number of confirmed cases
and the number of recovered cases they will
be increasing, maybe the number of deaths
they also increase. So let's see this data.
Let's read that data using pandas and do some
manipulation of this data and see the look
and feel of that data. In Jupyter, notebook.
Let's go to Jupyter Notebook and see. So first
of all, I need this pandas library and pour
it that maybe somewhere I need this NumPy
library as well. I'm also learning a psychic
learn SK learn library because I want to,
I want to use impute function, just to handle
the missing values, it is just more powerful
to use the I'm in the SK learn library there
is also a Data Science Library package that
is particularly a machine learning library,
or our package that actually gives a better
support or a larger support of handling missing
data. Although here I have used this SK learn
function just for an example. And but but
I could have used this data frame fill any
function or something like so but I'm just
using that one. Okay, after importing all
these, what I did is I just call PD dot read
CSV function, and I load that data and then
I did this stuff one by one. Let's, let's
let's spend some time on all these commands
one by one. And let's see in Jupyter Notebook,
what is happening, let's go to Jupyter Notebook
and actually read that file and do whatever
we are doing here. So first of all, import
NumPy that is already imported. Import.
For example, pandas that is also already imported,
then from SK learn dot impute import simple
impurity. So let's let's use that or let's
Okay, let's do that. From SK learn dot impute
SK learn dot impute import simple in pewter,
okay, import that because that's a new thing,
we need to import that now read the data,
for example, data frame in df. So df equals
PD dot read CSV. There is a CSV file read
CSV. And it contains the path of the file.
The path is located in my directory, it is
located at this particular location COVID.
And the name of that is COVID, underscore
19 ESCO data. So COVID underscore 19 underscore
data dot c s v. So let's read that file, the
file will be read, if you just see that some
of there is a function, let's say head that
gives the top records or the records that
appear just the very top that's that's what
the data file that I was showing you in Excel,
it is showing just the first five records,
I can show the first 10 Records, for example,
just by calling the head function in this
particular way. Okay, great. Let's say I just
want to remove this real number because I
think that is not required. And let's say
I want to remove this particular column. Because
that is also not required. There are multiple
ways of doing that. I can call an t l function
on this. And I can call the L function on
that. But there is another way of doing that
by df dot drop df dot drop and in that you
just give the columns that you want to drop
one column is serial number, I guess, what's
the column name? That's s and No. So you want
to you want to drop that column and then you
want to drop this particular column with herring
last update. So that is last update. So that
is I guess what is there
Xs one in place Drew. So Xs one is justments.
Mentioning, do do that stuff with columns
in place, equals true. That actually is, is
telling that whatever this operation you are
going to do reflect the changes in this df
frame. If we do not write in place to it,
we'll do everything and return onto a temporary
variable or underscore variable or whatever
we are saying, but the DF the data frame will
stay unchanged. So in place true means do
that changing in df variable itself. So now
if we see df dot had flat say, it will no
longer be showing us the serial number column
and the last updated column. What next we
can do we may we may want to rename this,
this name to just date. For example, this
to maybe another, let's rename all these columns,
using using the Rename function, df dot rename
columns equals two and then we have that dictionary
again in place equals two. So let's use let's
use this read in function, TF dot rename.
Let's do that. And here we have columns, columns,
if I spell right columns, and then that is
dictionary what columns you want to change,
I want to change observation date, I want
to change that to simply date, let's say and
I also want to change province slash state
to simply simply state, our province province
that say simply that and I also want to change
this country slash region to simply country.
So, maybe I want to change this country slash
region to simply due to country cru and try
country and I want all that should be happen
in place. So in place equals true. So after
that, if you run that, on this particular
step, and now if you see the state of df,
you will get like
so. Okay, these many, so they province country,
confirm debts, and so on. So this is much
nicer form than earlier. Moreover, we may
have a lot of missing values, oh, one way,
this date format, the date format is not in
a format that pandas internal date format.
So let's convert the date format into into
into the internal pandas date format, using
to to PD to date time function. So let's say
df date equals to PD to date time, and convert
this df date in that particular format. And
now if you run this TF dot had to might be
seeing the date format in a different way.
See that that's the that's that's the date
format that the pandas is expecting. Now,
we that that is just showing showing some
records if you want to see more records, we
can see those let's say I want to just I want
to just count or let's say let's just describe
all the data at TF dot describe there is a
describe function that describe all most of
the statistics of the data, I mean, the total
count of confirmed cases are these the deaths
are these recovered are these these many columns
are there these many values are there. The
mean is that and standard deviation is the
minimum 25. And these are the statistics.
Let's say there is another function info df
dot d A dog info. If you call that function
info, it will give us the more information
about the null increase and the nominal increase
and so on. For example, if you see the total
number of data columns are six, the total
number of records are 6162. The date increase
is always available. The province entries
are only 3700 available, the rest increase
our null increase, so province increase most
of the increase or null increase and they
are there, maybe we want to drop those or
maybe we want to impute those increase and
stuff like so, but they are not increased
that are available in the province column,
some of the province, some of the province
values are no longer available. Let's see
that here. For example, this is not available,
this is not available, this is not available.
And that's what the real state of the data
is this is not available, this is not available
and so on. So this can happen. Okay, next,
what we do is, we actually be actually use
the simple computer just to impute the missing
values. One ways to do that using simple mburo
from SK learn. Another way is, as we already
know, just df dot fill na fill na with, let's
say a bit let's say not available with let's
say a string, some string not available, that's
it that string and with that, if you fill
that fill any using that now, after that,
we will be having all that data, the missing
values will be filled according to Let's see
some missing values because in the province
there were some missing values. Now you can
see for example, let me go on and left Yeah,
so not available not available, we can we
can use that or we can use a fancy kind of
thing that is available by a psychic learn
and so on. Okay, after that, if you now see
the information info, now, you will not be
seeing any null value, all the columns are
there, oh, this was not in place. So don't
fill na that is let's change the DF with it.
So this doesn't happen in place, df just changed
the DF. Okay, df changes. Now, if we now call
the info, there is no null value anymore.
Yeah.
So I am this video here. In the next video,
I will show you this group by command to just
see these kind of stuff in a more detailed
way. Because this this particular video is
getting lamp here lanthier. me I'm stopping
here in this particular location. Next time,
I will show you the group by command in the
in the panda's data frame. And I will show
you what that does. So, we will explore all
that code that is written here. And we will
have in the in the upcoming videos when we
will see the plotting and matplotlib we will
be using the same data file to work more.
And to get more insight how the how this pandas
and matplotlib and NumPy in combination how
they can actually how they can actually play
a very important role in analyzing a very,
very large real data files. Okay, so I end
this video here. I will start the next video
right from this command. And I will tell you
what is happening what is the scope baikman
so hope to see you in the next video. Okay,
in the last video, we were discussing this
COVID-19 file, and we reached here but we
didn't use this SK learn in pewter, we just
use the fill na function of data frame. Now
let's discuss this group by command or a Curie
in in pandas that is much more visible. Let's
say our goal is now for example, if you go
to go back to Jupiter, if you see your dear
df dot head, or all, at the D f dot head,
let's attend records. If you want to see that
there are so many records, let's just see
10. Let's see, what you want to do is you
want to just see how many, how many total
confirmed cases are there in each country,
regardless of their date. And, for example,
you want to just see all the all the all the
confirmed cases, all the deaths, and all the
recovered cases in each country for all the
dates and for all the provinces combined together.
One way to do that is to write a group by
command for example. That's a df two equals
df dot group by and in group by what you see
is for what kind of columns you want to you
want to group all these all this data. So
for example, you want to group by country.
country. So that's your grouping. Now after
gopeng What do you want to see what kind of
what kind of what kind of, for example the
values you want to see because now you're
dropping? Well after grouping I really Want
to see because data is gone once I drop, all
the dates, they are grouped together all the
prevents that are grouped together. So, what
I really want to see is just the country and
I want to see the confirmed cases. So, pick
all these records confirmed, and then I want
to see deaths and recovered. So, for example,
if I want to deaths, and let's say then I
want to see the recovered cases are E and
just I want a big group all the countries
together group all these things together and
add all the records under each country. So
sum all of them, and maybe we want to reset
any index if it is there. So for example,
preset, we set index. So that So, after this
Curie For example, this group by query, what
will happen is this df two will contain a
summary of the data with respect to each country
and the total for example, in this particular
country, the total confirmed cases are these
all confirmed cases till now, and the deaths
of these and recovered as these for this country
for each country, now, each country is describing
Australia for example, in our till, till now,
Australia has total these confirmed cases,
these total deaths, and these are recovered
cases and so on. So, that is if we want to
group all these with respect to country, what
if we want to group all these with respect
to country and then date for example. So,
first we want to group them by country, so
country and then for each country, display
all the dates, and then do the same stuff,
the the Curie will stay almost the same. A
group by command will say almost the same
with one kind of
with one kind of let's say we want to first
group by country, once the, it is grouped
by the country, then I want to group them
by date. And now I want to see all the results
in the form of I want to see the data as well.
And what will happen now is for each country,
its trend with respect to all the dates that
will be displayed here. So let's see df two
now, df two. So if you see df two now, you
can see, for example, this particular country,
it has just one record in this country, it
has one record, then this country for this
date has this record for the same country
and other date has same record and all the
data is also sorted. I mean, now you can see
all the records in a very incremental way.
So that may give you a very good look and
feel of what is happening or, for example.
Another thing What if you want to what if
you want to, for example, find out all the
records, all the records, you just want to
find out all the records? Let's do three,
four, which the the confirmed cases, for example,
the confirmed cases are are more than 100.
Let's find out all the records. Let's, let's
let's let's get just let's just pick all the
records for which the confirmed cases are
larger than 100. And let's copy all these
records just those records in this. So if
we do that, we have d3 available, and we have
d3. This, I mean, these are just the records
in which the confirmed cases are for sure
larger than 100. Just those. Yeah, so we can
do. I mean a lot of a lot of data analysis,
the real data analysis, a lot of a lot more,
I've just shown you a very small snapshot
of what we can do with pandas on the real
data set. I mean, there is a lot more that
we can do with this pandas library, on real
data sets on multiple data files, combining
them together, joining them together, seeing
their correlation, a lot of stuff. And this
pandas really is a very, very fancy and very
high level library, very high level package
to work with data. So due to time limitations,
I'm just ending this pandas here although
there is much more to explain in that, but
in the next video we will be jumping towards
matplotlib just we will see some some functions
of matplotlib. And we will see very briefly
how can we plot How can we analyze data using
visual graphs or stuff like so. So, that that
sometimes this visualization of different
attributes of the data give very good insight
to the data wherever possible, wherever possible.
If the visualization is possible if the data
dimensionality in a way are the visualization
techniques are in a way that you can visualize
the trends in the data, that gives you much
more much better insight than the numbers
or statistical results, but it completely
depends in what situation you can visualize
the data there are situations, high dimensional
data, for example, is not always visualizable.
So, in those cases, the statistical results
of the numbers may play a more important role.
But in more in many cases, visualization give
a very good initial insight into the data
and the design process can become very, very
fast if you know something about the data,
whether you get that information by visualization
or by other statistics or whatever. So, in
the next video, I will be just explaining
some very few functions of matplotlib. And
then we will be, then we will be exploring
the same file, and we will be doing some stuff.
Doing some stuff using the plots and matplotlib.
And doing, seeing the trends of death rates,
seeing the trends of I mean, we'll be playing
with this file a bit more using matplotlib
as well. So hope to see you in the next video.
Okay, in this video, I'm going to discuss
matplotlib a very powerful package for plotting
graphs and scatter plots, line plots and 3d
plots and plots on the globe and whatnot,
I mean, very, very powerful tool. The most
important module in this matplotlib, or the
most popular module, or the most used module
is biplot. So we can import matplotlib.pi
plot as PLT. Another way of writing the same
kind of stuff is we can we can write like
from Matt matplotlib
from matplotlib import by plot as PLT. So
either way is fine whether we write this as
a documentation or that one that is fine as
MP is for NumPy. So let's create some points,
just just just make our first plot. Let's,
let's make some points starting from zero,
let's say all the points starting from zero
till 10. And let's create 1000 points in between.
One way to do that is to use built in function
or a method in NumPy, which is linspace or
linearly spaced points starting from zero
ending at 10. And there are 1000 of those
points. Let's say this is our x and this is
our let's say y which is NP dot sine, the
sine function is actually will apply element
by element on this NumPy array. And then this
PLT will plot will actually plot x comma y
all the points in front of you. So let's go
to Jupyter Notebook and actually see this
matplotlib in running form for the very first
time, oh, we have seen this matplotlib. When
we saw NP dot random, we only plotted a histogram.
While this is not the first time we actually
have seen this once, once, once before. So
import mat plot lib.pi plot as PLT. That's
your import command. For example. Now PLT
is available. Let's say x is NP dot Lin. space.
Let's start from zero. Go to 10 and generate
let's say 1000 points. That's it. That's your
x, y might be your MP dot sine x. That's it.
That's your y. And then what you do is you
say okay, PLT dot plot, x comma y point by
point, and then you press Shift, enter. That's
it. Oh, this plot is there in front of you.
That simple. I mean, that simple. Can you
imagine? This? Is that simple? Yeah, this
is that simple. So I'm in plotting. This is
a line plot. For example, if we want a scatterplot,
we can say okay, PLT dot scatter, there is
a scatter function that allows us to plot
all these endpoints form rather than rather
than this line form. These are all these a
lot of points. That's why you you're not seeing
these scatters. So let me let me let me take
this n x s viewer. Let's see. Let's take x
as let's just take a few points, let's say
just just just 30 points. Let's see the corresponding
30 points, see, they remember the indexing
of NumPy arrays and just using that. So now
use the scatter plots, and you have this,
oh, that's a scatter. Maybe we want to use,
let's say, start from the very beginning,
due to end and big every, let's say, attempt
point. And do the same with why, just to just
to see a plot in a better way, just sample
some points. So that's the scatterplot. It
is just like I'm in the points and so on.
It is not a it is not a continuous plot, like
the line plot, it's a scatterplot, we're going
to annotate this scatter plot, we can change
these colors to any color we want. For example,
we can we can have a prop property, for example,
color is equal to let's say, red, and everything
will become red. Yeah, so that's right, we
can have I mean, we can label it we can x
label it, we can via label, there are a lot
of properties. But but the but the main point
is plotting is that simple plotting is that
quick, using matplotlib. So yeah, this matplotlib
is really, really powerful, we have just seen
a snapshot, just a plot function and a scatter
function there, there are a lot of properties
to be said, there are a lot of things to be
considered. And we will see we will see actually
one one lanthier good use on this COVID-19
file. And we will we will actually analyze
the data trends and the confirmed trends and
some trends that and we will plot them and
see the trends really using matplotlib. So
But before that, let me let me show you that.
If you call for if you call this plot multiple
times, for example, maybe with different colors,
then you will be having a lot of curves on
the same on the same plot, for example. So
for example, let's see PLT dot plot x comma
y, let's say with with color, let's say color
equals to blue.
You can write blue, the whole or you can like
write just be that's fine PLT dot plot, x,
and let's say NP dot cause x and the color
you are interested in, and let's say the color
is, let's say green. And that's perfectly
okay. And that will give you two plots in
the same figure, sort of, and you can just
good to go. Well, yeah, so that more you can,
for example, you can plot with a green, green
color, and you want the solid line, or you
want, for example, Seon color in a dashed
line, or you want a dash and dot black line
or, or maybe you want to completely dotted
line in red color. So there are several things
that are available in matplotlib. This is
just a very few very simple snapshot. And
I have given you a very quick start in and
actually actually the whole point is using
Matlab is that quick, I mean, you can you
have your data, you just plug in their data,
you just call the plot function, and you're
good to go for analysis. Okay. In the next
video, we are where we will actually walk
through the we will actually walk through
the COVID-19 data set. And we'll actually
analyze the trends and to add the death rate
transfer each country individually, and then
we will see the depth confirmed and the recovery
trend of the overall world till the 16th of
March till the day till the data data is available.
So next video will be actually the viewer
will see the running form of pandas and matplotlib.
Together, so hope to see you in the next video.
Okay, I already have shown you the COVID-19
file. And here I have a notebook on that that
uses matplotlib and pandas to find out the
depths conformations and recovery trends using
using different plots. So let me import all
the packages that I need. I need a plot by
plot function from matplotlib. I need pandas
somewhere I need NumPy. And I'm using a simple
mburo here for missing values. So let's run
this. Let's run this command. And yes, everything
is imported. Now let's load the data that
I've shown you earlier. The data is available
now. And let's run this thing that is the
first 50 Records. Yeah, remember that? Yeah,
so that's the data that is available if if
you just want another view another view of
the data That's the data file, which is COVID-19
file. And it has observation day province
country, last update, confirm, to date, death
to date and recover to date for each country
and for each province individually. Okay,
great. So that's what we have. Now what we
can do is, now let's drop the serial numbers
and last update using in place that and rename
the columns that we did already in a previous
video as well. Let's convert the date into
the pandas built in date, frame. Okay, let's
use the psychic learn in pewter, sk learn
in pewter, using the constant strategy, there
are a lot of strategies there, let's use a
constant strategy. And this period or data
frame, in pure dot fit transform that will
help imputing all the missing values with
a constant strategy impure. So that's there.
Okay, next, let's apply this group by command
and group all of all the records using country
for each country. And for all the dates, let's
sum all the records that sum all the values
of records deaths and confirms using this,
but now let's first country and then all it
state, then the second country, then all it
states and so on. We have seen that in one
of our previous videos just running that again,
just for a double check. So that's what the
data state is. So country one all it states
country to all it states. So this country
has a lot of dates, then another country and
so on. Next, let's see how many countries
are there. In total, how many unique countries
are there. So what I, what I do is I find
the column, I actually pick the column with
country and call a unique function on that.
And that gives me all the countries without
repetition. And I just compute the length
length of countries tell me how many unique
countries are there in this data file?
There are 171 countries. So now my goal is
for each country, I want to see what is the
trend of with respect to the date as the data
is moving from the first day till 16th of
March? What is the trend of death? patients?
What is the trend of recovered patients and
what is a trend of confirmed patients as the
data moves on. So because we have 171 countries,
so let's loop over each country again, again,
and again, let's loop over what we do is for
ID x in the range of this, that's the loop
you remember that. And what I do is let's
find out the indices where the country is
like this, let's find out the index all the
indices where the country is like that. Then
what do you do I make a scatterplot. That,
with starting from this, and that, I just
pick the confirmed cases and all the confirmed
cases for this one country, I just pick those.
And I look, I do that using this scatterplot,
then I use another scatter plot, just to get
all the recovered cases, then I do another
scatter plot to get all the depth cases. And
then the title of the title of my figure becomes
the country name, the x labels the days, days
since the first suspect, the wire label is
the total number of cases, the legend command
actually will be there that will show what
eat that is in. So these kinds of labels that
are rewriting here, they will appear in the
figure, then we force them to show that in
each iteration show the show the fourth. So
this will show the trends of confirms to cover
some deaths for all 171 countries one by one.
So if we run this command, we'll be having
171 plots in front of us. Let's see all of
those one by one. So yeah, so this is for
the country. It has just one such thing. This
is for that this is for Afghanistan. As these
moves on the confirmed cases that are even
blue, they are moving up. These are the number
of cases. These are the number of days since
the first day. And the green is the number
of recovered cases for Albania. That's the
trend for Algeria. That's the trend. I mean,
these are each and everything is a separate
that is for Argentina. That is for America.
This is for America till 16th March, by the
way, today. The new says that America is really
in as dangerous position anyways, that's for
Australia till till the date we have to do
that is for Austria. Yeah, so these are all
the trends for all the countries. You see
I'm in the matplotlib how powerful that is.
Although I walked through this code very quickly,
but you can see this video again and again.
And then check how that happens. Yeah. So
that's what this is for Finland. Oh, Finland
is also in trouble. So France. Okay. So that
is for Germany. And yeah, so all the countries
that are available in data set, they have
these kind of plots. This is for Hong Kong.
And this is for India. And this is for Italy's
or Italy's. Yeah. So that's it. So that is
for each country individually, what if we
want the overall trend, or the overall confirm
and the deaths and the recover trend for all
the world together, so what I do is I big
I grew up all the data with date. So I pick
the first date, and add all the records, then
the second date for all the records for all
the countries and so on. And then I plot the
trend using the scatterplot, again, confirmed
record. And that's for all over the world
and see the trend, where the world is moving.
So that's the trend of the world. As the days
are going on, these are the depth grand, that's
a recovery trend. And that's a confirmation
trend that is moving on. Although I walked
through or this notebook, the notebook will
be available to you. I walk over this notebook
very quickly. But the goal was really to show
you the the I mean, that was a file may not
be that informative, if you see that in Excel,
but now it makes much more sense. When you
see these blobs you know what is happening
and you have insight in the data. And later
on, we may we may want to predict we may want
to make predictions. And the next date what
is going to happen, we may want to predict
using this plot or using some Machine Learning
Library like psychic learn or TensorFlow or
something like that. Okay, so that's it. I
can talk much more about pandas NumPy matplotlib
of there are so many other data science packages,
very important packages, one of those is SK
learn, we can that is for machine learning
basic machine learning. Then there are other
packages like TensorFlow for deep learning
by torch for deep learning. There are a lot
of packages with a lot of speciality is in
data science and stuff. I just discussed a
few of those the most important of those do
to manipulate the data to make predictions
to make classification or regressions. For
one, one way is to go to SK learn or psychic
learn. And if the data is huge, and you have
a lot of large amount of data, and you have
good expertise or deep learning, then you
should go to either TensorFlow or pytorch
these are the Python packages that are available
for predictions, classification, regression
and a lot more, but either way, whether you
are going to use scikit learn whether you're
going to use TensorFlow or pytorch either
way, you have to use pandas NumPy and sometimes
matplotlib to pre process the data and to
make the data ready for for these kind of
libraries to to perform predictions, either
a either in the form of classification or
in the form of regression. So so so this whole
course was about for for beginners who want
to who want to learn Python, specifically,
I discussed a lot about the in a lot about
Python in general, then then then I spend
some time not a lot amount of time sometimes
on exploring the data science packages as
well. But, I mean, there is no end we can
explore more, we can talk about the packages
more we can talk about other features of Python
more, a lot of I mean, input formatting, output
formatting, modules, packages, standard template
library, file handling Internet Access database,
I mean,
this is a whole universe, I have discussed
a few things for beginners. But But these
few things were very carefully selected for
data scientists. The if you have this course
available to you as you have gone through
all the course, you now have a very very good
understanding and now you can you can move
towards further edit advanced courses towards
data science and you will be ready to implement
the concepts in Python using using the packages
I have discussed so far. So I thank you all
and good luck.