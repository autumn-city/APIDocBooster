So it only receives one character as the input, then for the one layer of the hidden, the initial hidden and cell state, and it only outputs one output here, and then the hidden and cell set for the next state. So why that is more useful is in a way for computing the loss  essentially that you can get one thing at a time, essentially  instead of running the whole thing.
LSTMCell: in for loop (seq_len=5 times), each output of ith instance will be input of (i+1)th instance. There is only one cell, Truly Recurrent.
Specify the options state_is_tuple=False will concat the two state variables into one, therefore double the size of what you have specified in the init_state declaration. To avoid this, one can use the built-in zero_state method for an LSTMCell to initialize the state in the correct way without worrying about size differences.
The first argument to super() should be class itself, not a different class.
The input gets passed one after the other, for each particular LSTM cell.