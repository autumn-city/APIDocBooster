The [Java (hyper-link)] Math library function Math.random() generates a double value in the range [0,1).
Notice this range does not include the 1.
In order to get a specific range of values first, you need to multiply by the magnitude of the range of values you want covered.
This returns a value in the range [0,Max-Min), where 'Max-Min' is not included.
This would return a value in the range [0,5), where 5 is not included.
Now you need to shift this range up to the range that you are targeting.
You now will get a value in the range [Min,Max).
In order to get the Max value included, you need to add 1 to your range parameter (Max - Min) and then truncate the decimal part by casting to an int.
A random integer value in the range [Min,Max], or per the example [5,10]:
Since i.length will return 25, the nextInt( i.length ) will return a number between the range of 0-24.
Here's a helpful class to generate random ints in a range with any combination of inclusive/exclusive bounds:
This example generates random integers in a specific range.
Use myRandomNumber (which will give you a number within a range).
There are ideally a lot of ways to generate random numbers given a range.
I am thinking to linearly normalize the generated random numbers into desired range by using the following.
Let x be a random number, let a and b be the minimum and maximum range of desired normalized number.
Then below is just a very simple code snipplet to test the range produced by the linear mapping.
Hence we obtain the desired range.
For example if you want to generate five random integers (or a single one) in the range [0, 10], just do:
Here is a simple sample that shows how to generate random number from closed [min, max] range, while min <= max is true
Random number from the range [min..max] inclusive:
This will generate Random numbers list with range (Min - Max) with no duplicate.
I have created a method to get a unique integer in a given range.
6 is the range including number 5.
There is a library at [https://sourceforge.net/projects/stochunit/ (hyper-link)] for handling selection of ranges.
Say you want range between 0-9, 0 is minimum and 9 is maximum.
It's the same for all ranges.
To generate a random int in the range [0, 1_000]:
To generate a random int[100] array of values in the range [0, 1_000]:
You can define your minimum and maximum range to get those results.
here's a function that returns exactly one integer random number in a range defined by lowerBoundIncluded and upperBoundIncluded, as requested by user42155
Range 5-10
The Python 3 range() object doesn't produce numbers immediately; it is a smart [sequence object (hyper-link)] that produces numbers on demand.
The object also implements the [object.__contains__ hook (hyper-link)], and calculates if your number is part of its range.
There is never a need to scan through all possible integers in the range.
From the [range() object documentation (hyper-link)]:
The advantage of the range type over a regular list or tuple is that a range object will always take the same (small) amount of memory, no matter the size of the range it represents (as it only stores the start, stop and step values, calculating individual items and subranges as needed).
So at a minimum, your range() object would do:
This is still missing several things that a real range() supports (such as the .index() or .count() methods, hashing, equality testing, or slicing), but should give you an idea.
I also simplified the __contains__ implementation to only focus on integer tests; if you give a real range() object a non-integer value (including subclasses of int), a slow scan is initiated to see if there is a match, just as if you use a containment test against a list of all the contained values.
To add to Martijn’s answer, this is the relevant part of [the source (hyper-link)] (in C, as the range object is written in native code):
So for PyLong objects (which is int in Python 3), it will use the range_contains_long function to determine the result.
And that function essentially checks if ob is in the specified range (although it looks a bit more complex in C).
In CPython, range(...).__contains__ (a method wrapper) will eventually delegate to a simple calculation which checks if the value can possibly be in the range.
The reason for the speed here is we're using mathematical reasoning about the bounds, rather than a direct iteration of the range object.
For example, 994 is in range(4, 1000, 2) because:
As a final note - look at the range_contains function at the bottom of the code snippet.
If the exact type check fails then we don't use the clever algorithm described, instead falling back to a dumb iteration search of the range using _PySequence_IterSearch!
The fundamental misunderstanding here is in thinking that range is a generator.
What range actually is, is a sequence, just like a list.
The difference between a range and a list is that a range is a lazy or dynamic sequence; it doesn't remember all of its values, it just remembers its start, stop, and step, and creates the values on demand on __getitem__.
(As a side note, if you print(iter(a)), you'll notice that range uses the same listiterator type as list.
A listiterator doesn't use anything special about list except for the fact that it provides a C implementation of __getitem__, so it works fine for range too.)
And it's easier to implement range.__contains__ to just check it mathematically ((val - start) % step, but with some extra complexity to deal with negative steps) than to actually generate and test all the values, so why shouldn't it do it the better way?
If range actually were a generator, like my_crappy_range, then it wouldn't make sense to test __contains__ this way, or at least the way it makes sense wouldn't be obvious.
The other answers explained it well already, but I'd like to offer another experiment illustrating the nature of range objects:
As you can see, a range object is an object that remembers its range and can be used many times (even while iterating over it), not just a one-time generator.
If you're wondering why this optimization was added to range.__contains__, and why it wasn't added to xrange.__contains__ in 2.7:
First, as Ashwini Chaudhary discovered, [issue 1766304 (hyper-link)] was opened explicitly to optimize [x]range.__contains__.
A patch for this was [accepted and checked in for 3.2 (hyper-link)], but not backported to 2.7 because "xrange has behaved like this for such a long time that I don't see what it buys us to commit the patch this late."
Originally, xrange was a not-quite-sequence object.
Range objects have very little behavior: they only support indexing, iteration, and the len function.
This wasn't quite true; an xrange object actually supported a few other things that come automatically with indexing and len,* including __contains__ (via linear search).
Then, as part of implementing the [Abstract Base Classes (hyper-link)] PEP, it was important to figure out which builtin types should be marked as implementing which ABCs, and xrange/range claimed to implement collections.Sequence, even though it still only handled the same "very little behavior".
The patch for that issue not only added index and count to 3.2's range, it also re-worked the optimized __contains__ (which shares the same math with index, and is directly used by count).
* In fact, you even get iteration for free with indexing alone, but [in 2.3 (hyper-link)] xrange objects got a custom iterator.
** The first version actually reimplemented it, and got the details wrong—e.g., it would give you MyIntSubclass(2) in range(5) == False.
But Daniel Stutzbach's updated version of the patch restored most of the previous code, including the fallback to the generic, slow _PySequence_IterSearch that pre-3.2 range.__contains__ was implicitly using when the optimization doesn't apply.
It's all about a lazy approach to the evaluation and some extra optimization of range.
Values in ranges don't need to be computed until real use, or even further due to extra optimization.
sys.maxsize in range(sys.maxsize) is pretty fast
due to optimization - it's easy to compare given integers just with min and max of range.
Decimal(sys.maxsize) in range(sys.maxsize) is pretty slow.
(in this case, there is no optimization in range, so if python receives unexpected Decimal, python will compare all numbers)
The object returned by range() is actually a range object.
Since range objects know their bounds and stride, this is very easy to implement in O(1).
Due to optimization, it is very easy to compare given integers just with min and max range.
The reason that the range() function is so fast in Python3 is that here we use mathematical reasoning for the bounds, rather than a direct iteration of the range object.
Take an example, 997 is in range(4, 1000, 3) because:
4 <= 997 < 1000, and (997 - 4) % 3 == 0.
Try x-1 in (i for i in range(x)) for large x values, which uses the generator comprehension to avoid invoking the range.__contains__ optimisation.
TLDR;
the range is an arithmetic series so it can very easily calculate whether the object is there.
derived from QKS Smalltalk 1991, AOS® [Agile Object System;Agents Object System]
engine family technology for language, framework and runtimes it preserves
use case compatibility across a wide range of current and historical host OS
models.
you can specify any base you like (hex, decimal, 36), by default chooses a random base for each group of 8, in the range of base 16 to 36
These are all nice but seq is supposedly deprecated and most only work with numeric ranges.
If you want to stay as close as possible to the brace-expression syntax, try out the [range function from bash-tricks' range.bash (hyper-link)].
It tries to support the native bash syntax with as few "gotchas" as possible: not only are variables supported, but the often-undesirable behavior of invalid ranges being supplied as strings (e.g.
Solutions that do use only native Bash functionality, like @ephemient's, will not work on alphabetic ranges, like {a..z}; brace expansion will.
The question was about ranges of numbers, though, so this is a quibble.
Most of them aren't visually similar to the {1..10} brace-expanded range syntax, so programs that use both may be a tiny bit harder to read.
@bobbogo's answer uses some of the familiar syntax, but does something unexpected if the $END variable is not a valid range "bookend" for the other side of the range.
The standard Javascript doesn't have a built-in function to generate ranges.
If augmenting native types is your thing, then assign it to Array.range.
lodash.js [_.range() (hyper-link)] function
take(10, range( {from: 100, step: 5, to: 120} ) )
take(10, range( {from: 100, step: 5} ) )
takeAll( range( {to: 5} ) )
takeAll( range( {to: 500, step: 100} ) )
takeAll( range( {from: 'z', to: 'a'} ) )
Simple range function:
range(0,5,2) will include 6, which shouldn't be.
Did some research on some various Range Functions.
I found a JS range function equivalent to the one in PHP, and works amazingly great [here (hyper-link)].
Though this is not from PHP, but an imitation of range from Python.
range([begin], end = 0) where begin and end are numbers
Tends to be slow on large ranges, but luckily quantum computers are just around the corner.
you can use lodash function _.range(10) [https://lodash.com/docs#range (hyper-link)]
As far as generating a numeric array for a given range, I use this:
You can use [lodash (hyper-link)] or [Undescore.js (hyper-link)] range:
Alternatively, if you only need a consecutive range of integers you can do something like:
In ES6 range can be implemented with [generators (hyper-link)]:
range (Start, End, Step=1, Offset=0);
inclusive - forward   range(5,10)   // [5, 6, 7, 8, 9, 10]
inclusive - backward  range(10,5)   // [10, 9, 8, 7, 6, 5]
step - backward  range(10,2,2)   // [10, 8, 6, 4, 2]
exclusive - forward   range(5,10,0,-1)   // [6, 7, 8, 9]  not 5,10 themselves
offset - expand     range(5,10,0,1)   // [4, 5, 6, 7, 8, 9, 10, 11]
offset - shrink     range(5,10,0,-2)   // [7, 8]
step - expand    range(10,0,2,2)   // [12, 10, 8, 6, 4, 2, 0, -2]
It behaves similarly to Python range:
The for loop pushes numbers into the array, which will contain all the numbers in your range.
I use a simple range function in ES6 syntax :
It works with numbers, just like Python's range:
d3 also has a built-in range function.
See [https://github.com/mbostock/d3/wiki/Arrays#d3_range (hyper-link)]:
Generates an array containing an arithmetic progression, similar to the Python built-in range.
Here's my take, with options to emulate the Python's range() function.
Complete ES6 implementation using range([start, ]stop[, step]) signature:
If you have huge ranges look at Paolo Moretti's generator approach
For a range of single characters, you can slightly modify it:
For letters, he's a simple vanilla JS solution I came up with to generate letter ranges.
OK, in JavaScript we don't have a range() function like PHP, so we need to create the function which is quite easy thing, I write couple of one-line functions for you and separate them for Numbers and Alphabets as below:
... more range, using a generator function.
There's an npm module [bereich (hyper-link)] for that ("bereich" is the German word for "range").
It also supports descending ranges (by simply exchanging min and max), and it also supports steps other than 1.
This is what I use for numbers ranges:
Here is a definition of a range function that behaves exactly like Python's range type except that this one is not lazy.
The arguments to the range constructor must be numbers.
You can easily create range() generator function which can function as an iterator.
If you use [Ramda, they have their own R.range (hyper-link)] as does [Lodash (hyper-link)]
But if you are looking to get a range of numbers in a single line of code.
Writing any recursive function to generate a large range is going to bring you here.
A range with a defined hard int has a ton of answers, but what if you don't know that step and you want a number of steps in-between instead?
I just created this polyfill on the Array via Object.defineProperty to make a range for integers or strings.
Using the new Number.range [proposal (hyper-link)] (stage 1):
You can create your own es6 range version
For function that behaves like python range() function, use this:
Loop over a range of numbers between 0 and your Length in Vue:
To speed things up, you can specify a range of revisions you want to rewrite:
We say 'inclusive' because we want to include both bottom and top in the range of numbers that can be returned.
The random decimal we generate needs to be in the range 0 to (1+top-bottom) so we can round down and get an int in the range 0 to top-bottom
The code in the previous example gave us an integer in the range 0 and top-bottom, so all we need to do now is add bottom to that result to get an integer in the range bottom and top inclusive.
For a random integer with a range, try:
You've asked numbers among specific range.
(In this case you are biased among that range.
So consider your range ==> [78, 247]
number of elements of the range = 247 - 78 + 1 = 170; (since both the boundaries are inclusive.
In method two, generate numbers randomly and check those are in the range that you need.
So I would recommend my first method to generate random numbers within a specific range.
Using following code you can generate array of random numbers, without repeating, in a given range.
this is my take on a random number in a range, as in I wanted to get a random number within a range of base to exponent.
/*
 Write a function called randBetween that accepts two numbers 
 representing a range and returns a random whole number between those two 
 numbers.
/*
 Write a function called randFromTill that accepts two numbers 
 representing a range and returns a random number between min (inclusive) 
 and max (exclusive).
/*
 Write a function called randFromTo that accepts two numbers 
 representing a range and returns a random integer between min (inclusive) 
 and max (inclusive)
*/
Use this function to get random numbers between given range
In such cases, we can use crypto.getRandomValues() to generate secure integers, and reject any generated values that we can't map uniformly into the target range.
So we need to reject 1 of the possible generated values, and only continue when we get one of the 15 lesser values that can be uniformly mapped into our target range.
(This could be modified to use BigInts if you need a larger range.)
Regardless of the chosen range, the fraction of generated values that are rejected will always be less than 0.5, so the expected number of rejections will always be less than 1.0 and usually close to 0.0; you don't need to worry about it looping forever.
Question : Function to Generate Random Whole Numbers in JavaScript within a Range of 5 to 25
(i) First convert it to the range - starting from 0.
(ii) Then convert it to your desired range ( which then will be very
easy to complete).
a) Step First: (Converting it to range - Starting from 0)
so the range will be :
Now if you want both numbers inclusive in range - i.e "both 0 and 20", so equation will be:
5 ) to the range - then automatically we can get range from 0 to 20  => 5 to 25
In such cases, we can use crypto.getRandomValues() to generate secure integers, and reject any generated values that we can't map uniformly into the target range.
So we need to reject 1 of the possible generated values, and only continue when we get one of the 15 lesser values that can be uniformly mapped into our target range.
(This could be modified to use BigInts if you need a larger range.)
Regardless of the chosen range, the fraction of generated values that are rejected will always be less than 0.5, so the expected number of rejections will always be less than 1.0 and usually close to 0.0; you don't need to worry about it looping forever.
Now, lets chose a function which results in r such that it satisfies our equation range as [min,max].
OK. Now, the range of r i.e [0,1] is very similar to Math.random() function result.
The Math.random() function returns a floating-point, pseudo-random
  number in the range [0, 1); that is, from 0 (inclusive) up to but not
  including 1 (exclusive)
min + r * (max-min) = X, where X has range of min <= X < max
[Crypto-strong (hyper-link)] random integer number in range [a,b] (assumption: a < b )
I believe that it is sufficient to say that the two ranges overlap if:
Proof:
Let ConditionA Mean that DateRange A Completely After DateRange B
Let ConditionB Mean that DateRange A is Completely Before DateRange B
Then Overlap exists if Neither A Nor B is true -
(If one range is neither completely after the other,
nor completely before the other,
then they must overlap.)
Thanks to @tomosius, a shorter version reads:
DateRangesOverlap = max(start1, start2) < min(end1, end2)
This is actually a syntactical shortcut for what is a longer implementation, which includes extra checks to verify that the start dates are on or before the endDates.
All the solutions that check a multitude of conditions based on where the ranges are in relation to one another can be greatly simplified by just ensuring that a specific range starts earlier!
You ensure that the first range starts earlier (or at the same time) by swapping the ranges if necessary up front.
Then, you can detect overlap if the other range start is less than or equal to the first range end (if ranges are inclusive, containing both the start and end times) or less than (if ranges are inclusive of start and exclusive of end).
The endpoint of the range 2 doesn't enter into it.
If the ranges are inclusive at the start and exclusive at the end, you just have to replace > with >= in the second if statement (for the first code segment: in the second code segment, you'd use < rather than <=):
You greatly limit the number of checks you have to make because you remove half of the problem space early by ensuring range 1 never starts after range 2.
The situation 'two date ranges intersect' is covered by two cases - the first date range starts within the second, or the second date range starts within the first.
The solution posted here did not work for all overlapping ranges...
In case you're using a date range that has not ended yet (still on going) e.g.
Found it here with nice explaination ->
[http://makandracards.com/makandra/984-test-if-two-date-ranges-overlap-in-ruby-or-rails (hyper-link)]
Below query gives me the ids  for which the supplied date range (start and end dates overlaps with any of the dates (start and end dates) in my table_name
This correction is necessary because an open interval boundary does not belong to the value range of an interval by definition.
If you provide a date range as input and want to find out if it overlaps with the existing date range in database, the following conditions can successfully meet your demand
If @StartDate is ahead of existingStartDate and behind existingEndDate then we can say @StartDate is in the middle of a existing date range, thus we can conclude it will overlap
If @StartDate is behind existingStartDate And @EndDate is ahead of existingEndDate we can conclude that the provided date range devours a existing date range , thus overlaps
If any of the condition stands true, your provided date range overlaps with existing ones in the database.
If start and end date of daterange1 falls before start date of daterange2 or start and end date of daterange1 falls after end date of daterange2 this means they don't intersect with each other.
It returns true if both ranges have at least one day in common (assuming DATE values)
In PostgreSQL it's also easy to test for inclusion by using [date ranges (hyper-link)]
the above returns true if the second range is completely included in the first (which is different to "overlaps")
The range() built-in function returns a sequence of integer values, I'm afraid, so you can't use it to do a decimal step.
Python's range() can only do integers, not floating point.
(Replace the call to range with that expression.)
Building on ['xrange([start], stop[, step])' (hyper-link)], you can define a generator that accepts and produces any type you choose (stick to types supporting + and <):
If you really want to use a floating-point step value, you can, with numpy.arange.
Here's a simple case where rounding error causes arange to produce a length-4 array when it should only produce 3 numbers:
My versions use the original range function to create multiplicative indices for the shift.
This allows same syntax to the original range function.
It is consistent with empty set results as in range/xrange.
Passing only a single numeric value to either function will return the standard range output to the integer ceiling value of the input parameter (so if you gave it 5.5, it would return range(6).)
Edit: the code below is now available as package on pypi: [Franges (hyper-link)]
Here is my solution which works fine with float_range(-1, 0, 0.01) and works without floating point representation errors.
I am also quite lazy and so I found it hard to write my own range function.
Basically what I did is changed my xrange(0.0, 1.0, 0.01) to xrange(0, 100, 1) and used the division by 100.0 inside the loop.
So I decided to test if my solution will work for my range by running a short test:
This is my solution to get ranges with float steps.
scipy has a built in function arange which generalizes Python's range() constructor to satisfy your requirement of float handling.
from scipy import arange
frange(start, stop, precision)
The trick to avoid round-off problem is to use a separate number to move through the range, that starts and half the step ahead of start.
Alternatively, numpy.arange can be used.
arange() function allows steps in float.
Or, for a set range instead of set data points (e.g.
[more_itertools (hyper-link)] is a third-party library that implements a [numeric_range (hyper-link)] tool:
The [linspace recipe (hyper-link)] shows how to implement a lazy version of range    that suitable for floating point applications.
then you can call it just like the original range()... there's no error handling, but let me know if there is an error that can be reasonably caught, and I'll update.
If the reult so far is between max%7 and max-1 then the result will be uniformly distrubuted in that range.
The trick is 625 happens to be cleanly divisible by 7 and you can get uniform distributions as you build up to that range.
It assumes rand5() is a function that returns a statistically random integer in the range 1 through 5 inclusive.
rand5() will be assumed to return numbers in the range [0, 4], and rand7() will be assumed to return numbers in the range [0, 6].
Adjusting the ranges to [1, 5] and [1, 7] respectively is trivial.
Now that we have a random real number selected uniformly from the range [0, 1], we need to convert it to a series of uniformly random numbers in the range [0, 6] to generate the output of rand7().
manipulate n rand5 calls to get a number y within range [1, x]
Here are the range of values when R2 is ran thrice:
So you pick an 11 digit number in base 5, and then interpret it as a 9 digit number in base 7 if it's in range (giving 9 base 7 numbers), or as an 8 digit number if it's over the 9 digit number, etc.
(I let the range of rand5 be 0-4 and rand7 is likewise 0-6.)
I don't like ranges starting from 1, so I'll start from 0 :-)
cand is in the range [6, 27] and the possible outcomes are evenly distributed if the possible outcomes from r5() are evenly distributed.
Random5 produces a range from 1~5, randomly distributed
If we run it 3 times and add them together we'll get a range of 3~15, randomly distributed
Perform arithmetic on the 3~15 range

(3~15) - 1 = (2~14)
(2~14)/2 = (1~7)
Then we get a range of 1~7, which is the Random7 we're looking for.
Here's my general implementation, to generate a uniform in the range [0,N-1] given a uniform generator in the range [0,B-1].
Indeed, we can the initial distribution with itself shifted by one, and
repeating by summing the obtained distribution with the initial one shifted by
two, then three and so on, until 7, not included (we covered the whole range).
This means that, given 7 independent random numbers from ran5(), we can
compute a random number with uniform probability in the [0-6] range.
A random integer in the range 1 - 5 is clearly in the range 1 - 7.
Suppose the question was asked as "produce a uniformly distributed pseudo-random number generator with integer output in the range 1 - 7".
On the other hand, if the question is interpreted to mean that you actually have a truly random number generator for integers in the range 1 - 5 (not pseudo random), then the solution is:
This solution doesn't waste any entropy and gives the first available truly random number in range.
The probability of getting an answer in N iterations is the probability that a random number between 0 and max (5^N) will be smaller than the largest multiple of seven in that range (max-max%7).
Given a function which produces a random integer in the range 1 to 5 rand5(), write a function which produces a random integer in the range 1 to 7 rand7()
The simple solution has been well covered: take two random5 samples for one random7 result and do it over if the result is outside the range that generates a uniform distribution.
I tried this replacing the destRange and originRange with various values (even 7 for ORIGIN and 13 for DEST), and I get this distribution:
This method gives an equal probability of getting numbers in the range from 1 to 7, with the exception of 1.
Here's mine, this attempts to recreate Math.random() from multiple rand5() function calls, reconstructing a unit interval (the output range of Math.random()) by re-constructing it with "weighted fractions"(?).
Modifying the function to take any input/output random integer range should be trivial.
This is appended (base 7) to a random value between 0 and 4 inclusive, and the result is divided by 5, giving a new random value in the range of 0 to 6 inclusive.
1-5 is already within the range 1-7, therefore the following is a valid implementation:
Came here from a link from expanding a float range.
Now you can convert this float range (0-4 INCLUSIVE) to any other float range and then downgrade it to be an integer.
After you get your float range either multiply with 7 and throw the decimal part or multiply with 7, subtract 0.5 and round:
For the range [1, 5] to [1, 7], this is equivalent to rolling a 7-sided die with a 5-sided one.
When it comes to a range of commits, cherry-picking is was not practical.
As [mentioned below (hyper-link)] by [Keith Kim (hyper-link)], Git 1.7.2+ introduced the ability to cherry-pick a range of commits (but you still need to be aware of the [consequence of cherry-picking for future merge (hyper-link)])
git cherry-pick" learned to pick a range of commits
(e.g.
If you want to pick the range B through D (including B) that would be B^..D (instead of B..D).
See "[Git create branch from range of previous commits?
Note: as of Git 2.9.x/2.10 (Q3 2016), you can cherry-pick a range of commit directly on an orphan branch (empty head): see "[How to make existing branch an orphan in git (hyper-link)]".
A rebase --onto would be better, where you replay the given range of commit on top of your integration branch, as [Charles Bailey described here (hyper-link)].
after the parent of first_SHA-1_of_working_branch_range (hence the ~1): the first commit you want to replay
Currently, git cherry-pick accepts only a single commit, but if you want to pick the range B through D that would be B^..D in git lingo, so
But anyway, when you need to "replay" a range of commits, the word "replay" should push you to use the "rebase" feature of Git.
Now, if you really do want to cherry-pick a range of commits, for whatever reason, an elegant way to do this is to just pull of a patchset and apply it to your new integration branch:
As of git v1.7.2 cherry pick can accept a range of commits:
git cherry-pick learned to pick a range of commits (e.g.
Another option might be to merge with strategy ours to the commit before the range and then a 'normal' merge with the last commit of that range (or branch when it is the last one).
However, "git merge" will do the merge in one shot but you can not pass a range of revisions as argument.
we have to use "git diff" and "git apply" commands to do the merge range of revs.
Assuming you are on branchA where you want to pick commits (start & end commit SHA for the range is given and left commit SHA is older) from branchB.
The entire range of commits (both inclusive) will be cherry picked in branchA.
If you are using [CoffeeScript (hyper-link)], you can create a range by doing:
Edit: In my opinion, the following is a better range function.
2) get a reversed range:
There is small function, it allow to use construction like
[1, 2].range(3, 4) -> [1, 2, 3, 4] also it works with negative params.
Use the very popular [Underscore _.range method (hyper-link)]
For small ranges a slice is nice.
Or to do a range from a to b
If you are using lodash, you can use [_.range (hyper-link)]:
_.range([start=0], end, [step=1])
function* range(a, b) {
  for (var i = a; i <= b; ++i) yield i;
}
Array.from(range(a, b));
// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
[...range(a, b)]
// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
But '...rangeIter' way is quite handy (can be inlined), fast and more powerful
This solution is probably fastest it is inspired by lodash _.range function (but my is simpler and faster)
In no particular order except how they're arranged on my bookshelf:
the first three lines) of his code,
using the full range of Unicode code points.
See this [post (hyper-link)] to find difference between range and xrange:
range returns exactly what you think: a list of consecutive
  integers, of a defined length beginning with 0. xrange, however,
  returns an "xrange object", which acts a great deal like an iterator
xrange returns an iterator and only keeps one number in memory at a time.
range keeps the entire list of numbers in memory.
range creates a list, so if you do range(1, 10000000) it creates a list in memory with 9999999 elements.
xrange is a sequence object that  evaluates lazily.
range does the equivalent of Python 2's xrange.
To get the list, you have to explicitly use list(range(...)).
xrange no longer exists.
range generates the entire list and returns it.
xrange does not -- it generates the numbers in the list on demand.
xrange uses an iterator (generates values on the fly), range returns a list.
The advantage of the xrange type is that an xrange object will always 
  take the same amount of memory, no matter the size of the range it represents.
range() will create a list of values from start to end (0 .. 20 in your example).
This will become an expensive operation on very large ranges.
xrange() on the other hand is much more optimised.
it will only compute the next value when needed (via an xrange sequence object) and does not create a list of all values like range() does.
range creates a list, so if you do range(1, 10000000) it creates a list in memory with 9999999 elements.
xrange is a generator, so it is a sequence object is a that  evaluates lazily.
This is true, but in Python 3, range() will be implemented by the Python 2 xrange().
xrange only stores the range params and generates the numbers on demand.
Note that in Python 3.0 there is only range and it behaves like the 2.x xrange but without the limitations on minimum and maximum end points.
range creates a list, so if you do range(1, 10000000) it creates a list in memory with 10000000 elements.
xrange is a generator, so it evaluates lazily.
Personally, I always use range(), unless I were dealing with really huge lists -- as you can see, time-wise, for a list of a million entries, the extra overhead is only 0.04 seconds.
And as Corey points out, in Python 3.0 xrange() will go away and range() will give you nice iterator behavior anyway.
When testing range against xrange in a loop (I know I should use [timeit (hyper-link)], but this was swiftly hacked up from memory using a simple list comprehension example) I found the following:
Or, using xrange in the for loop:
Any comments on the slower instance of xrange?
On a requirement for scanning/printing of 0-N items , range and xrange works as follows.
range() - creates a new list in the memory and takes the whole 0 to N items(totally N+1) and prints them.
xrange() - creates a iterator instance that scans through the items and keeps only the current encountered item into the memory , hence utilising same amount of memory all the time.
This function is very similar to range(), but returns an xrange object instead of a list.
The advantage of xrange() over range() is minimal (since xrange() still has to create the values when asked for them) except when a very large range is used on a memory-starved machine or when all of the range’s elements are never used (such as when the loop is usually terminated with break).
range returns a static list at runtime.
xrange returns an object (which acts like a generator, although it's certainly not one) from which values are generated as and when required.
Use xrange if you want to generate a list for a gigantic range, say 1 billion, especially when you have a "memory sensitive system" like a cell phone.
Use range if you want to iterate over the list several times.
PS: Python 3.x's range function == Python 2.x's xrange function.
Range returns a list while xrange returns an xrange object which takes the same memory irrespective of the range size,as in this case,only one element is generated and available per iteration whereas in case of using range, all the elements are generated at once and are available in the memory.
Some of the other answers mention that Python 3 eliminated 2.x's range and renamed 2.x's xrange to range.
Range objects have very little behavior: they only support indexing, iteration, and the len function.
However, in 3.2+, range is a full sequence—it supports extended slices, and all of the methods of [collections.abc.Sequence (hyper-link)] with the same semantics as a list.
* The fact that issubclass(xrange, collections.Sequence) returns True in 2.6-2.7 and 3.0-3.1 is [a bug (hyper-link)] that was fixed in 3.2 and not backported.
The difference decreases for smaller arguments to range(..) / xrange(..):
In this case xrange(100) is only about 20% more efficient.
range(): range(1, 10) returns a list from 1 to 10 numbers & hold whole list in memory.
xrange(): Like range(), but instead of returning a list, returns an object that generates the numbers in the range on demand.
For looping, this is lightly faster than range() and more memory efficient.
xrange() object like an iterator and generates the numbers on demand.
xrange() and range() in python works similarly as for the user , but the difference comes when we are talking about how the memory is allocated in using both the function.
When we are using range() we allocate memory for all the variables it is generating, so it is not recommended to use with larger no.
xrange() on the other hand generate only a particular value at a time and can only be used with the for loop to print all the values required.
range(x) returns a list, that is created in memory with x elements.
xrange(x) returns an xrange object which is a generator obj which generates the numbers on demand.
For looping, this is slightly faster than range() and more memory efficient.
range(x,y) returns a list of each number in between x and y if you use a for loop, then range is slower.
In fact, range has a bigger Index range.
range(x.y) will print out a list of all the numbers in between x and y
xrange(x,y) returns xrange(x,y) but if you used a for loop, then xrange is faster.
xrange has a smaller Index range.
xrange will not only print out xrange(x,y) but it will still keep all the numbers that are in it.
You will find the advantage of xrange over range in this simple example:
The above example doesn't reflect anything substantially better in case of xrange.
Now look at the following case where range is really really slow, compared to xrange.
With range, it already creates a list from 0 to 100000000(time consuming), but xrange is a generator and it only generates numbers based on the need, that is, if the iteration continues.
In Python-3, the implementation of the range functionality is same as that of xrange in Python-2, while they have done away with xrange in Python-3
range :-range will populate everything at once.which means every number of the range will occupy the memory.
xrange :-xrange is something like generator ,it will comes into picture when you want the range of numbers but you dont want them to be stored,like when you want to use in for loop.so memory efficient.
If you are using Python 2X, then replace 'range()' with 'xrange()' in the first code and 'list(range())' with 'range()'.
In Python 2.x, range returns a list, xrange returns an xrange object which is iterable.
In Python 3.x, range becomes xrange of Python 2.x, and xrange is removed.
Additionally, if do list(xrange(...)) will be equivalent to range(...).
Also xrange really doesn't fully finish the sequence
So that's why its not a list, it's a xrange object
[range() (hyper-link)] in Python 2.x
This function is essentially the old range() function that was available in Python 2.x and returns an instance of a list object that contains the elements in the specified range.
However, this implementation is too inefficient when it comes to initialise a list with a range of numbers.
For example, for i in range(1000000) would be a very expensive command to execute, both in terms of memory and time usage as it requires the storage of this list into the memory.
[range() (hyper-link)] in Python 3.x and [xrange() (hyper-link)] in Python 2.x
Python 3.x introduced a newer implementation of range() (while the newer implementation was already available in Python 2.x through the xrange() function).
The range() exploits a strategy known as lazy evaluation.
Instead of creating a huge list of elements in range, the newer implementation introduces the class range, a lightweight object that represents the required elements in the given range, without storing them explicitly in memory (this might sound like generators but the concept of lazy evaluation is different).
Or if you want to protect for the case where the old range is 0 (OldMin = OldMax):
Note that in this case we're forced to pick one of the possible new range values arbitrarily.
Such as wrongly input value, wrongly input range, negative input/output ranges.
In the listing provided by PenguinTD, I do not understand why the ranges are reversed, it works without having to reverse the ranges.
Linear range conversion is based upon the linear equation Y=Xm+n, where m and n are derived from the given ranges.
Rather than refer to the ranges as min and max, it would be better to refer to them as 1 and 2.
Depending on the application it may not be necessary to check the ranges x1=x2 and y1==y2.
This example converts a songs current position into an angle range of 20 - 40.
Here is a Javascript version that returns a function that does the rescaling for predetermined source and destination ranges, minimizing the amount of computation that has to be done each time.
Consider we have a scale between (OMin, Omax) and we we have a value X in this range
And to do it with range
Here is a simple letter-range implementation:
Print the Upper and Lower case alphabets in python using a built-in range function
Here is how I implemented my custom function for letters range generation based on string.ascii_letters:
We have to construct cycles of length four and are able to cover the whole integer range up to four values.
I could imagine using the 31st bit as an imaginary (i) bit would be an approach that would support half the total range.
Obviously, this approach could be extended to work for an even wider range of numbers...
This will work in a very broad range of numbers:
But, once again, it works for a very wide range of numbers.
C# for a range of 2^32 - 1 numbers, all int32 numbers except (Int32.MinValue)
Essentially the function has to divide the available range into cycles of size 4, with -n at the opposite end of n's cycle.
Because of 0 being alone, there must be 3 other values in our range (whose size is a multiple of 4) not in a proper cycle with 4 elements.
So you have to somehow create your own imaginary axis, using part of your data range.
Since you need exactly as much imaginary (intermediate) values as initial values, you are left with only half the data range.
The allowed range for initial n is -64 to +63.
If n is in 0..63 (initial range), the function call adds 64, mapping n to the range 64..127 (intermediate range)
If n is in 64..127 (intermediate range), the function subtracts n from 64, mapping n to the range 0..-63
For negative n, the function uses the intermediate range -65..-128.
Then, I would write the C# test case code I would use (the obvious: loop from int.MinValue to int.MaxValue, and for each n in that range call f(f(n)) and checking the result is -n), telling I would then use Test Driven Development to get to such a function.
I thought the largest range possible was hinting at a modular arithmetic solution.
If the function f is only permitted to land only on signed 32bit integers, then the various solutions above will all work except for three of the input range numbers as others have pointed out.
This will work for the range -1073741823 to 1073741822:
It works by taking the available range of a 32 bit signed int and dividing it in two.
The first iteration of the function places n outside of that range by itself.
The second iteration checks if it is outside this range - if so then it puts it back within the range but makes it negative.
This satisfies f(f(x)) = -x for all integers in the range [-231-2, 231-2].
The results of f(x) are also in this range, but of course the computation would need 64-bit integers.
Then about the range.
The 32-bit integers range from -2^31 upto 2^31-1.
The numbers 2^31-1, -2^31-1 and -2^31 fall outside of the range of f(x) because the number 2^31 is missing.
Add 1/4 of a range;
It works for the whole range, except -2^31.
This set of cycles maximizes the ranges of inputs that will work within any machine type centered around zero, such as signed int32 or signed int64 types.
Analysis of compatible ranges
So the problem for general k is solvable if and only if the range of the input - 1 (to compensate for 0) is a multiple of 2 * k, and the positive and negative ranges are opposites.
For signed integer representations, we always have a smallest negative number with no positive counterpart in the range, so the problem becomes unsolveable on the complete range.
For example, a signed char has range [-128, 127], so it's impossible for f(f(-128)) = 128 within the given range.
If you highlight some text before typing :s, you'll see that the highlighted lines take the place of % as your substitution range.)
Looking at your question its clear that you just want to send the date range to your backend for further post processing.
The key observation is that range-based for-loops work by relying on begin() and end() in order to acquire the range's iterators.
If you can use [range v3 (hyper-link)] , you can use the reverse range adapter ranges::view::reverse which allows you to view the container in reverse.
This can be used with the <experimental/ranges/range> header.
A bit of a late answer I know, but I just had the same problem and decided that Python's internal range function was a bit lacking in this respect so I've overridden it in a util module of mine.
[Pandas (hyper-link)] is great for time series in general, and has direct support for date ranges.
For example [pd.date_range() (hyper-link)]:
For example if you only wanted weekdays, you would just swap in [bdate_range (hyper-link)].
See [date range documentation (hyper-link)]
Get range of dates between specified start and end date (Optimized for time & space complexity):
From the title of this question I was expecting to find something like range(), that would let me specify two dates and create a list with all the dates in between.
If there are two dates and you need the range try
A monthly date range generator with datetime and dateutil.
I thought I'd throw in my two cents with a simple (and not complete) implementation of a date range:
If you only want to see the keys/values from your map and like using boost, you can use the boost adaptors with the range based loops:
[http://www.boost.org/doc/libs/1_51_0/libs/range/doc/html/range/reference/adaptors/reference/map_values.html (hyper-link)]
Use the 'range' built-in function.
The signature is range(start, stop, step).
In Python 3, this produces a non-list range object, which functions effectively like a read-only list (but uses way less memory, particularly for large ranges).
If you want to use only range to achieve the same result, you can use all its parameters.
range(start, stop, step)
It may be less intuitive but as the comments mention, this is more efficient and the right usage of range for reversed list.
You could use range(10)[::-1] which is the same thing as range(9, -1, -1) and arguably more readable (if you're familiar with the common sequence[::-1] Python idiom).
If your n case is 0, reversed(range(0)) will not execute which is wrong if you by chance have a single object in the zero index.
Readibility aside, reversed(range(n)) seems to be faster than range(n)[::-1].
When you have iteration over n items and want to replace order of list returned by range(start, stop, step) you have to use third parameter of range which identifies step and set it to -1, other parameters shall be adjusted accordingly:
So equivalent of range(n) in reverse order would be:
You don't necessarily need to use the range function, you can simply do list[::-1] which should return the list in reversed order swiftly, without using any additions.
You can do printing of reverse numbers with range() BIF Like ,
range() - range ( start , end , increment/decrement ) 
where start is inclusive , end is exclusive and increment can be any numbers and behaves like step
The last option is easy to remember using the range(n-1,-1,-1) notation by [Val Neekman (hyper-link)].
I know you asked using range but its already answered.
Very often asked question is whether range(9, -1, -1) better than reversed(range(10)) in Python 3?
But what about range()?
So range(100000) doesn't take up lot of memory but it still supports efficient indexing and reversing.
So in summary, you can use reversed(range(10)) without any hit on performance.
because range(n) produces an iterable there are all sorts of nice things you can do which will produce the result you desire, such as:
range(x) creates a list from [0, 1, 2, ... x-1]
List comprehension (Using the squares because for range you don't need to do all this, you can just return range(0,9) ):
The next problem you will note is that your list will actually have only 9 elements, because the end point is skipped by the range function.
(As side notes, [] works just as well as list(), the semicolon is unnecessary, s1 is a poor name for the variable, and only one parameter is needed for range if you're starting from 0.)
However, this is still missing the mark; range is not some magical keyword that's part of the language the way for and def are, but instead it's a function.
and now you see why we don't need to write a function ourselves at all; range is already the function we're looking for.
Edit: It's [ [] for _ in range(10)]
But if you are ok with a range (e.g.
[0,1,2,3,...,x-1]), then range(x) might be fastest:
xrange() is more efficient because instead of generating a list of objects, it just generates one object at a time.
Unless I specifically need a list for something, I always favor xrange()
You should favour range() over xrange() only when you need an actual list.
For instance, when you want to modify the list returned by range(), or when you wish to slice it.
For iteration or even just normal indexing, xrange() will work fine (and usually much more efficiently).
There is a point where range() is a bit faster than xrange() for very small lists, but depending on your hardware and various other details, the break-even can be at a result of length 1 or 2; not something to worry about.
Prefer xrange().
Go with range for these reasons:
1) xrange will be going away in newer Python versions.
2) range will take on the efficiencies associated with xrange.
For performance, especially when you're iterating over a large range, xrange() is usually better.
However, there are still a few cases why you might prefer range():
In python 3, range() does what xrange() used to do and xrange() does not exist.
If you want to write code that will run on both Python 2 and Python 3, you can't use xrange().
range() can actually be faster in some cases - eg.
xrange() has to reconstruct the integer object every time, but range() will have real integer objects.
xrange() isn't usable in all cases where a real list is needed.
[Edit] There are a couple of posts mentioning how range() will be upgraded by the 2to3 tool.
For the record, here's the output of running the tool on some sample usages of range() and xrange()
As you can see, when used in a for loop or comprehension, or where already wrapped with list(), range is left unchanged.
range() returns a list, xrange() returns an xrange object.
xrange() is a bit faster, and a bit more memory efficient.
Python 3.0 is still in development, but IIRC range() will very similar to xrange() of 2.X and list(range()) can be used to generate lists.
Okay, everyone here as a different opinion as to the tradeoffs and advantages of xrange versus range.
They're mostly correct, xrange is an iterator, and range fleshes out and creates an actual list.
(You can use map with range but not with xrange, but it uses up more memory.)
What I think you rally want to hear, however, is that the preferred choice is xrange.
Since range in Python 3 is an iterator, the code conversion tool 2to3 will correctly convert all uses of xrange to range, and will throw out an error or warning for uses of range.
If you want to be sure to easily convert your code in the future, you'll use xrange only, and list(xrange) when you're sure that you want a list.
Use xrange() when iterating, as it saves memory.
On the other hand, use range() if you actually want a list of numbers.
I would just like to say that it REALLY isn't that difficult to get an xrange object with slice and indexing functionality.
I have written some code that works pretty dang well and is just as fast as xrange for when it counts (iterations).
Honestly, I think the whole issue is kind of silly and xrange should do all of this anyway...
One other difference is that Python 2 implementation of xrange() can't support numbers bigger than C ints, so if you want to have a range using Python's built in large number support, you have to use range().
I wouldn’t recommend using range instead of xrange in the preceding example—although
only the first five numbers are needed, range calculates all the numbers, and that may take a lot
of time.
With xrange, this isn’t a problem because it calculates only those numbers needed.
Yes I read @Brian's answer: In python 3, range() is a generator anyway and xrange() does not exist.
range(): range(1, 10) returns a list from 1 to 10 numbers & hold whole list in memory.
xrange(): Like range(), but instead of returning a list, returns an object that generates the numbers in the range on demand.
For looping, this is lightly faster than range() and more memory efficient.
xrange() object like an iterator and generates the numbers on demand (Lazy Evaluation).
range() does the same thing as xrange() used to do in Python 3 and there is not term xrange() exist in Python 3.
range() can actually be faster in some scenario if you iterating over the same sequence multiple times.
xrange() has to reconstruct the integer object every time, but range() will have real integer objects.
While xrange is faster than range in most circumstances, the difference in performance is pretty minimal.
The little program below compares iterating over a range and an xrange:
The results below shows that xrange is indeed faster, but not enough to sweat over.
So by all means use xrange, but unless you're on a constrained hardware, don't worry too much about it.
For future readers if you want a random number in a range use the following code:
"Hash and Range Primary Key" means that a single row in DynamoDB has a unique primary key made up of both the hash and the range key.
For example with a hash key of X and range key of Y, your primary key is effectively XY.
You can also have multiple range keys for the same hash key but the combination must be unique, like XZ and XA.
Hash and Range Primary Key – The primary key is made of two
  attributes.
The first attribute is the hash attribute and the second
  attribute is the range attribute.
For example, the forum Thread table
  can have ForumName and Subject as its primary key, where ForumName is
  the hash attribute and Subject is the range attribute.
DynamoDB builds
  an unordered hash index on the hash attribute and a sorted range index
  on the range attribute.
This means that every row's primary key is the combination of the hash and range key.
You can make direct gets on single rows if you have both the hash and range key, or you can make a query against the sorted range index.
For example, get Get me all rows from the table with Hash key X that have range keys greater than Y, or other queries to that affect.
Query results are always sorted by the range key.
If the data type of
  the range key is Number, the results are returned in numeric order;
  otherwise, the results are returned in order of ASCII character code
  values.
Sort key are used only to get range of data
2.1 Get single row by (partition key, sort key) or get range of rows by (partition key)
You can get multiple items (multiple rows) by specifying (HashKey, RangeKeyQuery)
If you decide however that your primary key is hashKey + SortKey then you could also do a range query on your primary key because you will get your items by (HashKey + SomeRangeFunction(on range key)).
A well-explained answer is already given by @mkobit, but I will add a big picture of the range key and hash key.
In a simple words range + hash key = composite primary key [CoreComponents of Dynamodb (hyper-link)]
[ (hyper-link)]
A primary key is consists of a hash key and an optional range key.
Range keys are used to sort the items in the
  partition, if they exist.
In the above example hashkey1 can have multiple n-range.
Another example of range and hashkey is game, userA(hashkey) can play Ngame(range)
To retrieve only a subset
  of songs by a particular artist, you can provide a value for Artist
  along with a range of values for SongTitle.
Maybe the most elegant solution is using a generator function to completely hide/abstract the iteration over the range of dates:
NB: For consistency with the built-in range() function this iteration stops before reaching the end_date.
So for inclusive iteration use the next day, as you would with range().
As long as you factor out your range logic, then you don't need the separate day_count and most importantly the code becomes easier to read as you call the function from multiple places.
What about the following for doing a range incremented by days:
Pandas is great for time series in general, and has direct support for date ranges.
You can then loop over the daterange to print the date:
For example if you only wanted weekdays, you would just swap in bdate_range.
See [http://pandas.pydata.org/pandas-docs/stable/timeseries.html#generating-ranges-of-timestamps (hyper-link)]
Numpy's arange function can be applied to dates:
Here's code for a general date range function, similar to Ber's answer, but more flexible:
Slightly different approach to reversible steps by storing range args in a tuple.
For completeness, Pandas also has a period_range function for timestamps that are out of bounds:
Here's a benchmark to compare a Go for statement with a ForClause and a Go range statement using the iter package.
I wrote [this iter package (hyper-link)] — which is backed by a simple, idiomatic for loop that returns values over a chan int — in an attempt to improve on the design found in [https://github.com/bradfitz/iter (hyper-link)], which has been pointed out to have caching and performance issues, as well as a clever, but strange and unintuitive implementation.
If you want to just iterate over a range w/o using and indices or anything else, this code sample worked just fine for me.
I have written a package in Golang which mimic the Python's range function:
The problem is not the range, the problem is how the end of slice is calculated.
A simple range over int32 would help because this evaluate the bfl.Size() only once.
Range starts inclusive of the first parameter; but ends Up To, Not Including the second Parameter (when supplied 2 parameters; if the first parameter is left off, it'll start at '0')
You can just construct a list from the range object:
Typically speaking, you probably don't need a list though since you can come by the value of my_list[i] more efficiently (i + 1), and if you just need to iterate over it, you can just fall back on range.
Also note that on python2.x, xrange is still indexable1.
This means that range on python3.x also has the same property2
1print xrange(30)[12] works for python2.x
2The analogous statement to 1 in python3.x is print(range(30)[12]) and that works also.
Actually, if you want 1-1000 (inclusive), use the range(...) function with parameters 1 and 1001: range(1, 1001), because the range(start, end) function goes from start to (end-1), inclusive.
in Python 3.x, the range() function got its own type.
list(range(1000))
In Pythons <= 3.4 you can, as others suggested, use list(range(10)) in order to make a list out of a range (In general, any iterable).
Certainly, Python2 which uses range() and xrange() is more convenient than Python3 which uses list(range()) and range() respectively.
The reason is because the original designer of Python3 is not very experienced, they only considered the use of the range function by many beginners to iterate over a large number of elements where it is both memory and CPU inefficient; but they neglected the use of the range function to produce a number list.
use irange to return a sequence iterator
use lrange to return a sequence list
use range to return either a sequence iterator (if the number of elements is large, e.g., range(9999999) or a sequence list (if the number of elements is small, e.g., range(10))
Use [Range (hyper-link)] in Python 3.
The reason why Python3 lacks a function for directly getting a ranged list is because the original Python3 designer was quite novice in Python2.
He only considered the use of range() function in a for loop, thus, the list should never need to be expanded.
In fact, very often we do need to use the range() function to produce a list and pass into a function.
In Python2, we have xrange() and range();
In Python3, we have range() and list(range())
Generate the range of data first and then shuffle it like this
By doing this way, you will get all the numbers in the particular range but in a random order.
But you can use [random.sample (hyper-link)] to get the number of elements you need, from a range of numbers like this
Be careful of having a smaller range than will fit in n. It will loop forever, unable to find new numbers to insert up to n
In case of a rather large range of possible numbers, you could use itertools.islice with an infinite random generator:
Because it's more common to call range(0, 10) which returns [0,1,2,3,4,5,6,7,8,9] which contains 10 elements which equals len(range(0, 10)).
Could you see that if range() went up to exactly len(li) that this would be problematic?
If you are calling range with a start of 1 frequently, you might want to define your own function:
The length of the range is the top value minus the bottom value.
Also like Ruby's range:
Exclusive ranges do have some benefits:
For one thing each item in range(0,n) is a valid index for lists of length n.
Also range(0,n) has a length of n, not n+1 which an inclusive range would.
For example, if you have 10 items in a list x, they are numbered 0-9. range(len(x)) gives you 0-9.
Of course, people will tell you it's more Pythonic to do for item in x or for index, item in enumerate(x) rather than for i in range(len(x)).
If you want 1-10, the first number you don't want is 11, so it's range(1, 11).
If it becomes cumbersome in a particular application, it's easy enough to write a little helper function that adds 1 to the ending index and calls range().
Read up on [the python docs (hyper-link)] for range - they consider for-loop iteration the primary usecase.
It's also useful for splitting ranges; range(a,b) can be split into range(a, x) and range(x, b), whereas with inclusive range you would write either x-1 or x+1.
While you rarely need to split ranges, you do tend to split lists quite often, which is one of the reasons slicing a list l[a:b] includes the a-th element but not the b-th.
Then range having the same property makes it nicely consistent.
With something like 'range(1,10)' confusion can arise from thinking that pair of parameters represents the "start and end".
Others mistakenly call that parameter "count" because if you only ever use 'range(n)' then it does, of course, iterate 'n' times.
Basically in python range(n) iterates n times, which is of exclusive nature that is why it does not give last value when it is being printed, we can create a function which gives 
inclusive value it means it will also print last value mentioned in range.
Basically, we could think of a range as an interval between start and end.
However, we count the integers included in the range instead of measuring the length of the interval.
The range(n) in python returns from 0 to n-1.
Respectively, the range(1,n) from 1 to n-1.
Swift provides distance() which measures the distance between start and end that can be used to create an NSRange:
Swift String ranges and NSString ranges are not "compatible".
Since NS(Mutable)AttributedString ultimately requires an NSString and an NSRange, it is actually
better to convert the given string to NSString first.
Then the substringRange
is an NSRange and you don't have to convert the ranges anymore:
As of Swift 4 (Xcode 9), the Swift standard library
provides method to convert between Range<String.Index> and NSRange.
Here substringRange is a Range<String.Index>, and that is converted to the
corresponding NSRange with
I love the Swift language, but using NSAttributedString with a Swift Range that is not compatible with NSRange has made my head hurt for too long.
Be cautious, as the result of range function has to be unwrapped.
Sure, I know that Swift 4 has an extension for NSRange already
But conversion can be done directly from Range< String.Index > to NSRange without Swift's String instance.
or you can create the specialized extension for Range itself
Due to the migration of Swift strings to UTF-8 encoding by default, the usage of encodedOffset is considered as deprecated and Range cannot be converted to NSRange without an instance of String itself, because in order to calculate the offset we need the source string which is encoded in UTF-8 and it should be converted to UTF-16 before calculating offset.
NSRange(range, in: )
NSRange(location:, length: )
My solution is a string extension that first gets the swift range then get's the distance from the start of the string to the start and end of the substring.
We can then apply these values to the NSMakeRange constructor.
Converting Range into NSRange
As the 'encodedOffset' is deprecated, so now in order to convert String.Index to Int we need the reference of original string from which Range<String.Index> was derived.
A convenient detailed extension for NSRange could be as below:
Now we can use any Range to convert it into NSRange as below, sharing my own requirement which led me to write above extensions
I was using below String extension for finding all the ranges of specific word from the String
As Bernhard Vallant said, if you want a queryset which excludes the specified range ends you should consider [his solution (hyper-link)], which utilizes gt/lt (greater-than/less-than).
When doing django ranges with a filter make sure you know the difference between using a date object vs a datetime object.
__range is inclusive on dates but if you use a datetime object for the end date it will not include the entries for that day if the time is not set.
You can get around the "impedance mismatch" caused by the lack of precision in the DateTimeField/date object comparison -- that can occur if using range -- by using a datetime.timedelta to add a day to last date in the range.
you can use "__range"
for example :
If you need a range of lines, say the range 42–666 (inclusive), and say you don't want to do the math yourself, and print them on stdout:
Do all of them fit within the range of the type?
BUT: on SQL Server, the date range supported is quite different.
The conversion of a datetime2 data type to a datetime data type resulted in an out-of-range value.
But this date is not compatible with entity frame work so it will throw 
conversion of a datetime2 data type to a datetime data type resulted in an out-of-range value
This 'Date' field type has the same range values as a DateTime .Net class.
I had no problem while Creating but Updating Database made my DateCreated property out of range!
When you don't want your DateTime Property be Nullable and do not want to check if its value is in the sql DateTime range (and @Html.HiddenFor doesn't help!
An address range can be specified by specifying two addresses
  separated by a comma (,).
An address range matches lines starting from
  where the first address matches, and continues until the second
  address matches (inclusively).
-n suppresses echoing the input as output, which you clearly don't want; the numbers indicate the range of lines to make the following command operate on; the command p prints out the relevant lines.
Furthermore, if you know two pattern (better be unique in your text), both the beginning and end line of the range can be specified with matches.
(Adding 1 for the q-range in boxxar's solution does not seem to be necessary.)
Specifically, 16224,16482p runs the p (print) command on the desired line address range.
Here's how you get the "16224 -- 16482" range without computing anything:
The solution shown above simply uses head first, to 'keep everything up to the top number', and then tail second, to 'keep everything from the bottom number upwards', thus defining our range of interest (with no need to compute an interval).
You can set the year range using this option per documentation here [http://api.jqueryui.com/datepicker/#option-yearRange (hyper-link)]
The range of years displayed in the year drop-down: either relative to today's year ("-nn:+nn"), relative to the currently selected year ("c-nn:c+nn"), absolute ("nnnn:nnnn"), or combinations of these formats ("nnnn:-nn").
where 50 is the range from current year.
YearRange:- Specifies the range of years in the year dropdown.
See:- [set year range in jquery datepicker (hyper-link)]
I needed a range of 70 years, which, while not as much as 100, is still too many years for the visitor to scroll through.
I wanted to implement the datepicker to select the birthdate and I had troubles changing the yearRange as it doesn't seemed to work with my version (1.5).
You can set the year range using this option in jQuery UI datepicker:
The key is noticing that rangeOfString: returns an NSRange struct, and [the documentation says (hyper-link)] that it returns the struct {NSNotFound, 0} if the "haystack" does not contain the "needle".
An improved version of [P i's solution (hyper-link)], a category on NSString, that not only will tell, if a string is found within another string, but also takes a range by reference, is:
So the better solution that I believe works is to use the fact that rangeOfString returns the length of 0  so then a better more reliable code is this:
Use the option NSCaseInsensitiveSearch with rangeOfString:options:
if _RangeT is a class type, the unqualiﬁed-ids begin and end are
  looked up in the scope of class _RangeT as if by class member access
  lookup (3.4.5), and if either (or both) ﬁnds at least one declaration,
  begin- expr and end-expr are __range.begin() and __range.end(),
  respectively;
— otherwise, begin-expr and end-expr are begin(__range) and
  end(__range), respectively, where begin and end are looked up with
  argument-dependent lookup (3.4.2).
That's the same results for ranged-based for loops, and also the same result for mere mortal code that doesn't have its own magical name resolution rules so just does using std::begin; followed by an unqualified call to begin(a).
If you implement the member functions and the ADL functions, though, then range-based for loops should call the member functions, whereas mere mortals will call the ADL functions.
If it's a range that isn't a container (which would be a good idea if it's immutable or if you don't know the size up front), you're free to choose.
I have my own plain only data array implementation for some reason, and I wanted to use the range based for loop.
The requirements on the begin/end return value are simple: You must overload pre-++, ensure the initialization expressions are valid, binary != that can be used in a boolean context, unary * that returns something you can assign-initialize range_declaration with, and expose a public destructor.
See [stmt.ranged] 1.2-1.3 from n4527.
Note that std::begin is not called unless range_expression returns an object of type in namespace std or dependent on same.
In [c++17 (hyper-link)] the range-for expression has been updated
This allows a C++ range-for expression to generate optimal code when iterating over a null-terminated char* buffer.
Here is a quick and dirty iterable range-view:
Here, I am sharing the simplest example of creating custom type, that will work with "range-based for loop":
That's the same results for
  ranged-based for loops, and also the same result for mere mortal code
  that doesn't have its own magical name resolution rules so just does
  using std::begin; followed by an unqualified call to begin(a).
If you implement the member functions and the ADL functions, though,
  then range-based for loops should call the member functions, whereas
  mere mortals will call the ADL functions.
[https://en.cppreference.com/w/cpp/language/range-for (hyper-link)] :
If range_expression is an expression of a class type C that has both a member named begin and a member named end (regardless of
  the type or accessibility of such member), then begin_expr is
  __range.begin() and end_expr is __range.end();
Otherwise, begin_expr is begin(__range) and end_expr is end(__range), which are found via argument-dependent lookup (non-ADL
  lookup is not performed).
For range-based for loop, member functions are selected first.
Note that the use of < in the != operator maintains the correct invariant, but obviously assumes step is positive and wouldn't be appropriate everywhere a more general range would be.
if you still looking for the answer you can use input type="number" in place of type="range" min max work if it set in that order:
1-name
2-maxlength
3-size
4-min
5-max
just copy it
Also, by using oninput on the <input type='range'> you'll receive events while dragging the range.
The source attribute should be the querySelectorAll selector of the range input you want to listen to.
And it works in the other direction: change the number input and the range input will adjust.
NB: With DateTimes you have to be careful; if only a date is given the value is taken as of midnight on that day; to avoid missing times within your end date, or repeating the capture of the following day's data at midnight in multiple ranges, your end date should be 3 milliseconds before midnight on of day following your to date.
Specifies a(n) (inclusive) range to test.
Is the expression to test for in the range defined by begin_expression
  and end_expression.
Acts as a placeholder that indicates test_expression should be
  within the range indicated by
  begin_expression and end_expression.
To specify an exclusive range, use the
  greater than (>) and less than
  operators (<).
If the column data type is datetime then you can do this following to eliminate time from datetime and compare between date range only.
You should leave one side empty, hence the name "partial range".
The same stands for partial range from operators, just leave the other side empty:
Keep in mind that these range operators return a Substring.
with this method you can get specific range of string.you need to pass start index and after that total number of characters you want.
Let's say you want to scale a range [min,max] to [a,b].
In your case, a would be 1 and b would be 30, but let's start with something simpler and try to map [min,max] into the range [0,1].
You might also notice that (b-a)/(max-min) is a scaling factor between the size of the new range and the size of the original range.
So here you scale the domain to the range.
The advantage is that you can flip signs to your target range.
Applied like so, scaling the range 10-50 to a range between 0-100.
Let's assume you have a range from 0 to 100.
Given an arbitrary number from that range, what "percent" from that range does it lie in?
Now, what if your range was 20 to 100?
A more generalized equation for finding out what % x lies in a range would be:
Now that we know what percent a number lies in a range, we can apply it to map the number to another range.
If we have a number in the old range, what would the number be in the new range?
First, figure out what percent 400 is within the old range.
So, 400 lies in 25% of the old range.
We just need to figure out what number is 25% of the new range.
So, 400 in the range [200, 1000] would map to 12.5 in the range [10, 20]
To map x from old range to new range:
Wrapping the scale function in a class so that I do not need to pass around the min/max values if scaling the same ranges in several places
Adding two small checks that ensures that the result value stays within the expected range.
This example along with a function based version comes from the page [https://writingjavascript.com/scaling-values-between-two-ranges (hyper-link)]
Not sure if this is the most elegant solution (this is what I used), but you could scale your data to the range between 0 to 1 and then modify the colorbar:
With the two different limits you can control the range and legend of the colorbar.
In this example only the range between -0.5 to 1.5 is show in the bar, while the colormap covers -2 to 2 (so this could be your data range, which you record before the scaling).
Using vmin and vmax forces the range for the colors.
You need to use Range<String.Index> instead of the classic NSRange.
I don't know what range you are trying to replace, but let's pretend you want to replace the first 2 characters.
The NSString version (as opposed to Swift String) of replacingCharacters(in: NSRange, with: NSString) accepts an NSRange, so one simple solution is to convert String to NSString first.
This is similar to Emilie's answer however since you asked specifically how to convert the NSRange to Range<String.Index> you would do something like this:
NSRange from NSString counts UTF-16 code-units.
And Range<String.Index> from Swift String is an opaque relative type which provides only equality and navigation operations.
Though the Range<String.Index> seem to be mapped to UTF-16 code-unit offset, that is just an implementation detail, and I couldn't find any mention about any guarantee.
NSRange values can be directly mapped to String.UTF16View indexes.
Then, you must provide proper NSRange which selects correct grapheme clusters.
If you provide wrong range like the above example, it will produce wrong result because proper grapheme cluster range couldn't be figured out.
As of Swift 4 (Xcode 9), the Swift standard
library provides methods to convert between Swift string ranges
(Range<String.Index>)  and NSString ranges (NSRange).
which can be used to convert NSRange to Range<String.Index> correctly
(including all cases of Emojis, Regional Indicators or other extended
grapheme clusters) without intermediate conversion to an NSString:
This method returns an optional string range because not all NSRanges
are valid for a given Swift string.
The Swift 2 version of rangeFromNSRange() was already given 
by Serhii Yakovenko in [this answer (hyper-link)], I am including it
here for completeness:
The Swift 2 version of NSRangeFromRange() is
I've found the cleanest swift2 only solution is to create a category on NSRange:
In Swift 2.0 assuming func textField(textField: UITextField, shouldChangeCharactersInRange range: NSRange, replacementString string: String) -> Bool {:
If you want to revert commit range B to D (at least in git version 2) in a single commit, you can do
You still have to clip to your range.
Edit: The range is inclusive.
If we sum two consecutive references, we get values from 0 to 65534, which covers the desired range of 63001 possibilities for a random number between 2000 and 65000.
To adjust it to the exact range, we use the sum modulo 63001, which will give us a value from 0 to 63000.
Since your range is not a power of 2, a simple modulo operation will only almost give you a uniform distribution, but with a 30-bit input range and a less-than-16-bit output range, as you have in your case, this should really be close enough:
If we stick to values of $RANDOM + 2000 between 2000 and 33500, we cover a range of 31501 ports.
That gets you the range of 200 to 700 into $VAR, inclusive.
I see the references you link all provide examples of iterating over a range of int values or some other fundamental data type.
I'm going to be contrary here and say there is no need for auto const & in a range based for loop.
Here, the author has created a const reference to v to use for all operations which do not modify v.  This is silly, in my opinion, and the same argument can be made for using auto const & as the variable in a range based for loop instead of just auto &.
and beware of possible [Temporary range expression (hyper-link)] pitfalls.
Note that ..< denotes a range that omits the upper value, so you probably want
200 ... 299 or 200 ..< 300.
I preferred Range .contains() operator too, until found that its implementation is inefficient - [https://oleb.net/blog/2015/09/swift-ranges-and-intervals/ (hyper-link)]
We can represent the condition x < 0 using a range:
  (Int.min..<0).contains(x) is exactly equivalent.
I came up with an even simpler version, for creating a range between two defined numbers, eg.
A short way of doing this would be to use Underscore.js's _.range() method.
[http://underscorejs.org/#range (hyper-link)]
I use my custom ng-repeat-range directive:
The code below defines a method range() available to the entire scope of your application MyApp.
Its behaviour is very similar to the Python [range() (hyper-link)] method.
Simplest no code solution was to init an array with the range, and use the $index + however much I want to offset by:
The function has a start/end range value, so it's more flexible, and... it works.
Range = 1..<10
Swift ranges are more complex than NSRange, and they didn't get any easier in Swift 3.
This [range operator (hyper-link)] creates a Swift range which includes both element a and element b, even if b is the maximum possible value for a type (like Int.max).
There are two different types of closed ranges: ClosedRange and CountableClosedRange.
The elements of all ranges in Swift are comparable (ie, they conform to the Comparable protocol).
That allows you to access the elements in the range from a collection.
However, a ClosedRange is not countable (ie, it does not conform to the Sequence protocol).
For that you need the CountableClosedRange.
This is similar to the last one except now the range can also be iterated over.
This range operator includes element a but not element b.
Like above, there are two different types of half-open ranges: Range and CountableRange.
As with ClosedRange, you can access the elements of a collection with a Range.
Again, though, you cannot iterate over a Range because it is only comparable, not stridable.
A CountableRange allows iteration.
You can (must) still use NSRange at times in Swift (when making [attributed strings (hyper-link)], for example), so it is helpful to know how to make one.
The example here is similar in meaning to the Swift range 3..<5.
The ... and ..< range operators are a shorthand way of creating ranges.
The long hand way to create the same range would be
Problem with NSRange
Try experimenting with NSRange and an NSString with emoji and you'll see what I mean.
Because of this, with Swift Strings you use Range<String.Index>, not Range<Int>.
Whenever the starting or ending point of a range can be inferred, you can leave it off.
You can use one-sided integer ranges to iterate over collections.
This also works with String ranges.
If you are making a range with str.startIndex or str.endIndex at one end, you can leave it off.
You can't use a range you created with one string on a different string.
As you can see, String ranges are a pain in Swift, but they do make it possibly to deal better with emoji and other Unicode scalars.
[String Range examples (hyper-link)]
[Range Operator documentation (hyper-link)]
I find it surprising that, even in Swift 4, there's still no simple native way to express a String range using Int.
The only String methods that let you supply an Int as a way of obtaining a substring by range are prefix and suffix.
It is useful to have on hand some conversion utilities, so that we can talk like NSRange when speaking to a String.
Here's a utility that takes a location and length, just like NSRange, and returns a Range<String.Index>:
For example, "hello".range(0,1)" is the Range<String.Index> embracing the first character of "hello".
As a bonus, I've allowed negative locations: "hello".range(-1,1)" is the Range<String.Index> embracing the last character of "hello".
It is useful also to convert a Range<String.Index> to an NSRange, for those moments when you have to talk to Cocoa (for example, in dealing with NSAttributedString attribute ranges).
We can thus write another utility where we go directly from a String location and length to an NSRange:
If anyone want to create NSRange object can create as:
this will create range with position 0 and length 5
Go's range only supports assignment by value.
There is no &range because the problem it solves is too trivial.
As it can be read from the output, copy constructor calls are made during range-based for loop iterations.
If we want to modify the elements in a container using range-based for,
the above for (auto elem : container) and for (const auto& elem : container)
syntaxes are wrong.
While the initial motivation of the range-for loop might have been ease of iterating over the elements of a container, the syntax is generic enough to be useful even for objects that are not purely containers.
The syntactic requirement for the for-loop is that range_expression support begin() and end() as either functions -- either as member functions of the type that it evaluates to or as non-member functions what take an instance of the type.
As a contrived example, one can generate a range of numbers and iterate over the range using the following class.
Eagerly evaluated (2.x range):
Lazily evaluated (2.x xrange, 3.x range):
I used to use numpy.arange but had some complications controlling the number of elements it returns, due to floating point errors.
Pylab has frange (a wrapper, actually, for matplotlib.mlab.frange):
i wrote a function that returns a tuple of a range of double precision floating point numbers without any decimal places beyond the hundredths.
it was simply a matter of parsing the range values like strings and splitting off the excess.
I use it for displaying ranges to select from within a UI.
using itertools: lazily evaluated floating point range:
For example naive_frange(0.0, 1.0, 0.1) would yield 0.999... as its last value and thus yield 11 values in total.
Please note the first letter of Range is capital.
You can change Range to something like drange or frange if you want.
The "Range" function behaves just as you want it to.
You can check it's manual here [ [http://reference.wolfram.com/language/ref/Range.html (hyper-link)] ].
Is there a range() equivalent for floats in Python?
I helped add the function [numeric_range (hyper-link)] to the package [more-itertools (hyper-link)].
more_itertools.numeric_range(start, stop, step) acts like the built in function range but can handle floats, Decimal, and Fraction types.
I think that there is a very simple answer that really emulates all the features of range but for both float and integer.
Why Is There No Floating Point Range Implementation In The Standard Library?
As made clear by all the posts here, there is no floating point version of range().
That said, the omission makes sense if we consider that the range() function is often used as an index (and of course, that means an accessor) generator.
So, when we call range(0,40), we're in effect saying we want 40 values starting at 0, up to 40, but non-inclusive of 40 itself.
When we consider that index generation is as much about the number of indices as it is their values, the use of a float implementation of range() in the standard library makes less sense.
For example, if we called the function frange(0, 10, 0.25), we would expect both 0 and 10 to be included, but that would yield a generator with 41 values, not the 40 one might expect from 10/0.25.
Thus, depending on its use, an frange() function will always exhibit counter intuitive behavior; it either has too many values as perceived from the indexing perspective or is not inclusive of a number that reasonably should be returned from the mathematical perspective.
The core idea is that nsteps is the number of steps to get you from start to stop and range(nsteps) always emits integers so there's no loss of accuracy.
[*] In particular, frange() returns a list, not a generator.
Here's the version that handles many of these cases correctly giving same behaviour as native range():
Note that this would error out step=0 just like native range.
One difference is that native range returns object that is indexable and reversible while above doesn't.
This can be done with numpy.arange(start, stop, stepsize)
Note 1:
From the discussion in the comment section here, "never use numpy.arange() (the numpy documentation itself recommends against it).
Other answers based on np.arange are deprecated.
This function will work well too, except for the cases when you want the reversed range.
You can go even further with plain standard library and compose a range function for the most of numeric types:
It will not work with decreasing ranges.
The best option here is to raise StopIteration, if you want to mimic the range function itself.
If you would like to mimic the range function interface, you can provide some argument checks:
If you relax the requirement to make a float analog of the range function, and just create a list of floats that is easy to use in a for loop, the coding is simple and robust.
Note that the function super_range is not limited to floats.
Whereas integer-based ranges are well defined in that "what you see is what you get", there are things that are not readily seen in floats that cause troubles in getting what appears to be a well defined behavior in a desired range.
split a given range into a certain number of segment: the linspace approach in which you accept the large number of decimal digits when you select a number of points that does not divide the span well (e.g.
make it handle range-like defaults so you can start from 0 automatically
make it handle decreasing ranges
The sizes of the foo and bar lists had ranged from 10 to 1,000,000 elements.
To generate a random value between rangeMin and rangeMax:
For creating a random number between A and B givin' that the boundaries are valid (A>B) we need to:
1. find the range between A and B so we can know how to many "steps" we have.
double randomValue = rangeMin + (rangeMax - rangeMin) * r.nextDouble();
double RandomValue = Offset + (Range)*(randomVal between 0.0-1.0)
I have a Range class in [MiscUtil (hyper-link)] which you could find useful.
You could throw an Exception if the fromDate > toDate, but I prefer to return an empty range instead []
h = [(i + 1, x) for i, x in enumerate(xrange(2000, 2005))]
Python 2.5 and older do not support the start parameter so instead you could create two range objects and zip them:
Now h = list(enumerate(xrange(2000, 2005), 1)) works.
Try using the TimeRange object in C# to complete your goal.
[Here is where I got that example of using TimeRange (hyper-link)]
What do you intend your "range" filter to do?
If your DataFrame does not have an index (IOW, the df.index is the default RangeIndex), then you will want to set index=False when writing.
The warning is from Fixnum#to_a, not from Range#to_a.
You can create an array with a range using splat,
I just tried to use ranges from bigger to smaller amount and got the result I didn't expect:
That's because of ranges implementations.
You need to create an Array<Int> using the Range<Int> rather than casting it.
Put the Range in the init.
This should work because Array has an initializer taking a SequenceType and Range conforms to SequenceType.
Interesting that you cannot (at least, with Swift 3 and Xcode 8) use Range<Int> object directly:
Therefore, as it was mentioned earlier, you need to manually "unwrap" you range like:
Since Swift 3/Xcode 8 there is a CountableRange type, which can be handy:
You can implement ClosedRange & Range instance intervals with reduce() in functions like this.
$RANDOM is an internal Bash function
  (not a constant) that returns a
  pseudorandom integer in the range
  0 - 32767.
Generate random number in the range of 0 to n (signed 16-bit integer).
Maybe I am a bit too late, but what about using jot to generate a random number within a range in Bash?
The standard method to generate a number (without a utility method) in a range is to just use the double with the range:
will give you a long between 0 (inclusive) and range (exclusive).
So if you want to get a Long, you're already not going to get the full 64 bit range.
I would suggest that if you have a range that falls near a power of 2, you build up the Long as in that snippet, like this:
to get a 35 bit range, for example.
If you want a uniformly distributed pseudorandom long in the range of [0,m), try using the modulo operator and the absolute value method combined with the nextLong() method as seen below:
Since nextLong() generates a uniformly distributed pseudorandom long in the range of [-(2^48),2^48) (or somewhere in that range), you will need to take the absolute value of it.
If you don't, the modulo of the nextLong() method has a 50% chance of returning a negative value, which is out of the range [0,m).
What you initially requested was a uniformly distributed pseudorandom long in the range of [0,100).
This will generate numbers in the given range for longs.
The current answer is good for the case when you know for sure what the range is, but if you still want correct behavior when the value is out of the expected range, then it won't work.
Generic function to find documents in a collection by date range of specifics fields:
As startTime stored as Timestamp, you can do this query range for more accururate (this good for both condition of long date range or same date range).
[Range (hyper-link)] is used in the request, to ask for a particular range (or ranges) of bytes.
[Content-Range (hyper-link)] is used in the response, to indicate which bytes the server is giving you (which may be different than the range you requested), as well as how long the entire content is (if known).
Content-Range is not only used in responses.
Thus the PUT request can include a Content-Range header indicating to the server where the partial entity body should be merged into the entity.
I just wanted to clarify, as I was researching the use of Content-Range in a WebDAV client I am developing, so perhaps this expanded information will prove useful to somebody else.
Range tree stores points, and optimized for "which points fall within a given interval" queries.
Range tree - O(n logn) preprocessing time, O(k+logn) query time, O(n) space
Range tree - new points can be added/deleted in O(logn) time (see [here (hyper-link)])
Range tree - O(n(logn)^d) preprocessing time, O(k+(logn)^d) query time, O(n(logn)^(d-1))) space
Note that there's a difference in behavior of [range() (hyper-link)] between Python 2 and 3 that you should know about: in Python 2 [range (hyper-link)] returns a list, and in Python3 an iterator, which is memory-efficient, but not always desirable.
range() in Python 2.x returns a list:
xrange() in Python 2.x returns an iterator:
And in Python 3 range() also returns an iterator:
Anyway, the range() in Python 3 is a generator.
This is what range(5) + range(10, 20) exactly did in Python 2.5 -- because range() returned a list.
I came to this question because I was trying to concatenate an unknown number of ranges, that might overlap, and didn't want repeated values in the final iterator.
The benefit of chain, however, is that you can pass an arbitrary list of ranges.
OTOH, unpacking generalisations haven't been "generalised" to arbitrary sequences, so you will still need to unpack the individual ranges yourself.
You can use list function around range function to make a list
LIKE THIS
Now this range function will return all the numbers starting from 0 to n-1
A modified version of the range to support start and end is:
Now it is possible to create ranges from 0 to N with the spread operator.
A lot of these solutions build on instantiating real Array objects, which can get the job done for a lot of cases but can't support cases like range(Infinity).
You can use a generator function, which creates the range lazily only when needed:
You can use a higher order generator function to map over the range generator:
If you are fearless you can even generalize the generator approach to address a much wider range (pun intended):
Generators now allow you to generate the number sequence lazily and using less memory for large ranges.
Range with step ES6, that works similar to python list(range(start, stop[, step])):
For a range
On the contrary, it has one major disadvantage : that you cannot create the range at runtime, as you need to know the template arguments at compile time itself.
The C++ standard library does not have one, but [Boost.Range has boost::counting_range (hyper-link)], which certainly qualifies.
You could also use [boost::irange (hyper-link)], which is a bit more focused in scope.
C++20's range library will allow you to do this via [view::iota(start, end) (hyper-link)].
I wrote a library called range for exactly the same purpose except it is a run-time range, and the idea in my case came from Python.
You can find the library on bitbucket, and it is under Boost License: [Range (hyper-link)].
It is a one-header library, compatible with C++03 and works like charm with range-based for loops in C++11 :)
Ranges can be compared lexicographically.
Examples of basic
usage, working with standard containers, working with standard
algorithms and working with range based for loops.
(Edit: - we can make the methods of range static instead of const.)
I found that boost::irange was much slower than the canonical integer loop.
This range automatically starts from zero.
You still need to use String.Index and not an Int index for the range, though.
You can use a subscript (note the Swift 4 one-sided range):
For a range of characters ( indexes) from string using String (range) syntax we can get from i-th to f-th characters with the code bellow:
For a substring (range) from a string using String.substring (range) we can get the substring using the code bellow:
To f-th, I use offsetBY: f + 1, because the range of subscription use ..< (half-open operator), not include the f-th position.
So, if you for example get a Range as the result of an NSRegularExpression, you could use the following extension:
Many answers have proposed workarounds for using ranges, but they can lead to inefficient code as they use String methods (index(from:), index(:offsetBy:), ...) that are not O(1).
So there are almost always more buckets allocated than you're using, and when you do a range over the map, it checks that tophash value of each bucket in that 2^B to see if it can skip over it.
To summarize, the delete within a range is safe because the data is technically still there, but when it checks the tophash it sees that it can just skip over it and not include it in whatever range operation you're performing.
ianlancetaylor commented on Feb 18, 2015
  I think the key to understanding this is to realize that while executing the body of a for/range statement, there is no current iteration.
While executing the body, one of the key/value pairs that has been seen--the most recent pair--was assigned to the variable(s) of the range statement.
The question he's answering is about modifying map elements in place during a range operation, which is why he mentions the "current iteration".
But it's also relevant here: you can delete keys during a range, and that just means that you won't see them later on in the range (and if you already saw them, that's okay).
Possible columns are in the range [A, XFD] or [1, 16384].
You can define any range you like in COLUMNS constant and it will do the right thing.
You can adjust the feature_range for your needs, or even use a standart scaler sk.StandardScaler()
If a syntactically valid byte-range-set includes at least one byte- range-spec whose first-byte-pos is less than the current length of the entity-body, or at least one suffix-byte-range-spec with a non- zero suffix-length, then the byte-range-set is satisfiable.
Otherwise, the byte-range-set is unsatisfiable.
If the byte-range-set is unsatisfiable, the server SHOULD return a response with a status of 416 (Requested range not satisfiable).
Otherwise, the server SHOULD return a response with a status of 206 (Partial Content) containing the satisfiable ranges of the entity-body.
So I think in your example, the server should return a 416 since it's not a valid byte range for that file.
A client will often test to see if the server handles ranged requests other than just looking for an Accept-Ranges response.
Chrome always sends a Range: bytes=0- with its first GET request for a video, so it's something you can't dismiss.
Whenever a client includes Range: in its request, even if it's malformed, it's expecting a partial content (206) response.
So, in order for the client to play video properly, your server must be able to handle these incomplete range requests.
You can handle the type of 'range' you specified in your question in two ways:
First, You could reply with the requested starting point given in the response, then the total length of the file minus one (the requested byte range is zero-indexed).
You must always respond with the content length included with the range.
If the range is complete, with start to end, then the content length is simply the difference:
Request: 
    Range: bytes=500-1000
Response:
    Content-Range: bytes 500-1000/123456
Remember that the range is zero-indexed, so Range: bytes=0-999 is actually requesting 1000 bytes, not 999, so respond with something like:
Some servers will send a regular 200 response as a reply, which it accepts (but with limited playback options), but try to send a 206 instead to show than your server handles ranges.
[RFC 2616 (hyper-link)] says it's acceptable to ignore range headers.
Firefox 64.0 makes a half hearted attempt to make these scrubbable whether or not you serve via range requests, but it gets confused and throws up a spinning wheel until the stream is completely downloaded if you seek a few times more than it thinks is appropriate.
If you want your code to pick a specific range of digits, be sure to use the && operator instead of the ||.
If you're already using lodash, you could use the inRange() function:
[https://lodash.com/docs/4.17.15#inRange (hyper-link)]
When you're using commit ranges like .. and ... with git log, the difference between them is that, for branches A and B,
The commits that branch B contains that don't exist in A is what is returned by the commit range, and is highlighted in red in the Venn diagram, and circled in blue in the commit tree:
You can make the triple-dot commit range ... more useful in a log command by using the --left-right option to show which commits belong to which branch:
Someday I might add my own explanation for how the commit ranges work with git diff, but for now, you might want to check out [What are the differences between double-dot ".." and triple-dot "..." in Git diff commit ranges?
[Pro Git § 6.1 Git Tools - Revision Selection - Commit Ranges (hyper-link)]
you can easily change range of dates and direction.
The following snippet (uses java.time.format of Java 8) maybe used to iterate over a date range :
In Python 3, range works like xrange([ref (hyper-link)])
Alternatively, if you are OK with a list of real numbers instead, you can use the standard random.randrange:
This works on basically everything that has a defined order, including xrange objects and lists.
range() and xrange() take a third parameter that specifies a step.
But for iteration, you should really be using xrange instead.
Note for Python 3 users: There are no separate range and xrange functions in Python 3, there is just range, which follows the design of Python 2's xrange.
You can use [Array.Copy(...) (hyper-link)] to copy into the new array after you've created it, but I don't think there's a method which creates the new array and copies a range of elements.
MyArray.ToList<TSource>().GetRange(beginningIndex, endIndex).ToArray()
In C# 8, they've introduced a new Range and Index type, which can be used like this:
[https://docs.microsoft.com/en-us/dotnet/core/whats-new/dotnet-core-3-0#ranges-and-indices (hyper-link)]
In C# 8.0, you can now do many fancier works including reverse indices and ranges like in Python, such as:
You can use the reversed() method on a range
Earlier edit for Swift 1.2: As of Xcode 6 Beta 4, by and ReverseRange don't exist anymore :[
If you are just looking to reverse a range, the reverse function is all you need:
As of beta 4, both the by() function and the ReversedRange type have been removed from the language.
If you're looking to make a reversed range, your options are now as follows:
1: Create a forward range, and then use the reverse() function to reverse it.
Note that I've also included the new exclusive range operator in this post as well.
ReverseRange has been removed; use lazy(x..
It means that every time I want to do a reverse range, I have to remember to put the parentheses, plus I have to write that .reverse() on the end, sticking out like a sore thumb.
So I've had to scurry around replacing all my decrementing C-style for loops with this ugly .reverse() construct — wondering all the while, why on earth isn't there a reverse-range operator?
Try following query to get dates between the range:
From_Date or To_Date could be between your date range or the record dates could cover the whole range.
This is easy, use this query to find select data from date range between two dates
An alternative approach would involve storing the ranges in a table, instead of embedding them in the query.
You would end up with a table, call it Ranges, that looks like this:
This does mean setting up a table, but it would be easy to maintain when the desired ranges change.
Make sure you use a word other than 'range' if you are in MySQL, or you will get an error for running the above example.
Because the column being sorted on (Range) is a string, string/word sorting is used instead of numeric sorting.
If the range is mixed, simply pad an extra zero:
This will allow you to not have to specify ranges, and should be SQL server agnostic.
Where the first removes all data points outside the given range and the second only adjusts the visible area.
You can also use the shorthand function xlim (or ylim), which like the first option removes data points outside of the given range:
Quick note: if you're also using coord_flip() to flip the x and the y axis, you won't be able to set range limits using coord_cartesian() because those two functions are exclusive (see [here (hyper-link)]).
This just alters the visible range (i.e.
So with the default inclusive=False, 'a', 'z' would just span the range from a to y, excluding z.
Use "for count in range" and chr&ord:
Another option (operates like range - add 1 to stop if you want stop to be inclusive)
Use xrange instead of range
Depending on how complex the range of characters is, a regular expression may be convenient:
input fires rapidly as you drag a range input slider.
UPDATE: I am leaving this answer here as an example of how to use mouse events to use range/slider interactions in desktop (but not mobile) browsers.
no-jQuery) solution to allow reading range input values without using on('input'... and/or on('change'... which work inconsistently between browsers.
The problem: When using a range input, i.e.
a slider, on('input'... provides continuously updated range values in Mac and Windows Firefox, Chrome and Opera as well as Mac Safari, while on('change'... only reports the range value upon mouse-up.
I report here 2 strategies to get identical continuous range value reporting in all browsers using vanilla JavaScript (i.e.
It essentially reads the range value both after 'mousedown' and during 'mousemove' events, slightly delaying each using requestAnimationFrame.
I provide here a no-jQuery cross-browser desktop-and-mobile ability to consistently respond to range/slider interactions, something not possible in current browsers.
...where r is your range input element and f is your listener.
The listener will be called after any interaction that changes the range/slider value but not after interactions that do not change that value, including initial mouse or touch interactions at the current slider position or upon moving off either end of the slider.
As of early June 2016, different browsers differ in terms of how they respond to range/slider usage.
The onRangeChange function provides a consistent and predictable cross-browser response to range/slider interactions.
In addition, the "input" event fires its listener only when the range/slider's value changes.
To use this solution, include the onRangeChange function from the summary above (simplified/minified) or the demo code snippet below (functionally identical but more self-explanatory) in your own code.
where myRangeInputElmt is your desired <input type="range"> DOM element and myListener is the listener/handler function you want invoked upon "change"-like events.
In the code snippet below, the function onRangeChange provides the universal solution.
The demo shows the range/slider value as well as the number of times the standard "change", "input" and custom "onRangeChange" events have fired (rows A, B and C respectively).
When running this snippet in different browsers, note the following as you interact with the range/slider:
JavaScript input type range slider events change input browser compatability cross-browser desktop mobile no-jQuery
I'm posting this as an answer in case you are like me and cannot figure out why the range type input doesn't work on ANY mobile browsers.
If you develop mobile apps on your laptop and use the responsive mode to emulate touch, you will notice the range doesn't even move when you have the touch simulator activated.
This is the problem with the range type input.
If the user's browser doesn't support range type, it will fall back and treat it as a text input.
This is why you cannot move the range when the touch simulator is activated.
If you develop hybrid apps on your laptop, there is a simple and easy library you can use to enable range type input to work with touch events.
This library is called [Range Touch (hyper-link)].
[Recreating the HTML5 range input for Mobile Safari (webkit)?
See [http://ruby-doc.org/core/classes/Range.html#M000695 (hyper-link)] for the full API.
If the range contains numbers or strings, natural ordering is used.
Otherwise step invokes succ to iterate through range elements.
Reference: [http://ruby-doc.org/core/classes/Range.html (hyper-link)]
range_step_inclusive and range_step are long gone.
It seems to me that until the .step_by method is made stable, one can easily accomplish what you want with an Iterator (which is what Ranges really are anyway):
If one needs to iterate multiple ranges of different types, the code can be made generic as follows:
Advantages of this approach is that is works with for sugaring and will continue to work even when unstable features become usable; also, unlike the de-sugared approach using the standard Ranges, it doesn't lose efficiency by multiple .next() calls.
Use the [num (hyper-link)] crate with [range_step (hyper-link)]
If your range is reasonably small, there is no reason to cache the right-hand side of the comparison in the do loop.
Except when the size of the range is a power of 2, this method produces [biased non-uniform distributed (hyper-link)] numbers regardless the quality of rand().
Generate a random number n in the range 0 through (max-min).
Since RAND_MAX - (RAND_MAX + 1) % (max-min+1) is always less than (RAND_MAX + 1) / 2,
we know that p > 1/2, so the expected number of iterations will always be less than two
for any range.
If such ranges are needed - you should use a 32-bit or 64-bit random source, instead of the 15-bit rand(), or ignore rand() results which are out-of-range.
If you later find that int doesn't cover the range you need for your distribution, this can be remedied by changing the uniform_int_distribution like so (e.g.
I am assuming here that rand() gives you a random value in the range between 0.0 and 1.0 NOT including 1.0 and that max and min are integers with the condition that min < max.
That way you have got floor(log(b,RAND_MAX)) because each digit in base b, except possibly the last one, represents a random number in the range [0, max-min].
To select data in numerical range you can use BETWEEN which is inclusive.
Note the Accept-Ranges response header to indicate the server has range header support:
Range header in previous response detected - subsequent request with open-ended range to confirm support.
Response returns a 206 status and Content-Range header to indicate the bytes present in the response body:
Subsequent range request to capture the end of the file (probably to capture trailing metadata):
User clicks in the video progress bar beyond the downloaded range - a range request is issued to begin playing from the selected position:
What that does is find out proportionally "how far into" the input range the input is.
It then applies that proportion to the size of the output range to find out in absolute terms how far into the output range the output should be.
It then adds the start of the output range to get the actual output number.
First, if we want to map input numbers in the range [0, x] to output range [0, y], we just need to scale by an appropriate amount.
An input range of [input_start, input_end] has input_end - input_start + 1 numbers.
So it's equivalent to a range of [0, r], where r = input_end - input_start.
Similarly, the output range is equivalent to [0, R], where R = output_end - output_start.
Then, we can translate the y value back to the original output range by adding output_start: output = output_start + y.
say you have range [input_start..input_end], let's start by normalising it such that 0 is input_start, and 1 is input_end.
let's just scale it down by the length of the range, then we'll have the biggest value (input_end) mapped to one.
okay, next step, we'll actually scale it to output range.
It is as trivial as just multiplying with the actual length of the output range, as such:
I wrote this method, which follows precisely the algebraic formula for mapping one range of numbers to another.
The function works like this ... notice I labeled the ends of the ranges A and B - that is because it is not necessary to make your ranges start low and end high or something like that ... you can make your first range 300 to -7000 and your second range -3500 to 5500 ... makes no difference what numbers you chose for your ranges, it will map them correctly.
I've even used this function in a counter to fade something out on the screen, but since opacity is a value between 0 and 1, I set up a counter to count from 0 to 100 then I map the range 0 - 100 to 0 - 1 and it gets all of the fractions between 0 and 1 based on feeding it the numbers 0 to 100 ... it's a cleaner way to do it as the main code looks better using a function like this than it does actually doing the math on the fly.
If You have small range, you can always write something like:
In short you won't be able to use a range of numbers as a type until a proposal comes out.
Is it possible to restrict a type to a number range, e.g.
if you need an extensive range, just print and copy/paste:
This is not an actual solution but a workaround which works in a very limited range of numbers!
EDIT: I put those types in a package for an easy reausability: [https://www.npmjs.com/package/ts-number-range (hyper-link)]
Here is the xrange way:
The caption for the vertical slider demo in the [IE documentation (hyper-link)] erroneously indicates that setting height greater than width will display a range slider vertically, but this does not work.
Source: [http://twiggle-web-design.com/tutorials/Custom-Vertical-Input-Range-CSS3.html (hyper-link)]
You're attempting to pass it a range of values.
to get the range 1 - 6.
If you need a range between lets say 10 - 30 then just do
It also accepts negative ranges:
or define it as a Range extension as property like this:
You can now use simply Int.random(in: 1 ... 6) to generate a random number in a given range.
var rangeFromLimits =  arc4random_uniform( (UPPerBound - LOWerBound) +   1)) + LOWerBound;
It’s idiomatic to me to extend Range:
make random number between range for arc4random_uniform()?
Probably one find useful this a bit updated version of Range extension from Ted van Gaalen's answer using Swift 4/Xcode 9+:
The answer should be the indexes of the elements between a certain range, we assume inclusive, in this case, 6 and 10.
For more information look at the scikit-learn [documentation (hyper-link)] on preprocessing data: scaling features to a range.
Based on this post: [https://stats.stackexchange.com/questions/70801/how-to-normalize-data-to-0-1-range (hyper-link)]
Take care with this answer, as it ONLY works for data that ranges [0, n].
This does not work for any range of data.
The output values will be in range of 0 and 1.
You can use the substringWithRange method.
You can also still use the NSString method with NSRange, but you have to make sure you are using an NSString like this:
String.substringWithRange() is expecting a Range<String.Index> parameter, and as far as I can tell there isn't a generator method for the String.Index type.
start and end are of type String.Index here and are used to create a Range<String.Index> and used in the subscript accessor (if a space is found at all in the original string).
You just need to add a new subscript function that takes a range and uses advancedBy() to walk to where you want:
The original question was about using the substringWithRange, but as has been pointed out that's a harder way to go than just doing your own extension.
The above range solution is good.
Range() appears to be a generic function so that it needs to know the type it is dealing with.
Please note that in the example, substringWithRange in conjunction with NSMakeRange take the part of the string starting at index 6 (character "W") and finishing at index 6 + 6 positions ahead (character "!")
Thus, when you say str.substringWithRange, Swift thinks you mean the Swift method rather than the NSString method — and then you are hosed, because the Swift method expects a Range<String.Index>, and you don't know how to make one of those.
This is how you get a range from a string:
The key point is that you are passing a range of values of type String.Index (this is what advance returns) instead of integers.
You can create an extension with a subscript though, that does this for you, so you can just pass a range of integers (see e.g.
If you have an NSRange, bridging to NSString works seamlessly.
For example, I was doing some work with UITextFieldDelegate and I quickly wanted to compute the new string value when it asked if it should replace the range.
You can use this extensions to improve substringWithRange
First create the range, then the substring.
And you also have to consider, that a browser doesn't actually have to render an input type=range as a slider.
Here's what I use for capturing the 'change event' for the html5 range slider:
You can also bind the 'click' event to the range slider if you want to return its value when it has been clicked (or even dragged).
range is a class of immutable iterable objects.
So no, range is not a generator.
Well, ranges have some useful properties that wouldn't be possible that way:
You can iterate over the same range multiple times.
This allows me to quickly and easily loop over a Range of cells easily:
I typically like to use the built in functionality of assigning a range to an multi-dim array (I guess it's also the JS Programmer in me).
Assigning ranges to variables is a very powerful way to manipulate data in VBA.
[regular-expressions.info/Character Classes (hyper-link)]

[Numeric Ranges (hyper-link)] (have many examples on matching strings interpreted as numeric ranges)
The - range definition goes from 1 to 1, which includes just 1.
That is, - in a character class definition doesn't define numeric range in the pattern.
Range definition instead uses ASCII/Unicode encoding of the characters to define ranges.
In most flavors, [a-Z] is likely to be an illegal character range


because a (97) is "greater than" than Z (90)
If no ranges are specified, it implicitly ors every character within it together.
Thus, [abcde] is the same as (a|b|c|d|e), except that it doesn't capture anything; it will match any one of a, b, c, d, or e.  All a range indicates is a set of characters; [ac-eg] says "match any one of: a; any character between c and e; or g".
Your goal is evidently to specify a number range: any number between 01 and 12 written with two digits.
In general, you can transform any number range into a valid regex in a similar manner.
or, 1-1, match a single digit in the range of 1 through 1
(Date range between 01/2000 to 12/9999 )
What does it mean for the ranges to overlap?
It means there exists some number C which is in both ranges, i.e.
To avoid confusion, considering the ranges are:
[x1:x2] and [y1:y2]
Now, if we are allowed to assume that the ranges are well-formed (so that x1 <= x2 and y1 <= y2) then it is sufficient to test
Unless you're running some high-performance range-checker on billions of widely-spaced integers, our versions should perform similarly.
Given two ranges [x1,x2], [y1,y2]
If two ranges are "too fat" to fit in a slot that is exactly the sum of the width of both, then they overlap.
For ranges [a1, a2] and [b1, b2] this would be:
When do 2 ranges not overlap?
Subtracting the Minimum of the ends of the ranges from the Maximum of the beginning seems to do the trick.
If you were dealing with, given two ranges [x1:x2] and [y1:y2], natural / anti-natural order ranges at the same time where:
Think in the inverse way: how to make the 2 ranges not overlap?
Therefore, the condition to make the 2 ranges overlap: not(y2 < x1 or x2 < y1), which is equivalent to y2 >= x1 and x2 >= y1 (same with the accepted answer by Simon).
i want check two time ranges overlap.
You will need to decide wether the following periods are IN or OUTSIDE your ranges:
If your table has columns called range_end and range_start, here's some simple SQL to retrieve all the matching rows:
Taking your example range of 06/06/1983 to 18/06/1983 and assuming you have columns called start and end for your ranges, you could use a clause like this
check the start of your test range is before the end of the database range, and that the end of your test range is after or on the start of the database range.
A range is just that: something defined by its start and end, not by its contents.
"Iterating" over a range doesn't really make sense in a general case.
Consider, for example, how you would "iterate" over the range produced by two dates.
IMO, the fact that it's allowed for forward ranges should be viewed as a convenience method only.
If you want to iterate backwards over a range like that, you can always use downto:
Here are [some more thoughts (hyper-link)] from others on why it's tough to both allow iteration and consistently deal with reverse-ranges.
Iterating over a range in Ruby with each calls the succ method on the first object in the range.
And 5 is outside the range.
I add one another possibility how to realise iteration over reverse Range.
According to the book "Programming Ruby", the Range object stores the two endpoints of the range and uses the .succ member to generate the intermediate values.
Depending on what kind of data type you are using in your range, you can always create a subclass of Integer and re-define the .succ member so that it acts like a reverse iterator (you would probably also want to re-define .next as well).
You can also achieve the results you are looking for without using a Range.
As bta said, the reason is that Range#each sends succ to its beginning, then to the result of that succ call, and so on until the result is greater than the end value.
How about (0..1).reverse_each which iterates the range backwards?
It seems to be strange to me that the construct above does not produce
  the expected result.
If you really can't make the client side configurable, pick one in the second range, like 48042, and just use it, declaring that any other software on those boxes (including any added in the future) has to keep out of your way.
I decided to download the assigned port numbers from IANA, filter out the used ports, and sort each "Unassigned" range in order of most ports available, descending.
This did not work, since the csv file has ranges marked as "Unassigned" that overlap other port number reservations.
I manually expanded the ranges of assigned port numbers, leaving me with a list of all assigned port numbers.
I then sorted that list and generated my own list of unassigned ranges.
Since this stackoverflow.com page ranked very high in my search about the topic, I figured I'd post the largest ranges here for anyone else who is interested.
These are for both TCP and UDP where the number of ports in the range is at least 500.
From within a range-function, it can also be obtained by a:lastline-a:firstline+1.
(:h function-range-example)
I implemented a TimeRange class as you can see below.
The get_overlapped_range first negates all the non overlapped options by a simple condition, and then calculate the overlapped range by considering all the possible options.
To get the amount of days you'll need to take the TimeRange value that was returned from get_overlapped_range and divide the duration by 60*60*24.
You can use the datetimerange package: [https://pypi.org/project/DateTimeRange/ (hyper-link)]
"2015-01-01T00:00:00+0900" inside the DateTimeRange() can also be datetime format, like Timestamp('2017-08-30 20:36:25').
Using auto&& or [universal references (hyper-link)] with a range-based for-loop has the advantage that you captures what you get.
Why should the body of a range-based for-loop be different?
Range.Value2  works the same way as Range.Value, except that it does not check the cell format and convert to Date or Currency.
[Range.Value (hyper-link)]: Returns or sets a Variant value that represents the value of the specified range.
[Range.Value2 (hyper-link)]: The only difference between this property and the Value property is that the Value2 property doesn't use the Currency and Date data types.
In addition to solutions proposed, and in case you have a 1D range to 1D array, i prefer to process it through a function like below.
The reason is simple: If for any reason your range is reduced to 1 element range, as far as i know the command Range().Value will not return a variant array but just a variant and you will not be able to assign a variant variable to a variant array (previously declared).
I had to convert a variable size range to a double array, and when the range was of 1 cell size, i was not able to use a construct like range().value so i proceed with a function like below.
This function returns an array regardless of the size of the range.
Ranges will return an array unless the range is only 1 cell and then it returns a single value instead.
This function will turn the single value into an array (1 based, the same as the array's returned by ranges)
This answer improves on previous answers as it will return an array from a range no matter what the size.
It is also more efficient that other answers as it will return the array generated by the range if possible.
I'm another vote for iterating through the cells in the range.
Unless somebody has found a workaround, my experience trying to assign the range directly to a Variant has been that it works fine (albeit returning a 2-dimensional array when I really only need 1D) except if my range has multiple areas, like for example, when I want just the visible cells in a column of a filtered table, or if I have ctrl-selected different blocks of cells on a sheet.
Iterating through all the cells in the range with a for..each loop always produces the results I expect.
As a bonus, you can do non-uniform mappings from one range to another, for intance if you want to map [1,128] to [1,10], [128,256] to [10,90] and [256,512] to [90,100] you can do it like this:
found at [https://rosettacode.org/wiki/Map_range#Python_ (hyper-link)]
does not clamp the transformed values to the ranges a or b (it extrapolates)
Simple map range function:
If explicit loop is needed, with python 2.6 and 2.7, you should use xrange (see below).
From what you say, in Python 3, range is the same as xrange (returns a generator).
So maybe range is as good for you.
If you must loop, prefer xrange/range and avoid using np.arange.
(Something like the worst thing you could do would be to iterate over the array with an index created with range or np.arange as the first sentence in your question suggests, but I'm not sure if you really mean that.)
So for this case numpy is 4 times faster than using xrange if you do it right.
Now, consider for a general range of [a,b].
Since any value XOR'd with itself is zero, the f(a-1) just cancels out all the values in the XOR run less than a, leaving you with the XOR of the range [a,b].
In Python 2.x, [range (hyper-link)] returns a list, but in Python 3.x [range (hyper-link)] returns an immutable sequence, of type [range (hyper-link)].
In Python 2.x, if you want to get an iterable object, like in Python 3.x, you can use [xrange (hyper-link)] function, which returns an immutable sequence of type [xrange (hyper-link)].
Advantage of xrange over range in Python 2.x:
The advantage of xrange() over range() is minimal (since xrange() still has to create the values when asked for them) except when a very large range is used on a memory-starved machine or when all of the range’s elements are never used (such as when the loop is usually terminated with break).
Furthermore, the only apparent way to access the integers created by range() is to iterate through them,
Since range objects in Python 3 are immutable sequences, they support indexing as well.
Quoting from the range function documentation,
Ranges implement all of the common sequence operations except concatenation and repetition
Range objects implement the [collections.abc.Sequence (hyper-link)] ABC, and provide features such as containment tests, element index lookup, slicing and support for negative indices.
All these are possible with that immutable range sequence.
 Because the range returns an immutable sequence, not an iterator object.
So, whenever islice is done on a range object, it always starts from the beginning.
Simply change

numbers = range(100)

 to

numbers = iter(range(100))

 Now, numbers is an iterator object and it remembers how long it has been iterated before.
In python-2.x, range actually creates a list (which is also a sequence) whereas xrange creates an xrange object that can be used to iterate through the values.
On the other hand, in python-3.x, range creates an iterable (or more specifically, a sequence)
range creates a list if the python version used is 2.x .
In this scenario range is to be used only if its referenced more than once otherwise use xrange which creates a generator there by redusing the memory usage  and sometimes time as it has lazy approach.
xrange is not there in python 3.x rather range stands for what xrange is for python 2.x
refer to question
 [What is the difference between range and xrange functions in Python 2.X?
To understand what for i in range() means in Python3, we need first to understand the working of the range() function.
The range() function uses the generator to produce numbers.
As you know range() returns the range object.
A range object uses the same (small) amount of memory, no matter the size of the range it represents.
It only stores the start, stop and step values and calculates individual items and subranges as needed.
So it means range() produces numbers one by one as the loop moves to the next iteration.
It saves lots of memory, which makes range() faster and efficient.
Reference: [PyNative - for loop with range() (hyper-link)]
If the step is always +1 (which is the default for range) the following should be more efficient than converting each list to a set or iterating over either list:
Assuming you are working exclusively with ranges, with a step of 1, you can do it quickly with math.
On a pair of ranges each with over 10^7 elements, this took under a second, independent of how many elements overlapped.
If you want to find the overlap of ranges with arbitrary steps you can use my package [https://github.com/avnr/rangeplus (hyper-link)] which provides 
a Range() class compatible with Python range(), plus some goodies including intersections:
Range() can also be unbound (when stop is None the Range goes on to +/-infinity):
The intersection is computed, not iterated, which makes the efficiency of the implementation independent of the length of the Range().
This is the answer for the simple range with step=1 case (99% of the time), which can be 2500x faster as shown in the benchmark when comparing long ranges using sets (when you are just interested in knowing if there is overlap):
Conclusion: even for small ranges, it is twice as fast.
Conclusion: you want to use the range_overlapping function in this case as it is 2500x faster (my personal record in speedup)
This one liner works perfectly in Python3, takes ranges as inputs and output.
It also handles illegal ranges.
This solution generates integers that are in the intersection of an arbitrary number of range objects in O(1) memory.
Ranges are iterators that modify themselves to generate elements.
Therefore, to loop over a range, it is necessary to modify it (or a copy of it, as shown below).
Now coming back to the example with the Range we can check how it implements IntoIterator.
Looking at [the reference docs for Range (hyper-link)], Range strangely does not seem to implement IntoIterator directly... but if we check the [Blanket Implementations (hyper-link)] section on doc.rust-lang.org, we can see that every iterator implements the IntoIterator trait (trivially, by just returning itself):
Well, checking [further up (hyper-link)] (under trait implementations) we see that Range does implement Iterator:
And thus Range does implement IntoIterator via the indirection of Iterator.
However, there is no implementation of either Iterator for &Range<A> (this would be impossible) or of IntoIterator for &Range<A>.
Therefore, we can use a for loop by passing Range by value, but not by reference.
Why can &Range not implement Iterator?
An iterator needs to keep track of "where it is", which requires some kind of mutation, but we cannot mutate a &Range because we only have a shared reference.
(Note that &mut Range can and does implement Iterator - more on this later).
It would technically be possible to implement IntoIterator for &Range as that could produce a new iterator.
But the likelihood that this would clash with the blanket iterator implementation of Range would be very high and things would be even more confusing.
Besides, a Range is at most two integers and copying this is very cheap, so there is really no big value in implementing IntoIterator for &Range.
This brings up another question: If we can clone the range and it is (as claimed above) cheap to copy it, why doesn't Range implement the Copy trait?
Then the .into_iter() call would copy the range coll (instead of moving it) and it could still be used after the loop.
Also note that &mut Range does implement iterator, so you can do
Finally, for completeness, it might be instructive to see which methods are actually called when we loop over a Range:
However, the range (e.g.
Therefore, you can consume the range itself by calling into_iter() (which you do implicitly).
Now, it is as if you moved the range into some function and you cannot use your variable coll anymore.
In this case, you could construct a Vec from your range (with the collect method), clone the range when iterating over it or get the length before iterating (since getting the length doesn't consume the range itself).
[https://doc.rust-lang.org/std/ops/struct.Range.html (hyper-link)]
Ranges are lists in Python 2 and iterators in Python 3.
As an aside, you woudn't want to use (*range(m), *range(m + 1, n)) even though it works because it will expand the iterables into a tuple and this is memory inefficient.
In C range for __int32 is –2147483648 to 2147483647.
[See here for full ranges.
A 32 bit integer ranges from -2,147,483,648 to 2,147,483,647.
In C, the integer(for 32 bit machine) is 32 bit and it ranges from -32768 to +32767.
32-bit signed integer in 2's complement representation has the range -231 to 231-1 which is equal to  -2,147,483,648 to 2,147,483,647.
The C language definition specifies minimum ranges for various data types.
For int, this minimum range is -32767 to 32767, meaning an int must be at least 16 bits wide.
An implementation is free to provide a wider int type with a correspondingly wider range.
For example, on the SLES 10 development server I work on, the range is -2147483647 to 2137483647.
Range-based for is for when you need to access each element of a container once.
A range-based for-loop is just syntactic sugar for "normal" loop using iterators, so the above applies.
If do_something is a simple function or can be wrapped in one, a simple map() can do_something range(some_number) times:
Since Docker 1.5 you can now expose a range of ports to other linked containers using:
Or instead you can publish a range of ports to the host machine via Docker [run (hyper-link)] command:
So you must check every cell in range separately:
Of course here are more code than in solution with CountA function which count not empty cells, but GoTo can interupt loops if at least one not empty cell is found and do your code faster especially if range is large and you need to detect this case.
For a specific range, just substitute  RANGE(...) for Selection.
If you find yourself in a situation where you can’t use CountA then it's much faster to first store your range as an array and loop on the array data than it is to loop on range/cell data.
If Range("A38:P38") is empty, it would print True in the Immediate Window; otherwise it'd print False.
in this case, it evaluates if range E10:E14 is empty.
The multiple repeated xrange() statements could be expressed like so, if you want to scale this up to a ten-dimensional loop or something similarly ridiculous:
Unlike Python's built-in range(), which permits both an arbitrary start, stop, and step, numpy's np.ndindex() only accepts a stop.
Here's an implementation that acts more like the built-in range() function.
To return to a mark preface the named mark with a single quote ( 'a)These marks can be used as the range.
If you already have the percentage and you're looking for the "input value" in a given range, then you can use the adjusted formula provided by [Dustin (hyper-link)] in the [comments (hyper-link)]:
Do you mean something like this, which scales the values linearly to fit within the new range?
You can transform one of the ranges into the other with this function (python)
In general the idea is that you want to rebase the ranges (make sure that they both start at zero) and then find how you need to stretch the first range to obtain the second range.
Convert the first range to [0-440] by subtracting 40 and the second range to [0-130] by subtracting 10.
The issue here is that the quotation marks are for when you are passing the name of a range to the .Range() object, but you are wanting to pass it the results of calling the .address method.
If you put those method calls in quotation marks VBA wont run them and will instead try to interpret what you have in them as the name of the range you are referring to.
You need to construct the range name string using these methods and pass the result to the .Range() object.
This first one separates out the construction of the range name and assigns that to a variable which can then be passed to .Range().
This returns a random int in range[0, n-1]).
This returns a random int in the range [0, n-1].
I.e., to get the range [20, 80] use:
Below code will help you to generate random numbers between two numbers in the given range:
Here is a very general purpose function which iterates over a range's values.
It can very easily be changed to accept an actual Range instance instead of the array of values.
here's update to [Voy's post (hyper-link)], uses [range.getValues() (hyper-link)] to get all values and omitting temporary array.
should be even faster because range.getCell().getValue() is omitted in the two dimensional loop.
Select your range
If the number is <30 then generate number in range 1-100 if not generate in range 40-60.
Here's a weighted solution at 3/4 40-60 and 1/4 outside that range.
So in your case, you could take f(x)=-(1/25)x2+4x to get a distribution with the most values in the middle of your range.
How many random numbers you sum and what their range is will determine how the final distribution will look.
Using the sum of 1 random number was already proposed in your question, but as you notice is not biased towards the center of the range.
You can get even more bias towards the center of the range by taking the sum of more random numbers.
This can still in theory cover the full range, but it has so much bias towards the center that you should never expect to see it reach the endpoints.
Solving this for x yields you the actual random number your are looking for, which is guaranteed to be in the [0, 100] range and a much higher likelihood to be close to the center than the edges.
Assume you have ranges and weights for every range:
Range selection boundaries.
Generate random number N from range [0, Sum of all weights).
Take ith range and generate random number in that range.
Ranges don't have to be ordered neither ascending nor descending order, so for faster range look-up range that has highest weight should go first and one with lowest weight should go last.
This is an excerpt from method of mine, which converts a DataTable (the dt variable) into an array and then writes the array into a Range on a worksheet (wsh var).
The code for value2 is in both cases the same
            Excel.Range cell = activeWorksheet.get_Range(Range);
            cell.Value2 = Array;
Strangely, I had to do this today!
Setting LC_COLLATE=C avoids nasty surprises about the meaning of character ranges in many locales.
Instead of making assumptions about the byte range of non-ASCII characters, as most of the above solutions do, it's slightly better IMO to be explicit about the actual byte range of ASCII characters instead.
(which basically greps for any character outside of the hexadecimal ASCII range: from \x00 up to \x7F)
I found adding range 0-8 and 0x0e-0x1f (to the 0x80-0xff range) is a useful pattern.
Even though intuitively they should match the range 0x80 to 0xff, 3 and 4 byte unicode characters were not matched.
ASCII range is x00-x7F, space is x20, since strings have spaces the negative range omits it.
Non-ASCII range is x80-xFF, since strings have spaces the positive range adds it.
String is presumed to be at least 7 consecutive characters within the range.
Some people use Tuples or Points, but in the end you want your Range to be extensive and provide some handy methods that relate to a Range.
It's also best if generic (what if you need a range of Doubles, or a range of some custom class?)
Ranges and Indices are released with C#8.0 and .NET Core.
Also, a bit of a different tangent here but sometimes ranges are useful only to iterate over them, a bit like it is customary to do in python.
In that case, the System.Linq namespace defines a static IEnumerable<int> Range(Int32, Int32) method, which, as the signature suggests,
generates a sequence of integral numbers within a specified range
There is a Enumerable.Range method but this one accepts start and count as its parameter.
Enumerable.Range(start, end - start + 1).ToList()
You now have your range selected.
The existing range-based for loop is over-constrained.
As you can see from the Standardese that you posted, the end iterator of a range is only used in the loop-condition __begin != __end;.
Well, if you have a sentinel-delimited range (C-string, line of text, etc.
The above operator== for StringIterator<> is symmetric in its arguments and does not rely on whether the range-for is begin != end or end != begin (otherwise you could cheat and cut the code in half).
But will this continue to work for long pipelines of ranges and filters?
C.6 Range Facade and Adaptor Utilities [future.facade]
The range abstraction
  makes that achievable.
With the right library components, it should be
  possible for users to define a range with a minimal interface (e.g.,
  current, done, and next members), and have iterator types
  automatically generated.
Such a range facade class template is left as
  future work.
Essentially, this is equal to D-style ranges (where these primitives are called empty, front and popFront).
A delimited string range with only these primitives would look something like this:
If one does not know the underlying representation of a primitive range, how to extract iterators from it?
How to adapt this to a range that can be used with range-for?
Conclusion: sentinels are not just a cute mechanism to press delimiters into the type system, they are general enough to [support primitive "D-style" ranges (hyper-link)] (which themselves may have no notion of iterators) as a zero-overhead abstraction for the new C++1z range-for.
Yes, you can, only if you convert your range lists as immutable tuple, so they are hashable and accepted as keys of your dictionary:
EDIT: actually it works in Python 3 as range is an immutable sequence type and generate an immutable tuple instead of a list as L3viathan stated.
I took some time to create a solution which would work whatever the values may be (picking one entry in the dictionary works as long as the lines are not "weighted" by bigger ranges.
It is possible on Python 3 — and on Python 2 if you use xrange instead of range:
You can't build a dictionary directly from a range, unless you want the range itself to be the key.
To get individual entries for each possibility within the range:
When you have a dict indexed by a small range of integers, you really should consider using a list instead:
This approach will accomplish what you want, and the last line will work (assumes Py3 behavior of range and print):
BTW if you're simulating a 20-side die you need the final index to be 21, not 20 (since 20 is not in range(1,20)).
I wrote a RangeKeyDict class for handling cases like this, which is more general and easy to use.
[https://github.com/albertmenglongli/range-key-dict (hyper-link)]
That isn't what you're doing; you're trying to map ranges.
In the code I present above, you can quickly spot whether the range uses < or <= in each place.
Instead of trying to use the ranges for the keys, you could reformulate your problem into one that does map specific keys to specific values.
You do so by looping through the ranges and generating a full dict containing all the possible values:
In this case, we use the ranges to generate a dict that we can look up a result in.
According to [raratiru (hyper-link)]'s [comment (hyper-link)], the RangeDict was the fastest answer at the time.
Seems like it may be related to the "double relative" combination of using both .Range and .Cells
Instead using rng.Parent.Range and having only the .Cells be relative to the containing range seems to fix it (and still allows for fully-qualified range references)
I encountered the same behavior when getting an Excel range within a range in VB.Net.
If 'max' and 'min' are independent variables, the extra subtraction for (max-min) will waste time, but if that expression can be precomputed at compile time, or if it can be computed once at run-time to test many numbers against the same range, the above expression may be computed efficiently even in the case where the value is within range (if a large fraction of values will be below the valid range, it may be faster to use if ((value >= min) && (value <= max)) ... because it will exit early if value is less than min).
I would do a Range object, something like this:
The idea is that one of the two factors becomes negative if the number lies outside of the range and zero if the number is equal to one of the bounds:
New and better way that also works with negative ranges:
This can be used with both positive and negative ranges and defaults to a range of
1..100 (inclusive) and uses x as the number to check followed by an optional range defined by min and max.
When checking if a "Number" is in a range you have to be clear in what you mean, and what does two numbers are equal mean?
If it's to validate method parameters, none of the solutions throw ArgumentOutOfRangeException and allow easy/proper configuration of inclusive/exclusive min/max values.
The link above demonstrates the "range" selector feature, which is what you're looking for, but there are lots of other ways to use it as well.
[jQuery UI Slider (hyper-link)] widget extension for a rangeDrag feature.
This feature allows the user to drag the entire range at once, rather than having to drag the handles to move the range.
You can try adding the drag + drop triggers to the $('.ui-slider-range') element OR add you own event to the $('.ui-slider-range') element that just trigger the events on the $('.ui-slider-handle')
You can also try [jQRangeSlider (hyper-link)], take a look at the [demo (hyper-link)].
It allows for both fixed and user-changeable ranges.
Here is a formula if you know the max and min values of a range, and you want to generate numbers inclusive in between the range:
Returning rand() % N does not uniformly give a number in the range [0, N) unless N divides the length of the interval into which rand() returns (i.e.
This means that the only correct way of changing the range of rand() is to divide it into boxes; for example, if RAND_MAX == 11 and you want a range of 1..6, you should assign {0,1} to 1, {2,3} to 2, and so on.
If you want to get random values outside the default range [0, RAND_MAX], then you have to do something tricky.
It returns values in the range [min, max], where max >= min and 1+max-min < RAND_MAX.
There is a source of randomness, outputting integer numbers in range [0, MAX) with uniform distribution.
The goal is to produce uniformly distributed random integer numbers in range [rmin, rmax] where 0 <= rmin < rmax < MAX.
In my experience, if the number of bins (or "boxes") is significantly smaller than the range of the original numbers, and the original source is cryptographically strong - there is no need to go through all that rigamarole, and simple modulo division would suffice (like output = rnd.next() % (rmax+1), if rmin == 0), and produce random numbers that are distributed uniformly "enough", and without any loss of speed.
Will return a floating point number in the range [0,1]:
ScnCap is already a set range object, so you do not need to use the Range() method on it again.
If you have two sets of date ranges ($startDate to $endDate and $targetStartDate to $targetEndDate), this is how to check for intersection...
Whether the for loop is range based or not does not make a difference at all, it only simplifies the code inside the parenthesis.
I would not use this loop to initialize1 the range defined by numbers, because when I look at it, it seems to me that it is iterating over a range of numbers, but in actuality it does not (in essence), i.e instead of reading from the range, it is writing to the range.
I believe it beats the range based for loop both in communicating the intent and in readability.
But using range-based for is a lot better:
On the other hand, if we're talking about C++1y, then I would argue that no, the algorithms will not be obsoleted by range based for.
In C++ standard committee there is a study group that is working on a proposal to add ranges to C++, and also there is work being done on polymorphic lambdas.
Ranges would remove the need to use pair of iterators and polymorphic lambda would let you to not specify exact argument type of lambda.
is "we're assigning to everything in a range.
The range is numbers.
is "we're doing something to everything in a range.
The range is numbers.
One plausible reason I might want to provoke the first reading, is because I think the most important fact about this code is that it assigns to the range.
I use generate because in C++ std::generate means "range assignment".
Range-based for loops have an inherently more direct way of expressing that the range is numbers, than iterator-based algorithms do.
That's why people work on range-based algorithm libraries: boost::range::generate(numbers, rand); looks better than the std::generate version.
As against that, int& in your range-based for loop is a wrinkle.
What if the value type of the range isn't int, then we're doing something annoyingly subtle here that depends on it being convertible to int&, whereas the generate code only depends on the return from rand being assignable to the element.
Hence auto, which defers thinking about the types until I see what gets assigned -- with auto &x I say "take a reference to the range element, whatever type that might have".
Range-based for loops improve loops (primarily by removing most of the boilerplate, although there's a little more to them than that).
There are some things you cannot do (simply) with range-based loops that algorithms that take iterators as input can.
Iterator-based algorithms give you a better control on the range you are operating on.
The general version is implemented as a for-loop over the provided range, and this version will be used when instantiating the template.
if you'll provide it a range which is a std::vector<int> - often it will actually call memset under the hood, yielding a much faster and better code.
Range-based loop include the way things are done: start with the first, apply and go next element until the end.
Range-based for-loop is just that.
A time range doesn't exist as a standalone index type.
ActiveRecord tries to be helpful and iterates my range.
Actually, it works if you specify with range an interval shorter than [-100, 100].
If you want to plot the histogram on a range larger than [x.min(), x.max()] you can change xlim propertie of the plot.
Per [[range.access.begin] (hyper-link)]: (emphasis mine)
The name ranges​::​begin denotes a [customization point
  object (hyper-link)].
The
  expression ranges​::​​begin(E) for some subexpression E is
  expression-equivalent to:
Therefore, ranges::begin(std::declval<A>()) is invalid.
If your range always starts from 0 then all you have to do is
A more involved any-range to any-range conversion would require
Use like convertToRange(20,[10,50],[5,10]);
minRange (0 in your example)
maxRange (15 in your example)
To have the range :
[http://rosettacode.org/wiki/Map_range#JavaScript (hyper-link)]
I've taken August Miller's idea and added limits to them (value can't go outside the range of in_min and in_max and if it does it returns out_min and out_max respectively) and minified it for those who want a copy paste function for their scripts:
well you have two ranges range1 = [a1,a2] and range2 = [b1,b2] and you want to map a value s in range one to a value t in range two.
But it really depends on the size of src range.
For large range scale(...) should be more efective.
Another way to do this with simple if/else range.
Actually this is what is use to cast a value which is out of the range to the closest end of it.
[http://php.net/manual/en/function.range.php (hyper-link)]
[Create a date range in mysql (hyper-link)]
If you want to generate any kind of dates range (past, future, and in between), you will have to use this view instead:
You could simply limit the date range inside the CTE and omit the where clause from the select statement using the CTE.
The above produces the date range 1/22/0001 - 1/27/0001 and is extremely trivial.
Thus, given two dates, generating a range can be broken down like so:
The first generates a range of numbers and the second uses this functionality to generate a range of dates.
The math is to ensure that input order doesn't matter and because I wanted to use the full range of numbers available in GenerateRangeSmallInt.
The following function takes ~16ms of CPU time to return the maximum range of 65536 dates.
However, I do not feel myself comfortable to do this with quite large range so I've ended up with the following solution:
This range will give me dates from 59999 days (~164 years) behind to 40000 days (109 years) ahead:
You'd like to get the a date range.
Getting a list of dates in a date range boils down to creating a sequence of integer numbers see [generate an integer sequence in MySQL (hyper-link)]
for contiguous ranges like that you can also use Resize:
It functions much like a Range object.
Selection and Range do not share all the same properties and methods, though, so for ease of use it might make sense just to create a range and set it equal to the Selection, then you can deal with it programmatically like any other range.
This depends on what you mean by "get the range of selection".
If you mean getting the range address (like "A1:B1") then use the Address property of Selection object - as Michael stated Selection object is much like a Range object, so most properties and methods works on it.
If the values of the chart exceed the customized domain range, then the domain boundaries set get ignored.
You can use the [Resize (hyper-link)] method as you know the size of destination range will be the same as the source range.
Using Resize, you could transfer the range directly without involving the clipboard.
Chart data range has to have a fixed address.
There is a way around this, and that's using named ranges
In name manager, define the names for your data and titles
I used xrange and yrange, and defined them as:
xrange:  =OFFSET(Sheet1!$A$2,0,0,Sheet1!$E$1)
  yrange:  =OFFSET(Sheet1!$B$2,0,0,Sheet1!$E$1)
Leave the Chart data range blank
for the Legend Entries (Series), enter  the title as usual, and then the name you defined for the data (note that the workbook name is required for using named ranges)
[image]
First create two named ranges that use Index/Match formulas to pick the begin and end days based on E2 and E3:
Here's a nice [Chandoo post (hyper-link)] on how to use dynamic ranges in charts.
If you still want to refer to your start and end cells, you'll need to add a separate formula for your Day Range and your Values Range.
Day Range:
Values Range:
Then add two ranges referencing the INDIRECT values of those cells
Press Ctrl+F3, Click New, and add a new range with the name "chart_days", referring to =INDIRECT(Sheet1!$F$4); and a new range with the name "chart_values", referring to =INDIRECT(Sheet1!$F$5)
I use OFFSET to create a defined name formula so that I may define all the ranges for the data, allowing me to have a starting a ending date (or the beginning and ending position of any data set).
Initial Month and Last Month are Range Names defined for single cells used to indicate which months of the graph will be included (from starting to ending months).
When a line chart's range is a named variable, and the variable has INDIRECT() references through a cell to a range, then the variable must have at least 2 INDIRECT()s separated by a comma.
t2_test2: (in_array($val, range($min, $max)): 9.3301 ms
Most of the given examples assume that for the test range [$a..$b],  $a <= $b, i.e.
the range extremes are in lower - higher order and most assume that all are integer numbers.
I base the test it in the fact that ($n-$a) and ($n-$b) have different signs when $n is between $a and $b, and the same sign when $n is outside the $a..$b range.
There's filter_var() as well and it's the native function which checks range.
filter_var with that filter returns either boolean false when number is outside range or the number itself when it's within range.
The expression (!== false) makes function return true, when number is within range.
If you would use != it would be false for number 0 within range -5; +5 (while it should be true).
If user would write empty value ($userScore = '') it would be correct, as in_array is set here for default, non-strict more and that means that range creates 0 as well, and '' == 0 (non-strict), but '' !== 0 (if you would use strict mode).
You could return bool or even add openRange parameter.
checking range of every number of array or POST/GET values.
Proof:
Let n belong to range [a,b], where [a,b] is a subset of real numbers.
You could do it using in_array() combined with range()
Generating an array (escpecially with larger ranges) will slow down the execution.
It contains Katakana, Hiragana and Kanji unicode ranges.
As zawhtut mentioned, [this page (hyper-link)] has a reference for several unicode ranges.
To summarize the ranges:
What is Unicode range of all Japanese characters?
The number in bracket is the part of the language you capture with the Unicode code range (in decimal).
Make a Range and compare Time objects to it using the === operator.
Note: I just used beginning_of_day and end_of_day to provide an easy range.
The important part is the include_with_range?
method on a Range.
I think the 2009 paper ["Pairs do not make good ranges" (hyper-link)] by Alisdair Meredith is at least part of the answer.
Basically, many algorithms return pairs of iterators that are actually not guaranteed to be valid ranges.
It seems they removed the support for pair<iterator,iterator> from the for-range loop for this reason.
If you know for certain that some pair of iterators really represents a valid range then you could wrap them into a custom type which offers begin()/end() member functions:
Functions which return valid ranges (like equal_range) should say so using an appropriate return type.
It's a bit embarrasing that we have to manually confirm this via something like as_range above.
You can use boost::make_iterator_range.
It constructs an iterator_range with begin() and end() methods.
boost::make_iterator_range can accept std::pair of iterators.
Moreover, [Boost.Range (hyper-link)] contains a few more interesting ranges which you could find pretty useful combined with the new for loop.
With C++20 we will have ranges.
What you are interested in is ranges::views::iota, which makes this code legal:
That means even though views::iota represents a range from 1 to 10 exclusive, no more than one int from that range exists at one point.
IIRC the reason it sets both headers is because some versions of Opera don't allow you to set the Range header on an XHR.
So yes, the same information is sent in both headers - the standard Range header is the preferred one to use, if you don't need to support browsers that can't send it properly.
The step method described in [http://ruby-doc.org/core/classes/Range.html (hyper-link)] should do the job but seriously harms may harm the readability.
You may think that step(5) kind of produces a new Range, like why_'s question initially intended.
But the each is called on the (0..20) and has to be replaced by another step(5) if you want to "reuse" the 0-5-10-15-20 range.
Your Range would be from newMin to newMax.
Edit: So it sounds like we have something called rangeSize.
The above answer does not guarantee to get a new sub-range with the exact rangeSize.
You can use an index in a range and then access the array via its index:
The same goes for  v-for in range:
[Unicode (hyper-link)], stict term, has no range.
As for the range, I believe there is no range of printable characters.
The wiki says, the C0 control character is in the range U+0000—U+001F and U+007F (which is the same range as ASCII) and C1 control character is in the range U+0080—U+009F
The non-graphical characters would consist, basically, of control characters: the range 0x00-0x0f plus some others that are scattered.
ASCII printable character range is \u0020 - \u007f
In fact many 8-bit character sets have many non-consecutive ranges which are non-printable.
The printable Unicode character range, excluding the hex, is 32 to 126 in the int datatype.
I would much like to refine my program to produce the list of ranges, but for now here's what I am working with for anyone who needs immediate answers:
I am posting this tool because I think this question attracts a lot of people who are looking for slightly different applications of knowing printable ranges.
Taking the opposite approach to @HoldOffHunger, it might be easier to list the ranges of non-printable characters, and use not to test if a character is printable.
Then there's invalid character ranges, either [yet] unused or reserved for encoding purposes, and [language-specific variation selectors (hyper-link)]..
For covering my case -> I've got a range start & end date, and dates list that can be as partly in provided range, as fully (overlapping).
[Range#cover?
In Ruby 1.9 the most direct translation seems to be [Range#cover?
In case you wonder how that's different from Range#include?, it's that the latter iterates over all elements of the range if it's a non-numeric range.
I use ranges::view_facade to create a custom view.
It holds a vector returned by f (one at a time), changing it to a range.
This makes it possible to use view::join on a range of such ranges.
Certainly, we can't have a random or bidirectional access to elements (but view::join itself degrades a range to an Input range), nor can we assign to them.
I copied struct MyRange from Eric Niebler's [repository (hyper-link)] modifying it slightly.
To keep up with this contract, views have to pass around references to range elements, and in general they can handle both rvalue and lvalue references.
This of course is somewhat of a hack and will only work if you then streamline the whole range into some sink, like an output container.
range-v3 forbids views over temporary containers to help us avoid the creation of dangling iterators.
"That's all great, Casey, but why don't range-v3 views store temporary ranges like this internally?"
If views were to store temporary ranges in internal containers "behind your back" then the complexity of view operations - and hence compositions - would become unpredictable.
Since the view composition won't store the temporary ranges for you, you need to dump them into some kind of storage yourself, e.g.
Note that the correctness of this approach depends on the fact that view::join is an input range and therefore single-pass.
Why isn't there some kind of support for 'temporary storage materialization™' in range-v3?"
range-v3 now has views::cache1, a view that caches the most recent element in the view object itself, and returns a reference to that object.
It looks like [there are now test cases in the range-v3 library (hyper-link)] that show how to do this correctly.
I've found such solution for filtering range of IPs:
*' slightly to be a [CIDR range (hyper-link)] like 172.17.0.0/16
Here's what I get on my 2017 MacBook Pro with @test_range set to 1..1000:
With a much larger range of 1..100_000, the relative ordering stays the same:
The same goes for a much smaller range of 1..10:
The range depends on where you are looking at.
As correctly stated by bkaid, the available zoom range depends on where you are looking and the kind of map you are using:
When you have use many times words like 'range', autocorrect will change 'Range' value to 'range'.
Try manually change this method to 'Range' and sure that you don't have any variables like 'range'.
However, the related issues of a lowercase method can come from creating a variable or routine which you named range and the system will auto change case based on that definition.
You should never create a variable or routine with the same name as a defined process like Range().
Try declaring Range as a Range somewhere in your code (note the case):
This should convert all your range to Range
I have several models and procedures, and at some point all of my Ranges got converted to lowercase range.
My easy fix was to go to ThisWorkbook in my project, and Dim Range as Range there, and then it will automatically change  "range" to "Range" everywhere it appears in your code
In your example, the new dates are both outside the range.
If you want to check if there is any overlap between the date ranges, use:
The following will return true if the two date ranges overlap, regardless of order.
@Bergi's answer is probably more elegant, in that it just checks the start/end pairs of the two date ranges.
Is it possible to copy a range to a virtual range?
Range allways represents some existing instance(s) of cells on a worksheet in a workbook.
Does it require me to sloppily paste it in another range in the
  workbook?
You can paste everithing from one range to another, you can paste only something like e.g.
formulas to another range.
But in the above example it only makes x a "shortcut" to that range
  rather than a copy of the range object itself.
Variable x holds a reference to that specific range.
It is not possible to made any standalone copy of a range.
It is possible to create references to a range and to copy everithing / something from one range to another range.
Lately I have been finding it would be quite useful to totally save a
  range and all it's properties in memory rather than in the workbook
  somewhere.
Again, it is not possible to save all range properties to some virtual, standalone copy of specific Range because Range allways represents an existing, concrete set of cells.
What you could do is to create your own  class with some properties of a Range or even all properties ... but it will be some extra work to do.
Here some examples how to use range as parameter and copy it to another range.
The range must be set after the plot.
If ymin is changed before plotting, this will result in a range of [0, 1].
range will be an array of date objects that fall on the first possible value for each day
You need to install moment and moment-range first:
A native for loop is enough and makes most sense because a for loop exists to count values in a range.
If you are using moment then you can use their "official plugin" for ranges [moment-range (hyper-link)] and then this becomes trivial.
moment-range node example:
moment-range browser example:
If you want to find each "x" intervals (days, months, years, etc...) between two dates, [moment.js (hyper-link)] and the [moment-range (hyper-link)] extension packages enable this functionality.
The date ranges were missing single days due to timezone shift caused by the local day light saving time (DST).
git filter-branch does accept range notation, but the end of the range needs to be a reference, not the ID of a commit.
if you want filter commits B and C you should also filter all commits after: D, E, F, G, H.
So, that's why git tells you to use a ref at the end of the range, so that it just not finishes up with a detached head.
Enclose you filter commands in an if-statement that checks for that range.
You can check whether a commit is within a given range with this command:
If your selection range is "any time near the turn of the century" you'll de-select this commit, since its committer date is "now", more than a decade beyond 1999.)
You can use the isin method on the date column like so
df[df["date"].isin(pd.date_range(start_date, end_date))]
In case if you are going to do this frequently the best solution would be to first set the date column as index which will convert the column in DateTimeIndex and use the following condition to slice any range of dates.
very helpful when you want to be explicit about your range.
you can do it with pd.date_range() and Timestamp.
Then you can define a date range index :
Pranav C Balan's answer better explains what is going on: [HTML5 range - unsupported pseudo: range (hyper-link)]
There is no :range pseudo selector in css or jQuery.
There's use of [:in-range (hyper-link)] or [:out-of-range (hyper-link)] css selector that you can use for min and max value range:
There's no :range selector.
Range can be found with a simple formula as follows
To generate a random double within a range, multiply a random int with a random double.
Generates a random integer uniformly distributed in the
range from [min] to [max], both inclusive.
I don't really like the idea of while(true)
But other solution would be to use enumerable.Range:
If you know how many chunks/intervals/periods/parts you want to split your time range into, I've found the following to be helpful
You can convert that listOfDates into however you want to represent a timerange (a tuple, a dedicated date range object, etc).
Do you want overlapping start/end of ranges?
Is there a minimum range size?
Below is some code that'll handle some of the corner cases, you'll have to think about overlapping especially and possibly push the start/end of ranges by a few seconds or maybe more depending on the data you're returning.
if you still wanted to use ranges...
So, in this case, the "ranges" are really just fenced in with nils in order to catch the boundary conditions.
range(4) returns [0, 1, 2, 3],
range(3,6) returns [3, 4, 5],
range(0,10,2) returns [0, 2, 4, 6, 8],
range(10,0,-1) returns [10, 9, 8, 7, 6, 5, 4, 3, 2, 1],
range(8,2,-2) returns [8, 6, 4],
range(8,2) returns [],
range(8,2,2) returns [],
range(1,5,-1) returns [],
range(1,5,-2) returns [],
So if you need a function to work similarly to Python's range(), you can use above mentioned solution.
An example of the lazy range() using yield can be found [here (hyper-link)].
In addition to what's already said, Javascript 1.7+ provides support for [iterators and generators (hyper-link)] which can be used to create a lazy, memory-efficient version of range, simlar to xrange in Python2:
A port of the range function from Python 2 is provided by the [underscore.js (hyper-link)] and [lodash (hyper-link)] utility libraries (along with many other useful tools).
For a very simple range in ES6:
Still no built-in function that is equivalent to range(), but with the most recent version - ES2015 - you can build your own implementation.
Here's a small extension for one of the answers in case you need to specify both starting and ending position of the range:
The following is a natural adaption of Python's [range() (hyper-link)] function to JavaScript:
Here is another es6 implementation of the range
[pythonic (hyper-link)] mimics the Python range behaviour best it can using JS' generators (yield), supporting both the range(stop) and range(start, stop, step) use cases.
In addition, pythonic's range function returns an Iterator object similar to Python that supports map and filter, so one could do fancy one-liners like:
MDN recommends this approach: [Sequence generator (range) (hyper-link)]
I'm partial to Python3 behavior of range.
You will find below JavaScript's implementation of Python's range():
Assuming you need a simple range with a single step:
Is there a function in JavaScript similar to Python's range()?
All of the solutions here are referring to Python 2's range (probably because of the code example you gave).
However in Python 3, the range() method returns an iterator.
So the more accurate representation of Python 3's range(n) function is Array(n).keys().
Is there a function in JavaScript similar to Python's range()?
It works very similar to Python 2.7 range(), but it's much more dynamic.
This function can behave in three different ways (just like Python's range()):
range(stop)
range(start, stop)
range(start, stop, step)
Actually, in Python range() returns an iterable object and we know that iterators are more memory efficient than arrays (or lists in Python).
Does not seem to have any problem on HTML5 <input type="range"> using change.
(I assume it because the range input is inside li tag, and you gave it a name):
Assuming this is a homework ;-) - no need to summon libraries etc - it probably expect you to use range() with chr/ord, like so:
For the rest, just play a bit more with the range()
You will have an if-check no matter how efficient you try to optimize this not-so-intensive computation :) You can subtract the upper bound from the number and if it's positive you know you are out of range.
Apache Commons Lang has a [Range class (hyper-link)] for doing arbitrary ranges.
[Guava Range (hyper-link)] has similar API.
You could use java.time.temporal.ValueRange which accepts long and would also work with int:
I know this is quite an old question, but with Java 8's Streams you can get a range of ints like this:
For a range of Comparable I use the following :
My code is similar to Python`s range :)
If you use Spring, you can rely on org.springframework.data.domain that is quite complete including bound and unbound ranges.
So Range("A2") can be written as Cells(2,1)
You can set the a new range in various ways.
Method 4 is not the same as Method 1 when the ranges are not adjacent.
In old (2.x) versions of Python, xrange can only handle Python 2.x ints, which are bound by the native long integer size of your platform.
Additionally, range allocates a list with all numbers beforehand on Python 2.x, and is therefore unsuitable for large arguments.
I would definitely stick with xrange since creating a list between 0 and what looks like a number rivaled by infinity would be taxing for memory.
xrange will generate only the numbers when asked.
Returning to this 5 years later, I would use yield and yield from plus faster counting over the prime range:
The accepted answer suggests a drop-in replacement for xrange, but only covers one case.
Very uneficient code, that's not the best way of getting dividers, I've done it with a for and range, but I can't execute it because of the long variables, so I decided to implement it with a for using a while, and increment a counter by myself.
Another implementation for python 2 range():
Python will compare [range (hyper-link)] objects as [Sequences (hyper-link)].
For example, the first range object:
and the second range object:
Both represent an empty list and since two empty lists compare equal (True) so will the range objects that represent them.
As a result, you can have completely different looking range objects; if they represent the same sequence they will compare equal:
Do note, though, that even though the comparison doesn't evaluate how they represent a sequence the result of comparing can be achieved using solely the values of start, step along with the len of the range objects; this has very interesting implications with the speed of comparisons:
Ranges compares super fast:
As [@SuperBiasedMan (hyper-link)] noted, this only applies to the range objects in Python 3.
Python 2 range() is a plain ol' function that returns a list while the 2.x [xrange (hyper-link)] object doesn't have the comparing capabilies ([and not only these.. (hyper-link)]) that range objects have in Python 3.
Look at [@ajcr's answer (hyper-link)] for quotes directly from the source code on Python 3 range objects.
It's documented in there what the comparison between two different ranges actually entails: Simple quick operations.
The [range_equals (hyper-link)] function is utilized in the [range_richcompare function (hyper-link)] for EQ and NE cases and assigned to the [tp_richcompare slot for PyRange_Type types (hyper-link)].
I believe the implementation of range_equals is pretty readable (because it is nice as simple) to add here:
res = range(0) == range(2, 2, 2)
means the range from 0 to 0 - 0 steps (here step equals to default value 1), list without values.
means the range from 2 to 2 with step equals to 2, list without values.
So, these ranges are really equal
range(0) returns range(0,0).
range(2, 2, 2) returns range(2, 2, 2).
Testing range objects for equality with == and != compares them as
  sequences.
That is, two range objects are considered equal if they
  represent the same sequence of values.
(Note that two range objects
  that compare equal might have different start, stop and step
  attributes, for example range(0) == range(2, 1, 3) or range(0, 3, 2)
  == range(0, 4, 2).)
If you compare ranges with the "same" list, you'll get inequality, as stated in [the docs (hyper-link)] as well:
In Python 2, where range just returns a list, range(1) == [0] evaluates as True.
To add a few additional details to the excellent answers on this page, two range objects r0 and r1 are compared [roughly as follows (hyper-link)]:
The length of a range object is easily to calculate using the start, stop and step parameters.
So in the case of range(0) == range(2, 2, 2), Python does the following:
sees that range(0) and range(2, 2, 2) are different objects in memory.
sees that len(range(0)) is 0.
This means that len(range(2, 2, 2)) is also 0 (the previous test for inequality failed) and so the comparison should return True.
method of the range to test this
Note that 2..0 is an empty range, so (2..0).include?
have a look at this question: [Determining if a variable is within range?
You can check if value is in the range by use of following methods,
All number literals denote inclusive ranges.
But in practice, I use for i in range(len(a) (or for _ in range(len(a)) if I don't need the index) to make it explicit that I want to iterate as many times as there are items in a sequence without needing to use the items in the sequence for anything.
And obviously, if there is no collection that is associated with the iteration at all, for ... in range(len(N)) is the only option, so as to not resort to i = 0; while i < N; i += 1 ...
Going by the comments as well as personal experience, I say no, there is no need for range(len(a)).
Everything you can do with range(len(a)) can be done in another (usually far more efficient) way.
This is one of the only times you might consider using range(len(a)).
Clements answer (as shown by Allik) can also be reworked to remove range(len(a)):
So, in conclusion, range(len(a)) is not needed.
Sometimes matplotlib requires range(len(y)), e.g., while y=array([1,2,5,6]), plot(y) works fine, scatter(y) does not.
One has to write scatter(range(len(y)),y).
I can't think of a solution that does not use the range-len composition quickly.
If you have to iterate over the first len(a) items of an object b (that is larger than a), you should probably use range(len(a)):
It is a binary adder but I don't think the range len or the inside can be replaced to make it smaller/better.
Some people said that for i in range len(a) is for beginners,but what if I want to access to the element and the indices simultenously.
Use Range("RaceDrop").Value to indicate the actual value of the cell.
Most of the time Range("RaceDrop") = will work but it is best to always explicitly say .Value
I am not entirely sure what you are trying to do with the Cells(1,1) part of your code, but if you are looking to find the top left value in the range, try something like the below code
If the cells you are referring to are named Ranges of only a single Cell you should be able to use just
Normally, I don't have to specifically type the sheet that the data is on, because the tables work globally (usually I just have Range("Table") and it works regardless of where the code is at because it always knows where to refer to) however.. it seems that since I'm trying to copy data from a table into a table on another sheet, it doesn't work that way, and needs the Sheets("") to be defined.
just a reminder, plt.hist(range=[low, high]) the histogram auto crops the range if the specified range is larger than the max&min of the data points.
So if you want to specify the y-axis range number, i prefer to use set_ylim
If the starting cell of the range and of the key is static, the solution can be very simple:
... with setting the values of dateRangeStart and dateRangeEnd earlier in the picker event handlers:
Actually I can already break this reproduciblly on my machine using IntStream.range(0, 10000).parallel().boxed().sorted((a, b) -> -1).forEachOrdered(System.out::println);
The literal of int 9223372036854775807 is out of range.
"out of range" is pretty clear: something is not within the expected range (probably that of int)
The problem is [that "some digits" is defined to be an int literal (hyper-link)] and therefore must be in the range defined by int.
Side note: you'll realize that there are no byte or short literals and you can still assign values (usually int literals) to byte and short variables: that's possible due to special rules in [§ 5.2 about Assignment Converson (hyper-link)]: they allow assignment of constant expressions of a larger type to byte, short, char or int if the values are within the types range.
That's easiest to implement and fast enough unless you have millions of ranges (and maybe even then).
When looking for a range, find the range where start <= position.
The number is in the range if position <= end.
Since the end of any range is guaranteed to be smaller than start of the next range, you don't need to care about the end until you have found a range where the position might be contained.
All other data structures become interesting when you get intersections or you have a whole lot of ranges and when you build the structure one and query often.
A balanced, sorted tree with ranges on each node seems to be the answer.
If the total range of numbers is low, and you have enough memory, you could create a huge table with all the numbers.
For example, if you have one million of numbers, you can create a table that references the range object.
32 or 64 minus whatever power of 2 your ranges were based on).
According to [the documentation (hyper-link)] the onChange callback receives the ranges as an argument:
This would be equivalent to range starting at row 4 and ending in whatever column is Activecell, but row 6.
range(1, 75) represents the numbers 1..74.
It's a bit silly on a range object, but you could do it:
enumerate(bar) is essentially just zip(range(len(bar)), bar).
put this code this will clear your IndexError: list index out of range.
It's not possible with the built-in [range (hyper-link)]:
So you can quickly hack together a solution by counting, converting to base 26 (which uses the digits 0 to 9 and a to p) and then "translating" the digits to the range a to z.
copied from [http://php.net/range (hyper-link)]
You could ofcourse write your own function to do this as it seems that the range() function in php doesn't support this.
This should be an easy job, since you can just nest the range function in another loop.
With this I can get the range using any value for the start and end.
Use this recursive function to get the exact range from A to ZZ
not sure what that's called) of Range().
The following can be called with any range as parameter:
You only need a single line of code to set the border around every cell in the range:
Range("A1:F20").Borders.LineStyle = xlContinuous
This should be able to handle contiguous and non-contiguous ranges for A and B.
this will work with contiguous range:
If the outer range really is enclosing then you can use CurrentRegion
Each object of Range type has property Areas that contains the collection of its subranges.
If you want to specify two ranges, you can always group them with parentheses common_pattern(pattern1|pattern2).
The second is that there's a strange .
And the third is that you do not specify a range of numbers, but a range of characters.
A range of characters to get all possible (integer) numbers would be [0-9]*.
What you want is an optional 2 followed by a character from the range [1-5].
You should read up on what lists and ranges are and mean in Regular Expressions because you misused both of them!
As for the rest of the pattern, if 1-5 and 20-25 is literally what you want, matching 1-5 is done with a character class (which you now are familiar with ;) like [1-5] meaning match any character in the ASCII range between the characters 1 and 5 inclusive.
[range() (hyper-link)], however, returns an immutable sequence.
First, range is a type.
An instance of range is not an iterator, because range.__next__ is not defined.
An instance is iterable, though, because range.__iter__ is defined, so you can get an iterator with, for example, iter(range(3)).
range.__next__ is not defined, but range_iterator.__next__ is.
An instance of range represents a bounded sequence of integers, without actually being a bounded sequences.
As such, you can have multiple independent iterators over the same range.
range.__reversed__ yields an iterator like range.__iter__, but going in the opposite direction.
The CMake command [target_compile_features() (hyper-link)] is used to specify the required C++ feature cxx_range_for.
Maybe your C++ program uses other C++ features than cxx_range_for.
Setting this command activates the C++11 features for the compiler and after executing the cmake .. command, you should be able to use range based for loops in your code and compile it without any errors.
I missed, that i have to add the from parameter to the range aggregation.
Any time you call Range or Cells or Rows or UsedRange or anything that returns a Range object, and you don't specify which sheet it's on, the sheet gets assigned according to:
You qualify the Range reference, but the Cells reference is unqualified and is likely pointing to the Activesheet.
Note that you can run this any number of times and it will simply overwrite the existing named variable "workRange" without any problems.
To build it up as a series of non-contiguous ranges you simply use the above but append the additional ranges on to the string with commas like this:
What this is doing is taking a number i in range(1,3) #[1,2] and then print i * 0.01 2**i number of times which I believe is what you are trying to do.
If you want to sum a range beginning elsewhere, you can use [Skip (hyper-link)]:
If the ='blad1'!grafiekrange gets the right Chart data, then put the following macro into a module:
Now, if the chart data and the named range data has changed, select the Chart and press [Ctrl]+[Shift]+[D] or run the macro setSelectedChartSourceData in another way.
And in the worksheet I have a few named ranges of which the grafiekrange is used now.
this named range has this formula:
This will soon or later cause strange issues and is a very bad practice.
When you define a range and assign it to a range object then it refers to the sheet which was active at that time.
This way you do not need to use .Select/.Activate to work with the range object.
You may want to read up on [Range.Address property (Excel) (hyper-link)]
It shows you the "Parent" sheet of that range :)
selects the range someRange and returns the boolean value True (you usually don't notice that because you don't try to assign it to something).
both name_task and name_task_2 are booleans (True) and not ranges.
since you didn't specify what name_task is (other than Variant, which basically means nothing), vba will use the range's Value as default property and name_task will be a variant array containing sht1.Range("A8:B8", sht1.Range("A8").End(xlDown)).Value.
To assign a range object you need to use Set:
If you declare Dim name_task As Range VBA will tell you that something is wrong at the right line and troubleshooting becomes much easier.
It wouldn't allow the use of an r-value expression that computes a range.
So you don't need to stick the range into a variable to make it work.
If you want live feedback as the range changes without waiting for mouse release, you could listen oninput
returns a copy of this range clamped to the given limiting range.
One more variant using extension and argument name range
This extension uses Range and ClosedRange
ranged:
You need to test two conditions to determine if two ranges overlap.
Added:
To picture why this is the condition, [image] consider a base range (range_1, shown at the bottom of the diagram), and then think of all the various other possibilities for date_range_2.
Using the diagram, look at the conditions above for each of the ranges shown, and you'll see why it works.
This is because in range(2,2) there is no number!
With a range as small as that you could just keep a list of every port and set flags for which are open & closed, and print out the results.
The Range::Object set of modules is very comprehensive, and [Range::Object::Serial (hyper-link)] does exactly what you're looking for out of the box
It doesn't matter which one is a character and which one is a range.
Range("A1").End(xlDown) returns the [default property which is Value (hyper-link)].
So for example, your current range is A6:A9, if A9 has the word Test in it, your line becomes:
Set Supplier_Names = ws_Temp.Range("A6", "Test").
You can use the [Address (hyper-link)] property of Range to return the cell address that is found.
Set Supplier_Names = ws_Temp.Range("A6", Range("A6").End(xlDown).Address)
Set Supplier_Names = ws_Temp.Range("A6", "$A$9")
[http://www.cpearson.com/Excel/ArraysAndRanges.aspx (hyper-link)] is a great resource for learning about this method of using Arrays with the Worksheet.
I've introduced another range object to make it more readable:
Quite strange~
Set rSub = .Range(.Cells(1, 1), .Cells(3, 3))
When I removed the dot before Range I got the result as we expected
Set rSub = Range(.Cells(1, 1), .Cells(3, 3)))
I think that the .cells(3,3) inside the parentheses is resolving to an address, which basically acts like an offset inside the range.
The line  Set rSub = r.Range(r.Cells(1).Address) is equivalent to:
Set rSub = r.Range("A2") which resolves to "A3."
You can use addresses inside a range definition this way.
You need to test if the start of your smaller range is greater or equal to your larger range's start AND if your end of your smaller range is less than or equal to the end of your larger range:
If you don't want to include the endpoints of the range simply change <= and >= to < and > respectively.
You can use range and array_intersect, i.e.
With range we create 2 arrays containing numbers based on the 4 variables (start, end), then we use array_intersect to check if the 2 arrays have numbers in common, if the output is not empty, we know the numbers (time) overlap.
If you are just checking whether any part of the offer overlaps any part of the range, it's simple.
If you wanted to also include ranges that intersected at a point, you would need to use <= and >= instead.
It's a strange construct even to seasoned Python coders.
You can check if the Adress of your Intersected Range is the adress of your group-range.
If it is, it lies completely within your type-range:
Application.Intersect(Range(NamedRange.NameLocal), Range("Type")) is not nothing if any part of the two ranges overlap - to prove that one is contained within the other, you should check that namedrange does not overlap with the ranges above, below, to the left and to the right of Type.
So add  more if statements testing intersect with appropriate ranges - so (if Test is fixed) something like
If Test is variable then The range at the top would be
The [range() (hyper-link)] function in Python has 3 parameters: range([start], stop[, step]).
built-in range function), the performance should be the same.
In your code rangenum is the problem,
try this
Yes, step in range has fixed size.
Guard using Range:
Here's another way to match using a range:
Another option would be to actually add this to the language using implicits, i added two variations for int and Range
You also need to remember that the stop value in a range is not included, so to get the numbers 1 - 5 you need to add 1 to the stop parameter:
EDIT: use >= if the border ranges count to overlapping
Not sure if it is what you want, but you can exit the sub with the following code if the target is not inside the B10:H13 range:
In order to do this you'd have to modify code on both the client to send the modified header and the server to read from the "Range" header instead of the querystring.
HTTP Range is typically used for recovering interrupted downloads without starting from the beginning.
Absolutely - you are free to specify any range units you like.
3.12 Range Units
HTTP/1.1 allows a client to request
  that only part (a range of) the
  response entity be included within the
  response.
HTTP/1.1 uses range    units
  in the Range (section 14.35) and
  Content-Range (section 14.16)
  header fields.
An entity can be broken
  down into subranges according    to
  various structural units.
The only range unit defined by
  HTTP/1.1 is "bytes".
HTTP/1.1
  implementations MAY ignore ranges
  specified using other units.
But, as you can see from the 'other-range-unit' bit, you are free to come up with your own token specifiers.
Coming up with your own Range specifiers does mean that you have to have control over the client and server code that uses that specifier.
So, if you own the backend piece that exposes the "/document/content/http-range-question" URI, you are good to go; presumably you're using a modern web framework that lets you inspect the request headers coming in.
You could then look at the Range values to perform the backing query correctly.
Furthermore, if you control the AJAX code that makes requests to the backend, you should be able to set the Range header yourself.
If you are using a custom Range unit, any caches between your client and the origin servers "MAY ignore ranges specified using [units other than 'bytes']".
: /document/content/http-range-question/page/1.
I don't understand how you're looping by 'person1's range, then by person2's ranges' - I'm not sure what that means without seeing the code.
I can't see how you would get better than O(n), but you can iterate through the range only once.
Sort the starts and ends of the ranges.. keeping information alongside as to whether its a range-start or finish... for your example you'll get this:
If you increase it from 1 to 2 this is a start of an overlapping range.. the end of the overlapping range will be when you decrease the counter from 2 to 1
If the ranges for each person are sorted this method can be adapted to compute the overlaps very easily.
If your ranges are known to be non adjacent (i.e.
if there is always at least one number between to consecutive ranges).
Else you might need an extra compaction step to ensure that adjacent ranges will be put into one range.
The nice thing is that this works for any ordered type and not just ints, and you can intersect any number of ranges very fast ( O(n+m) ).
Note that the inputs and outputs, except for the angle in degrees, are in the range of 0 to 1.0.
Note that this algorithm uses 0-255 as it's range (not 0-360) as that was requested by the author of this question.
I created a possibly faster implementation by using 0-1 range for RGBS and V and 0-6 range for Hue (avoiding the division), and grouping the cases into two categories:
For 0-255 range just * 255.0f + 0.5f and assign it to an unsigned char (or divide by 255.0 to get the opposite).
You can say that a range would not get affected by the new range if:
Either the range finishes before the new range starts.
The range starts after the new range ends.
Based on those conditions, you can have a function that says whether a given range is safe or not;
By, safe I mean whether the newRange and existingRange would overlap or not.
Here is how you can use filter() to filter out the overlapping ranges:
You could filter by checking the range.
The result contains only ranges who are overlapping the given range.
This happens because your insert macro changes the range your named range formula refers to, just like it would any normal formula.
any formula, including the named range formula, that referes to a cell on or below row 10 will be updated to refer to a cell one row down (ie $L$11 in this case)
You can fix this by changing your named range formula to this
If my_range is not sorted, step #1 is my_range.sort_by(&:first).
[http://www.dba-oracle.com/t_interval_partitioning.htm (hyper-link)] says you can change range to interval and back again by using the alter table syntax
I would use [Range#min (hyper-link)] and [Range#max (hyper-link)]:
With regard to your comment below: if you'd like to access a range of the CharacterView, you could easily implement your own extension of CollectionType (specified for when Generator.Element is Character) making use of both prefix(_:) and suffix(_:) to yield a sub-collection given e.g.
a half-open (from..<to) range
To concretely demonstrate how to traverse through a range in a string in Swift 4, we can use the where filter in a for loop to filter its execution to the specified range:
iterateStringByRange("string", from: 1, to: 3) will print t, r and i
it uses Boost Range traits (range_mutable_iterator<> etc.)
This allows things to work with other ranges (e.g.
the user-defined converson operator uses boost::copy_range<> for similar reasons
I'm not sure what do you mean by "dynamic arrays", in any case, if not iterating over static arrays, informally, the compiler looks up the names begin and end in the scope of the class of the object you iterate over, or looks up for begin(range) and end(range) using argument-dependent lookup and uses them as iterators.
For more information, in the C++11 standard (or public draft thereof), "6.5.4 The range-based for statement", pg.145
According to the latest C++ Working Draft (n3376) the ranged for statement is equivalent to the following:
This class template can then be used to create a range, over which you can iterate using the new ranged for syntax.
How does the range-based for work for plain arrays?
Is that to read as, "Tell me what a ranged-for does (with arrays)?"
The above example loops through ia by it's primary 'range' ([3]), and therefore loops [3] times.
Specifically in your case (subsequent range is inside previous one) you may use this code:
Otherwise (ranges are intersect) try this code:
Do not use Resaize as that will resize the range to that size not add rows.
Also remember that assigning parentage to all range objects is important so VBA is not defaulting to activesheet.
You can replicate the match in your VBA to count before using the range how many rows you would have, or you can use error handling:
Here is a function I knocked up to return whether a named range exists.
Within your main procedure, all you need to do is do an existence check before using the range
It also becomes much simpler to check whether any named range referring to a valid address exists, without using error handlers in this simple application.
Ranges use <=> to determine if an iteration is over; 5 <=> 1 == 1 (greater-than), so it's done before it starts.
Even if they didn't, ranges iterate using succ; 5.succ is 6, still out of luck.
A range's step cannot be negative, so that won't work either.
It returns the range because each returns what it was called on.
This doesn't even really have anything to do with Ruby, it's just simple basic math: the range which starts with 5 and ends with 1 is empty.
You can easily extend the [Range (hyper-link)] class, in particular the each method, to make it compatible with both ascending and descending ranges:
Change RefersTo:=Range1 to RefersTo:=Range1.RefersTo
But this will only work if you change the range to a name:
You want to join tblUnit with tblPriceRange matching rows where the ranges overlap.
Two ranges overlap if the begin of the second is before the end of the first and the begin of the first before the end of the second, so your join condition would look like this:
Both bounds of the range are inclusive.
The first-byte-pos value in a byte-range-spec gives the byte-offset
     of the first byte in a range.
The last-byte-pos value gives the
     byte-offset of the last byte in the range; that is, the byte
     positions specified are inclusive.
Examples of byte-ranges-specifier values:
I'm not sure why you expect range would remember that it had been called previously.
Each call to range(x) returns a new range object that provides numbers from 0 to x-1 as you iterate over it.
To get the behavior you are describing, you need to reuse the same iterator for the range object in each loop.
I wrote this code on another forum some years back as a quick method to add a Subtract Range option, the same approach I used in [Fast method for determining unlocked cell range (hyper-link)]
This function accepts two ranges, removes the cells where the two ranges intersect, and then produces a string output containing the address of the reduced range.
If the Boolean variable, bBothRanges, is set to True, then the process is repeated with the cells with the opposite range order,
the code then returns the "reduced" range as a string, then closes the WorkBook.
In your case the code runs the bBothRanges option and then checks if the RemoveIntersect returns vbNullStringto see if the ranges are the same.
For very short ranges as you have provided, a simple cell by cell loop would suffice, for larger ranges this shortcut may be useful.
To generate odd numbers: (range 10 :min 1 :step 2)
I've assumed that what is really needed is the analogue to Python's range generator function.
Here is a range function to generate a list of numbers.
CL-USER 23 > (range 0 10)
CL-USER 24 > (range 10 0 -1)
CL-USER 25 > (range 10 0 1)
CL-USER 26 > (range 1 21 2)
CL-USER 27 > (reverse (range 1 21 2))
Needed to implement (range n) in a [tiny Lisp (hyper-link)] that just had dotimes and setq available:
.. and ... denote a range.
The [documentation for Range (hyper-link)]† says this:
Ranges constructed using .. run from the beginning to the end inclusively.
Note that, while to_a on a Range of integers gives a collection of integers, a Range is not a set of values, but simply a pair of start/end values:

†The docs used to not include this, instead requiring reading the [Pickaxe’s section on Ranges (hyper-link)].
Ranges constructed using .. run from the beginning to the end inclusively.
-- [http://ruby-doc.org/core-2.1.3/Range.html (hyper-link)]
But really the ranges differ on a [real number line (hyper-link)].
It just seems boost::range doesn't have support for it out of the box, but you can
implement a number-like object whose operator*() would return a number, and use that as an iterator for range
Just to add to the other answers if you're coming from a C++11 perspective - if you'd rather use modern for-each loops, you can do this even more cleanly with [boost counting_range (hyper-link)]:
You can easily query Range to check if an existing range overlaps with the given range.
range.rb
There is no range function in Go.
There is only the [range keyword (hyper-link)].
But there is no difference between range x and range(x).
Want a range that starts with something other than 1?
It generates integers in the range of [0, @max].
All other answers are good, however they all have speed issues for larger ranges because they force MySQL to generate every number then filter them.
The [documentation (hyper-link)] of rangeOfComposedCharacterSequencesForRange: say
The range in the receiver that includes the composed character sequences in range.
This method provides a convenient way to grow a range to include all composed character sequences it overlaps.
as the location is valid it is considering that the range overlap the character at this location
The implementation of rangeOfComposedCharacterSequencesForRange: just calls rangeOfComposedCharacterSequenceAtIndex: twice, with the start and end indexes of the range, and returns the combined range.
The documentation does not explicitly state that the characters at the edges of the provided range are never included but I agree that the observed behavior feels wrong.
To define the CopyFrom you can use anything you want to define the range, You could use Range("A2:A65"), Range("A2",[A65]), Range("A2", "A65") all would be valid entries.
I added the Copy from range, and the Resize property to make it slightly more dynamic in case you had other ranges you wanted to use in the future.
This is what I came up to when trying to copy-paste excel ranges with it's sizes and cell groups.
'**
'Copies a table from one place to another
'TargetRange: where to put the new LayoutTable
'typee: If it is an Instalation Layout table(1) or Package Layout table(2)
'**
'**
'Receives the Pasted Table Range and rearranjes it's properties
'accordingly to the original CopiedTable
'typee: If it is an Instalation Layout table(1) or Package Layout table(2)
'**
You can do something like below to paste values in other ranges.
Turns out, ranges do not have to be initialized but can simply be created as follows:
In this case, the code would be fixed by replacing Range<Index>(start..<self.endIndex) with:
In Swift 3, additional range types were introduced, making a total
of four (see for example [Ole Begemann: Ranges in Swift 3 (hyper-link)]):
and, as a consequence, various conversions between the different
range types have been removed, such as the
initializer of struct Range.
All theses changes are part of the
[[stdlib][WIP] Eliminate (Closed)CountableRange using conditional conformance (#13342) (hyper-link)] commit.
Another option is to use a one sided range
(introduced in Swift 4 with [SE-0172 One-sided Ranges (hyper-link)]):
let range = startIndex ..< characters.index(startIndex, offsetBy: 1)
let range = start...end
You can't use them with "Range(".
The goal is to copy the data (values only) to the column range starting in cell AH5 in another workbook.
sRng = .Range("B2:B5"), tCell = .Range("AH5") the values can be copied like this:
[code snippet]
You could use standard html5 input with type range.
I switched to Powerange, since the IOS styles of the handle will not overlap the track.
Get range value using  $("#amount").val() and then make your request to get required response with this value.
Set the range from C3 to Last Row & Last Column
Set Rng = .Range(.Cells(3, "C"), .Cells(LstRw, LstCol))
Put the formula in that range
You are getting the error because you are not fully qualifying your ranges.
You have to set the units of the range values like so:
The Python 3 range object defines the following rich comparisons (taken from the [C source (hyper-link)]):
Use [date_range (hyper-link)] for the index:
A RangeIndex is automatically created for your data, instead of you having to take care to assign the correct index to the row you are appending at each iteration.
The [Selection (hyper-link)] property is the cell or range of cells in the current selection.
You can simply use Selection in VBA to reference the range that you actually have selected :
I have assumed that the ranges in the array are ordered in the sense that the end of each range is not greater than the start of the next and the start of each range is not less than the end of previous.
I chose valid_range.
Though with this your currently existing ranges aren't valid since 4000..5000 is part of the 3000..4000 range.
A solution to this would be to use ranges with three dots instead.
If the first number of the range is included in any range;
If the last number of the range is included in any range;
If any range is included itself in the selected range.
And as I commented 5000..6000 will be in conflict because there is a range with 5000 and other with 6000.
method that show if 2 ranges are overlaped (this can be do at model level)
Then I define an invalid_range method that returns true if the range is invalid for the set:
Edited: change invalid for invalid_range because it isn't AR compatible.
We don't need to check for inclusion of ranges in Ruby, just check the boundaries.
Instead of Range("rgFound") it is just rgFound.
This variable is a reference to the found range.
Also note that for the [Range.Find method (hyper-link)] you need also define the LookIn, LookAt, SearchOrder and MatchByte parameters.
Also, if you've been given the range and can only iterate over it once, you can use [tee (hyper-link)] and [islice (hyper-link)]:
Since your subRange map is sorted, you can iterate over it and check that there is no gap in the sequence of end to the next start.
Apply this check recursively to all subRanges, too.
Another way to do it is to do the sum of all the ranges and compare it to the delta of the maximum and minimum values across all ranges.
range filter is one of them
For getting more clear go to our [blog (hyper-link)] and see How to disable thumbs while dragging in RangedSeekBar section.
I ran into the same problem (you have provided an out-of-range value) when using a number state with a default value of -1:
A null date won't be coerced to a date that isn't within the range of the SQL DateTime type the way a default value would.
for the associated object properties or EF will pass in DateTime.MinValue for unassigned values which is outside of the range of what the SQL datetime type can handle.
If it doesn't run then try deleting the named range and creating a new one.
Kindly use the below isNameRngExist function which will return true when the name range "DrugCodeInventory" exist and then you can proceed with further manipulation.
The easiest way for this would be to parse the string as a number and look for the number to be in the proper range.
And another one that specifies what range of digits is allowed for each digit in a three-digit number.
which just alternates for each tricky numeric range there might be.
I would break down the ranges so that it can easily be specified in separate individual regex:
If you need the two digit range, it's just a matter of adding [0-9][0-9] to the regex.
The recently released rgxg command line tool generates regular expressions that match a specific number range:
Directly use the .Copy and .PasteSpecial methods with a range (reducing four lines of code into one):
Range("O" & (34 - x) & ": V" & (34 - x)).copy Range("O" & (35 - x) & ": V" & (35 - x))
Assign the values of one range to another range:
Range("O" & (35 - x) & ": V" & (35 - x)) = Range("O" & (34 - x) & ": V" & (34 - x))
You can even write a range function to go along with this:
I don't think you will be able to use the range operate to do this.
range selector
Current play position travels on the rangeselector after user clicked "play".
FFMPEG is best option 
if you are facing problem to compile ffmpeg use this link [https://github.com/WritingMinds/ffmpeg-android (hyper-link)]  and follow commands from 
[https://github.com/antpersan/CutVideoAndroid (hyper-link)] and for range Seekbar [https://github.com/anothem/android-range-seek-bar (hyper-link)] or use shanrais suggested VideoSeekBarView
this solution I have tried it's working perfectly this example includes the custom RangeSeekBarView , custom ProgressBarViewwith seekbar where you can select the video range of video you want trime and save to the destination
This error message clearly mentions that ruby was unable to convert your range into integer.
I don't know of any documentation for what specifically Kernel#rand expects from a Range argument but we can get a look at what's going on by overriding respond_to?
To add a bit more to @mu-is-too-short's answer, I checked the source of Random#rand and the following is the current implementation logic for rand(Range):
Get the begin, end, and vmax from the Range object ([call range_values (hyper-link)]), where vmax is computed as ([call id_minus (hyper-link)]): 
[code snippet]
vmax will be used as the upper bound of the random number generation later.
The Range.Select method will only work, if the sheet, where the range belongs, is active.
The Rng range may not be on the Sheets("LAX Data") and by calling Rng.Select while another sheet is active, you run into error.
You set the range to
Set Rng = ActiveSheet.Range("B101") 'Note: this can be any sheet.
The range object stores its position along with the sheet it is from, as a file is defined by a full/absolute path.
If you want to reference range "B101" on sheet "LAX Data", you should replace Rng.Select with Range("B101").Select.
this way you will not try to select range which is not on ActiveSheet (which is the reason for an error).
[Correct usage of Range and Cells objects (hyper-link)]
You have to delete range variable to get built-in function back but not give it a none.
Anyway, depending on the return values of these looping constructs is... a strange approach.
For ranges it's simple: x..y defines a range from x to y inclusive and x...y defines a range from x to y exclusive.
The code below will search column C of the range B5:D10.
Because the searched range starts on column B - then column C is the third column, which is column D when looking at the whole worksheet.
Similarly you're counting rows within your range.
If worksheet cell D7 contains the word Yellow then it will return i=3 as that's the third row in your range.
Also I am assuming LastRow tells you what row is the bottom row of your copy range.
Assuming 'input' contains the input, the following code will return true if any numbers are missing from the range:
The Swift String method rangeOfString() returns an optional Range?
And if you replace the NSString method stringByReplacingCharactersInRange()
by the Swift String method replaceRange() (or in this case
simply by removeRange()) then you can work purely with Range<Swift.Index>
without converting it to NSRange or Range<Int>.
For people like me who really want to get a Range<String.Index>:
You do need to reference the string where you'll be using the range.
Swiss-army steam shovel for String subscripting, NSRange, Range<Int|String.Index> conversions
In Swift 2, given string: String and nsRange: NSRange, this is
Convert NSRange to Range<String.Index> swift function
I'm not familar with ckeditor in particular, but regular javascript allows you to select text using a range so I don't think it's adding anything special.
Once you have the element you need to find out which character within the element was clicked, then create an appropriate range to put the cursor there.
This page is a bit dated, but has a good discussion of ranges: [http://www.quirksmode.org/dom/range_intro.html (hyper-link)]
Ranges can't tell you their positions on the page, so you'll have to use another technique to find out what bit of text was clicked.
It seems that after mouse click/focus event and redraw (setTimeout ms 0) document.getSelection().getRangeAt(0) returns valid cursor range.
TinyMCE moves caret to start on initialization, so I create special span 'caret' element at current range start and later force editor to select it, then remove it.
Where .r, .g, and .b have range 0 to 255.
Otherwise: .a has range 0.000 to 1.000.
And version with # and color ranges checking
I read about Range and you can use cell in range like this:
range(a, b-1, -1) is a list (in Python 2) that goes from a to b-1 (not included), by steps of -1.
You can try to do, in a Python shell, print range(10, 5, -1), for instance.
You can also check the output of range(5, 11, 2), to understand better what range() does.
You are trying to reimplement boost::iterator_range and boost::counting_iterator.
There even exists a boost::counting_range already: [http://www.boost.org/doc/libs/1_47_0/libs/range/doc/html/range/reference/ranges/counting_range.html (hyper-link)]
As Rachel indicated... this should do the trick assumes your named range is defined as namedRange:
Resize to increase the columns included by 1, then offset the entire range by -1 column to get your neededRange.
Use arrays: Read the source range into an array SrcArr = SrcRng.Value and use an array for output ReDim DestArr(1 To SrcRng.Cells.Count, 1 To 1) As Variant.
All Ranges and Cells need to be qualified.
So sh3.Range(sh3.Cells(...
And as input[type=range] is very poorly supported, I will recommend using jQuery UI slider and the way of attaching labels found [here (hyper-link)] in answer.
I put together a demo that uses a range input with corresponding <p> tags that act as both labels for the current state of the slider, as well as triggers to change the slider's value.
Also worth nothing, if you're interested in showing the current value as a label/flag to the user, (instead of many) there's a great [article by Chris Coyier (hyper-link)] on value bubbles for range sliders.
Its a jQuery slider plugin for range inputs.
This code does not need jQuery nor CSS and should work on any browser that supports the range input type.
If you are handling only non overlapping ranges operations will simply be more efficient, but there's no drawback in using them, although they can handle the general case.
As for programmatically protecting a range no.
However, you could protect a sheet, does not need to be in the same spreadsheet and then create an onEdit trigger that would replace any change in your "protected" range with the original source data.
Every time a change is made to the spreadsheet the script will rewrite the data in the sheet for the range you specify.
Then create a template sheet, protect the ranges in it manually and send a copy of the template.
According to [Control protected ranges and sheets in Google Sheets with Apps Script (hyper-link)], posted on February 19, 2015, now is possible to protect a Google Sheets range.
Access and modify protected ranges and sheets.
A protected range can
  protect either a static range of cells or a named range.
Firefox: ::-moz-range-thumb and ::-moz-range-track.
It's not limited in range other than memory and storage.
It adds joins values exponentially on each iteration so it's very fast even for very large ranges.
It's handy for date and time ranges as well:
So for example to create a record for every minute on a time range in a table you could do something like:
Both versions can easily be extended with a WHERE clause, limiting the output of numbers to a user-specified range.
Like Brian's answer, focusing on filtering to the range is important from within the query; a BETWEEN still tries to generate all the initial records prior to the lower bound even though it doesn't need them.
If we know the range we want, we can specify it via @Upper and @Lower.
If you want to increase the range, you can continue to add additional joins with progressively higher orders of magnitude, so long as they're ordered from most to least significant in the FROM clause.
Edit:
I realized that the original question was to get a range from x to y.
My script can be modified like this to get a range:
It doesn't reference any tables and returns an unsorted range of up to 1048576 values (2^20) and can include negatives if desired.
It runs pretty quickly, especially on smaller ranges.
The  method to resize a "Named Range" is different if it is a "normal" named range or a "Table" (ListObject) range.
For the case of a named range, you change the scope like this (i.e.
You can then use the list table's .DataBodyRange to access the table data only.
you're basically saying: "Set my key 'i for i in range(1, 11)' to True" and "i for i in range(1, 11)" is not a valid key, it's just a syntax error.
You can make a new [range (hyper-link)] with the same start and end, and pack all steps to a new list.
Now on each number from the range you can check if it matches [any (hyper-link)] step.
However, the steps of the ranges skip some values in this sequence.
Storing the selected range is simple.
The following will return only the first selected range (Firefox at least supports multiple selections):
range will have properties startContainer (the node containing the start of the range), startOffset (an offset within the start container node: a character offset in the case of text nodes and child offset in elements), endContainer and endOffset (equivalent behvaiour to the start properties).
Range is well documented by [its specification (hyper-link)] and [MDC (hyper-link)].
In IE, range will contain a TextRange, which works very differently.
Rather than nodes and offsets, TextRanges are concerned with characters, words and sentences.
This DateRange is evaluated in a lazy way.
Feel free to construct a date range of 5000 years.
And to include the last date within the range:
If you can use boost, then a nice option is [boost::irange (hyper-link)]:
services21-35 is not a valid range name: I can't create that name because it contains a -
A couple of problems, Dim ColLetter As Range should really be Dim ColLetter As String, your string concatenation is wrong, change Range("Notes_Start:ColLetter" & lastRow) to Range("Notes_Start:" & ColLetter & lastRow)
I'm not familiar with the Range("Notes_Start:..." syntax, but I believe that you could use Range("Notes_Start").Offset(lastrow,Col) to get what you're after.
Another option that came to my head is to use a filter, so you don't have to pollute your controller with Range.
Andy's solution is great, however the range cannot go backwards.
I modified it to include the last value in the range:
My range slider shows in all browsers now.
As your targeting a range of E2:E4 you would need to specify the cell locations.
EDIT: If you're setting up named ranges to change dynamically then you don't need VBA.
Enter this directly into the named range in Excel and leave it to auto adjust automatically between E2 and whatever the last item is (assuming no blanks).
[fieldselection (hyper-link)] is a very usable jquery plugin for selection/range manipulation.
Take a look at [IERange (hyper-link)]:
IERange is a feature-complete
  implementation of W3C [DOM Ranges (hyper-link)] for
  Internet Explorer, allowing users to
  write one cross-browser version of
  their range manipulation code.
Supports Range APIs:
document.createRange()
compareBoundaryPoints(), cloneRange(), createContextualFragment(), toString()
Range support (Webkit-style)
addRange(), removeAllRanges(), getRangeAt(), toString()
I've written a new range/selection library called [Rangy (hyper-link)] that is similar in concept to IERange but goes quite a lot further.
Lets forget the range function for now.
Now the range functions stops stepping before (<) the 2nd paramater.
To set your range make sure you've included "With" before you start ".
To answer your question, with range = Sheets("sheet").Range("A1") you are assigning a value variable, not an object.
Therefore the default variable of the range object is implicitly assigned, which is value.
Edit: If you are using named ranges, try RangeObject.Value2 instead of RangeObject.Value.
Named ranges do not have a Value property.
I don't think so...  even if you select a column manually while in the Range Name selector, it complains.
That would be a nice feature and it would make sense since they support column ranges for formulas already.
I have a range name of "Sheet1!A10:AW10" with no problems.
if you make more cells later, you need to manually add to the range name.
I had the same problem with ranges such as A3:A which normally work in other places such as ARRAYFORMULA(), but the workaround is to not specify the starting row, such as A:A.
Update2: I didn't notice that google spreadsheet replaces ranges like A:A to A1:A50, so new rows added later on do not still get included.
I think it's a helpful tool to use Insert -> Define new range to make a wizard appear and make the syntax correct.
See how I added an id called euroRange to my ion-range element.
Inside of the euroRage id I added .range-pin:after which means that whatever I specify should be done directly after the normal content of the pin.
So the main thing here is that the const value is the value selected on the range.
After that you can do whatever you want with it and just set the textContent of the range-pin to fix the text.
The Enumerable class already has a static method which will return a range of values for you - might be simpler to just use those semantics.
You need to traverse through the banned ranges and iteratively create the valid ranges while doing so.
The method could look like this (I assume that range contain integer numbers only):
This can help you remove a range from another, or from a set of ranges:
Example of removing multiple ranges from other ranges:
You don't need to select the range to delete it, just do .Range("A1:EC168").Delete.
I cheat by making a preparation for the range G23 to K27 fill with X1 to X25 in the first for i = 1 to 5.
You simply find its "minimum range" given an increment of .1 (tenth's place) or 1000 (thousands place).
Here min_price and max_price don't need to both be in the range at all times.
If you want to check if ranges have any common points you should use
If you want to check if user range is in all range you may use
Undefined behaviour for user_preice_low>user_price_high
You can get non-contiguous ranges via the Range() method.
To get a non-contiguous range excluding row 5:
The only way I can see to do this using cell row/col refs is to select each contiguous range via these and concatenate the resulting addresses, for example:
What I did was assign your named range to a variable (just for easier referencing).
Then using the Range() property, I used the 3rd and 200th row of your named range to set the range to look for blank cells.
The idea is that this will help you in the event your named range isn't simply an entire column.
It will get the relative 3rd and 200th row from your named range.
I've stumbled on a technique that I don't see presented as an option in any of the handful of "range-in-a-range" questions here.
I discovered you can ask VBA for a range of a range directly.
I have formatted some data as a Table, but it could be simply a Named Range, or even an unnamed range I suppose.
My Table is named SummaryBand, which due to a previous step was not necessarily always in the same absolute position on the spreadsheet, but I wanted an absolute Range within SummaryBand.
This [runs (hyper-link)] because a reference to an array of N ints is passed in the function and (unlike pointers) range for loops can iterate on those.
The range-based for statement in fact uses the same expressions as standard functions std::begin and std::end They cannot be defined for pointers without knowing the size of the array.
use a proper range-style container, like std::array or std::vector
This will utilize only As Range which should help resolve the issue:
General solution for arbitrary range...
For some reason I had to put Range(Cells(6,361), Cells(6,361)).
The reason you received the run-time error is because Cell() is a range object in itself.
And it's always a good idea to qualify your range objects with your worksheet and even your workbook.
You need to split the ranges, parse the numbers and check them:
How can you get daterange1 = 0, since it's a range, i.e.
If you mean that daterange2 must fall ENTIRELY within daterange1, then
In Python2, range returns a list.
In Python3, range returns a [range object (hyper-link)].
The range object does not have an append method.
To fix, convert the range object to a list:
The range object is an iterator.
It purposefully avoids forming a list of all the values since this requires more memory, and often people use range simply to keep track of a counter -- a usage which does not require holding the full list in memory at once.
The advantage of the range type over a regular list or tuple is that a
  range object will always take the same (small) amount of memory, no
  matter the size of the range it represents (as it only stores the
  start, stop and step values, calculating individual items and
  subranges as needed).
Check [unutbu (hyper-link)]'s answer to know why you can't append to a range().
However, keep range()-s iterating approach by using itertools.chain() instead of forcing it to a list and appending to it then.
For example, with the below input, it outputs the range 99-100 instead of 3-50.
Make a map called rangeMap where the keys are ranges and the values are how many other ranges that range is part of (Integers)
For every range range in your list of ranges:


Create another map createdRanges, again mapping ranges to integers
For every entry in rangeMap

Define range2 and n to be the range and integer that entry holds
If range and range2 overlap:


Define newRange to be that overlapping part
Define newN to be n + 1, so we know that another range was overlapped by this one
Add newRange to createdRanges, with the value n + 1.
Otherwise, just continue the loop

Once you're done with that loop, go through every range in createdRanges.
If that range doesn't already exist in rangeMap, add that range and the corresponding number that says how many ranges it overlaps.
Otherwise, check if the value that is already in the map is less than the number of ranges this current range overlaps.
Finally, find the entry (or entries) in rangeMap with the highest value/number of overlaps, and return the key that maps to that value.
While this is extremely inefficient, if you're going to use it for a large number of ranges, you can optimize it to be less bad by removing ranges for which there exist ranges with more overlaps (or the same number) and are less restrictive, or somehow delaying calculation of ranges, etc.
Without knowing the contents of your range or seeing the other functions that you call (e.g.
Try this, you always have to use the set command with a range, otherwise you get an object or block variable not defined error.
A Range can take a string address starts with a column letter and is followed by the row index.
If Range has two parameters then the range extends from the first parameter to the second including all the cells in between.
Range("L3:Q10")
Range("$L$3:$Q$10")
Range("L3", "Q10")
Range("Q10", "L3")
Range(Cells(3,"L"), Cells(10,"Q"))
Range(Cells(3, 12), Cells(10, 17))
Range(Cells(10,"Q"), Cells(3,"l"))
Range(Cells(3, 17), Cells(10, 12))
Range("L3", Cells(10, 12))
Range(Cells(3, 17),  "Q10")
A Range will not accept a single cell as an argument (e.g.
Range(Cells(1,1)) is invalid)
The ranges and it's Cells arguments must be on the same worksheet.
The code below will work if Worksheets("manday") is the ActiveWorksheet because if a range is not qualified it is automatically assume to be on the ActiveWorksheet.
Worksheets("manday").Range(Cells(3,"L"), Cells(10,"Q"))
Worksheets("manday").Range(Cells(3,"L").address, Cells(10,"Q").address)
Worksheets("manday").Range(Worksheets("manday").Cells(3,"L"), Worksheets("manday").Cells(10,"Q"))
Use Set to set the return range
Because you havn't specified a Worksheet, your function will return a Range on the Active Sheet
It it can't handle the Range request then it should send the whole resource with a 200 status.
Multiple range headers are invalid, thus 400 would be a correct reply.
The Numeric Range Filter is deprecated.
According to the [Java API (hyper-link)], "This filter will be removed at some point in time in favor for the range filter with the execution mode fielddata."
I think "small" is relative to the full range of values for that field.
There is no minimum limit as long as in Content-Range: bytes a-b/c, a <= b, and c > b.
Here are the production rules for [Content-Range (hyper-link)]:
Consider using rangeSelect to have one control instead of two.
I don't know why the '+ 5' instead of '+ 7', but if I add 0, I get a selectable date range of the day I picked plus the next.
I didn't need to set a specific maximum and minimum date, just didn't want a date range overlap, so I just let them set each other:
This effectively 'bounces' the inputs around a shared input range of compatible days.
The goal of this is to always ensure that there is only a finite range of days (or months or whatever) between the the two fields.
Initial Idea from: [http://jqueryui.com/demos/datepicker/#date-range (hyper-link)]
After this, you just have to check if the number is in range:
Second argument (range) can either be a static ip such as 127.0.0.1 or a range like 127.0.0.0/24.
Btw, in case you need to check multiple ranges at once you can add few rows to the code in order to pass array of ranges.
Basically you want to divide the range into 256 equal portions, which is what that should do.
A range is an object, so you have to use "Set":
TIMESTAMPDIFF is used to determine the number of seconds in the date range.
Multiply this by a random number between 0-1 results in a random number between 0 and the number of seconds in the range.
Adding this random number of seconds to the lower bound of the range results in a random date between the data range bounds.
The (x)range solution is faster, because it has less overhead, so I'd use that.
In Python 2.x, use xrange instead of range, because xrange uses less memory, because it doesn't create a temporary list.
In Python 3.x, there is only range, which is the less-memory version.
Thus, in Python 2.x, iterating over a range(n) uses O(n) memory temporarily, and iterating over an xrange(n) uses O(1) memory temporarily.
Some quick timing runs seem to give the 2nd option using range() a slight edge over enumerate():
and just for fun using xrange() (Python v2.7.2)
I would favor readable code first, then using xrange() if available (i.e., Pre-Python v 3.x), followed by range() and enumerate().
I would say that as you aren't using the "_" attribute from the enumarate function then use range as it is more readable that way.
Assuming you're using Python 2.x, if you use len(), you should use xrange() as it will avoid creating a list of the numbers in the range.
Object variable 'SourceRange' is assigned without the 'Set' keyword
So a better SourceRange property would look something like this:
For those interested I solved this by setting the found range as the entire column.
Try incrementing a variable inside the range, only when it is equal to 1 matches the beginning of the range.
First I created an inverse function to xlrd.cellname() and then I proceeded with the function to get the values ​​of the ranges
Keep in mind that you only get linear ranges, don't create matrix
You can use this code to display the value of the range slider.
Converting range to array is a standard procedure in VBA.
In general, when you do it explicitly like this TimeArray = Worksheets("Data").Range("E1:E30").Value, VBA translates it to a 2D-array.
In the reproducible example I think what you need is seq and not range.
We can use outer to get difference between every element of rho1, rho2, get their absolute value and get the range.
Also, my script outputs slightly different ranges than your "expected output," specifically where two ranges abut.
Here's that modified version of the code that gives the weird behavior when ranges abut:
[range() (hyper-link)] is for generating arrays of consecutive integers
range() expects integer arguments.
If you want to know if x is inside this range try some form of this:
If you use range() it is excluded (range(0, 5) does not include 5!)
To check whether some number n is in the inclusive range denoted by the two number a and b you do either
use the replace >= and <= with > and < to check whether n is in the exclusive range denoted by a and b (i.e.
a and b are not themselves members of the range).
Range will produce an arithmetic progression defined by the two (or three) arguments converted to integers.
range is actually an immutable sequence type
class range(start, stop[, step])
The arguments to the range constructor must be integers (either
built-in int or any object that implements the index special
method).
For a positive step, the contents of a range r are determined by the
formula r[i] = start + step*i where i >= 0 and r[i] < stop.
For a negative step, the contents of the range are still determined by
the formula r[i] = start + step*i, but the constraints are i >= 0 and
r[i] > stop.
You might want to read the [documentation of range() (hyper-link)].
Here's a [tutorial about range() (hyper-link)].
range() now behaves like xrange() used to behave, except it works with values of arbitrary size.
If you want to do it for a range like 10.x.x.x, then do this:
You cannot match an IP range with [allow (hyper-link)], but you can emulate it with a CIDR notation:
Their Professional version has much more features like country blocking and IP range blocking, bulk csv uploading etc.
This will give a range from 1.2.0.1 - 1.2.255.254
There is no in-built solution for range picker, there are libraries out there which you can use to implement your requirement.
For example see this library : [https://github.com/oli107/material-range-bar (hyper-link)]
Seems like the syntax that you're using to create the named item (i.e., passing a string as the second parameter instead of passing a Range object) is making it so that the named item you're creating isn't actually a Range object.
Therefore, when you subsequently try to treat that named item like a Range object, you're getting an error.
Here's a code snippet that creates a named item for a range and then gets that named item (a range) and writes its address to the console:
Range-based for is obviously simpler to read and write.
EDIT: You can break form a range-for without abusing an exception.
std::for_each, ironically, is the alternative which is actually range based and allows you to select particular begin and end values instead of the whole container.
(EDIT: This can be hacked around using a simple range class providing begin and end members, such as provided by Boost.)
The range based for loop is just a loop, so any state that is to be used outside of the loop has to be declared outside of that scope.
By the way, the range based loop works on C-style arrays and std::strings too.
If you want to unhide hidden rows/columns, you'll need to ensure you have the range's sheet suitably unprotected.
tp is arraylist of ports plus the range of ports.
listbox14 are the ports range we need to compare with items 10-80,
So now listbox contains all the range items I need to compare!
I don't think it will work like that out of the box as equal_range returns a pair of iterators while, the for cycle over range according to [documentation (hyper-link)] are:
As per [Why was pair range access removed from C++11?
the as_range at the accepted answer, [boost::make_iterator_range (hyper-link)], or write your own:
mismatch and partition_copy return a pair of iterators from different ranges;
minmax returns a pair of objects that may not be iterators at all, and if they are there's no guarantee they form a range;
minmax_element can return a range, but it can also return a reversed range (e.g.
on a reverse-sorted range minmax_element will return {prev(last), first};
equal_range is guaranteed to return a range.
What std::equal_range returns is simply a std::pair.
An excellent read on a more elegant way to iterate containers using Ranges.
Ranges are implemented in his [Loki (hyper-link)] library.
The idea is to count the overlap within each group, sum the overlaps, and then compare to the actual range.
Try Range("A1230").Resize(351)
