["kron produces:\n", "kron reshapes it to a combination of the shapes of A and B:\n", "With your kron:\n", "This call to kron is not memory intensive.\n", "You can't find both A and B, given a K, because there could be many possible A's and B's to produce a certain kron matrix, K. Thus, alongwith K, you need either A or B to get the remaining input B or A respectively.\n", "Case #1 Given A and K (kron matrix), you can find B with -\n", "Case #2 Given B and K (kron matrix), you can find A with -\n", "For vector inputs to kron, this would work -\n", "It is because kron already reshapes the matrices in its arguments and doesn't dim-check further (assumes 2D).\n", "From kron.m for full matrices we can see the problem:\n", "You can either loop as you have done already or just modify the kron function and make sure that the remaining dimensions are preserved during kroning.\n", "As I commented, your kron with 3 arguments is unknown.\n", "With the kron that you added, the recursive step does:\n", "For 2 items, your kron returns a nested tuple of arrays.\n", "np.kron applies a np.asanyarray(b) to that 2nd argument, which results in a 4d array.\n", "Applying your kron to  full *m, but turning the matrices into arrays:\n", "Did you even test the kron function by itself?\n", "Let's do the kron without reshaping:\n", "In any case it's evident from the output that this tensordot is producing the same numbers - but the layout is different from the kron.\n", "I can replicate the kron layout with\n", "And omitting the reshape, I get the same (2,2,2,2) you get from kron:\n", "Uncommenting the second line might affect where ones and kron comes from.\n", "Now you just have to add a __kron__(self, other) method on the relevant types (assuming you have control over these types or they don't use slots or whatever else that would prevent adding methods outside the class statement's body).\n", "Another solution would be to maintain a type:specifici function mapping and have the \"generic\" kron function looking up the mapping, ie:\n", "If the Kronecker product only works on two similar classes, you can even do the type checking in the function :\n", "Then, you just need to define a _kron_ method on the class.\n", "This is only some basic example, you might want to improve it to handle more gracefully the cases where a class doesn't have the _kron_ method, or to handle subclasses.\n", "However, there is nothing stopping you from defining a kron function that does the same thing; look for __kron__ or __rkron__ on the objects passed to it:\n", "One possible way to improve this is by calling matlab.internal.sparse.kronSparse in some blockwise manner and store the intermediate results in the correct position of the output array, but this should require some careful thought.\n", "BTW, I tried using the FEX submission that Ander mentioned ([KronProd (hyper-link)]) but it provides no benefit when you need to compute kron(A,B) + kron(C,D) (although it's amazing for kron(A,B)\\b situations).\n", "Kron totally fails.\n", "Verify output by comparing against [kron (hyper-link)] for generic matrix sizes -\n", "Hint no.2: For some complex functions (like kron), if your input and output is of fixed size, it might be possible to obtain register-level optimized, linear, non-iterative, non-branching code using computer algebra system like Wolfram Mathematica.\n", "Also, mathematically speaking, the kronecker product of a row vector and a column vector is essentially their outer product.\n", "So, you could do the same thing using Kronecker products as:\n", "You can use kron:\n", "kron doesn't work for 3D, but indexing does:\n", "In case when the first operand is the identity matrix, then the result of the Kronecker product can be simply represented using cuSPARSE's bsr's format.\n", "KRON(I, T)\n", "Also in simple cases when the second operand is the identity matrix, the result of the Kronecker product can be represented using cuSPARSE's bsr's format.\n", "KRON(S, I)\n", "After cracking my head around in finding the index relation of the for loops to do the kronecker tensor product.\n", "I point out that sparse.kron produces, by default a BSR format matrix.\n", "If you specify another format, kron will not produce  those zeros:\n", "res is computed by FFT from  mat = kron(C2, Rn), and this is (as you say) a wasteful way of doing kron(C2, fft(Rn)) since it the FFT along the k dimension is re-done for each of the 2\u00d72 other dimensions.\n", "But the point, presumably, is to do this for \"entangled\" states in the product space -- a generic likemat = rand(8,2) cannot be decomposed into factors kron(likeC2, likeRn).\n", "Combining with kron will then always be wasteful.\n", "The package Kronecker.jl may help for some things, but I don't think it knows about fft.)\n", "This uses my package to handle kron-like operations; you could just write out the necessary reshapes yourself, too.\n", "While the kron solution is by far the simplest (and you can always dump it into a list with [.tolist (hyper-link)]), let's look at a pure python implementation.\n", "There are two parts here: how to implement kron, and how to reshape a list.\n", "produces the same result as H = kron(A,B) except that the order of elements are changed.\n", "So the expected result can be computed without using kron:\n", "That is exactly what the error is telling you: kron must have an explicit shape.\n", "If you do not want to pass the array sizes beforehand, you'd have to define kron as\n", "You just need to define the allocatable array as allocatable, i.e replace the kron definition with;\n", "The outer () surround the arguments being passed to the kron function, and the inner () provide the index into PI.\n", "However, the two kronecker products are similar, via a permutation matrix, i.e., one has:\n", "Then the two kronecker products are:\n", "Remember that adding a bunch of vector outer products (which you can treat the Kronecker products as) ends up as a matrix-matrix multiplication, which BLAS's DGEMM can handle efficiently.\n", "If we're progressively selecting pairs of vectors A and B and adding them to some 'running total' vector/matrix C, the following modified version of the above kron function\n", "The initial kron function is DGER with alpha = 0 and C being an uninitialised (zeroed) matrix/vector of the correct dimensionality.\n", "As for your original question, as far as i know none of those libraries implements a kron function, since it is only a \"convenience\" routine.\n", "As there was a problem with the implicit impl variable of kron, I also rewrote the function call to explicitly state which variable to use to use\n", "By copying the function and making it specific for Complex numbers, I was able to get the kronecker product to work.\n", "Now I could also remove the explicit use of (kron.kronDM_M[Complex, Complex, DenseMatrix[Complex], Complex]).\n", "Use [sparse.kron (hyper-link)] for the Kronecker product of sparse matrices.\n", "[numpy.kron (hyper-link)] does not handle sparse matrices.\n", "I am not sure about the definitions used by the [Vec Operator (hyper-link)], the [Kronecker Product (hyper-link)] and the identity matrix defined in the chapter:\n", "to eliminate the need for explicitly calculating the Kronecker product and replacing it with a level 3 BLAS gemm call instead.\n", "The other identity which could potentially useful would be to calculate the Kronecker product using an outer product (rank 1 update in level 2 BLAS IIRC):\n", "Note again that the ordering of the resulting matrix will not be the same as the Kronecker product of the matrices A and B.\n", "I am not aware of a CUDA library for computing the true Kronecker product of a pair of arbitrary sized matrices.\n", "For example, that horrible kron thing you're doing...\n", "You could refactor your kron nesting like this:\n", "I don't know what \"better\" means but here are some alternatives to kron(eye(m),ones(n,1)):\n", "sparse.kron(Hb, \u0393) with your sparse Hb should give the same thing, but as a sparse matrix.\n", "I suspect from the error message that kron(Hb, \u0393)*[[1],[0]] is attempting a matrix product.\n", "While the 2nd argument is clearly (2,1), I don't see why the first, the kron() is (3,3).\n", "This way you can also avoid kron itself which is not the fastest itself.\n", "Here is a vectorized version using kron (not as fast as [thewaywewalk (hyper-link)] 's answer):\n", "Applying a numeric operation (such as kron) to a char automatically converts the characters to their [ASCII codes (hyper-link)].\n", "The kronecker product of two vectors is just a reshaped result of the matrix multiplication of both vectors:\n", "Using the rewriting of the Kronecker product given by Daniels answer\n", "Here's the explanation that might also help you in the future:\nLooking at the kron definition, the result when inserting an m by n and a p by q matrix has size mxp by nxq, in your case 400 by 1001 and 1000 by 1000, that makes a 400000 by 1001000 matrix, which has 4*10^11 elements.\n", "because the size of the array generated by repmat([1 2 3],1,4) has always the same length while the length of the arrays generated by using kron and randperm changes according to the definiton of day and repeat.\n", "Should work, broadcasting the kron to  all 3 planes.\n", "kron is specialized rearrangement of the outer product of a and b.\n", "[Why is numpy's kron so fast?\n", "As I showed before, kron can be produced by applying a transpose and shape to an outer product.\n", "or even better (a view of the kron witout copies):\n", "Also that braodcast_to isn't faster, though that's largely the fault of kron (which my previous answer showed was on the slow side).\n", "The solution has been modified based on the implementation of [kron in numpy (hyper-link)].\n", "Note that this is not a generalisation of the kron implementation of numpy because this is not going to work for cases where you just want to do a straightforward kron operation.\n", "Maybe np.kron() is allocating memory and then you're throwing it away.\n", "If you're only multiplying EV_subset by ones, you don't really need to call np.kron().\n", "You can certainly take a look at the source for np.kron.\n", "(maybe this is kron(B,A) instead of kron(A,B); reverse A & B if needed)\n", "This doesn't prove that kron is fastest, but I compared its time to how long it would just take to populate a similarly sized Array with ones, and kron did quite well:\n", "Unlike kron, it's very readable and understandable.\n", "Even so, I'd only use kron if you've identified it as a performance bottleneck.\n", "It now rivals kron:\n", "You can wrap the kron function and do as you would do in Matlab and Python.\n", "Note that Kronecker product is defined on single channel matrices, so you need to split the planes BGR matrix, apply kron, and then merge back.\n", "b is different, the most common suggestion is to use kron(a', ones(2,3)) but here are some alternatives: [A similar function to R's rep in Matlab (hyper-link)]\n", "And voila, behold the Kronecker product of a and b.\n", "But Atemp.^2./Btemp.^1.5 can be simplified to kron(1./(B.^1.5), A.^2) to avoid some of the large temporal matrices and increase the speed.\n", "the kron_and_sum example)\n", "#   1 MAG_AUTO            Kron-like elliptical aperture magnitude         [mag]\n", "['#', '1', 'MAG_AUTO', 'Kron-like', 'elliptical', 'aperture', 'magnitude', '[mag]']\n", "The [kron (hyper-link)] function does exactly that:\n", "Others will get significantly slower for larger sizes but won't error due to exhausted memory (the kron solution for instance).\n", "I removed the kron function because it wasn't doing anything here and CVXPY doesn't currently support Kronecker products with a variable left-hand side.\n"]